

## Binary adder

An adder, as its name implies, is a circuit for adding binary numbers. The simplest adder adds two bits. 
As shown above, adding two bits can result in the following:

![](./images/Lesson13-28.png)

When adding, two parts are produced: a sum and a carry (each of which can be either 0 or 1). A circuit 
to implement the behavior of an adder will need two inputs (one for each of the single-bit numbers) and 
two outputs (one for the sum and one for the carry). Constructing such a circuit is fairly straightforward.
Consider the following truth table for the adder (where S is sum and C is carry):

![](./images/Lesson13-29.png)

Notice that the values in the S column correspond to an xor of the two inputs, while the values in the C 
column correspond to an and of the two inputs. Here are their respective truth tables for reference:

![](./images/Lesson13-30.png)

Note how the output of the *xor* gate is exactly the same as the sum bit produced by the adder. Similarly, 
the output of the *and* gate is exactly the same as the carry bit produced by the adder. Constructing the 
circuit is almost too easy:

![](./images/Lesson13-31.png)

This circuit is called a **half adder**. It has two Boolean expressions: $S=(A \cdot \bar{B})+(\bar{A} \cdot B)$ and $C=A \cdot B$ . 
While a half adder does add two single-bit numbers and can generate a carry, it has no provision for a 
carry *input* into the circuit. As shown above, when adding two multi-bit binary numbers, one works 
column by column from right-to-left, making sure that the carry bit from the previous column is added 
into the current column. Here is the illustration of this process show earlier, on 38 and 15:

![](./images/Lesson13-32.png)

A half adder could be used to add the right-most (low-order) bits of the two numbers, but it is not 
general enough to add the digits of an arbitrary column since it does not support a carry as input.

A **full adder** overcomes this limitation of the half adder by allowing a carry to be fed into the circuit 
along with a bit from each of the numbers to be added. Thus, a full adder will have three inputs: the two
bits being added, plus a *carry* *in*. Only two output bits, the sum and a *carry* *out*, are needed because the 
largest result that can be produced by the circuit will be three (11~2~). This occurs when all three inputs 
are 1. Here is a complete truth table for a full adder. The inputs are almost the same as before, except 
that the carry in is labeled C~in~, and the carry out is labeled C~out~:

| C~in~ | A | B | S | C~out~ |
|--|:--------|----|----|----|
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 0 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

Designing a circuit to implement this behavior from scratch would be challenging. However, through 
careful observation and the use of two half adders, the job is manageable. Since we’ll be using half 
adders to build the full adder, our circuit diagram will be simpler if we imagine the half adder 
encapsulated into a *black box*, as shown below:

![](./images/Lesson13-34.png)

The trick to building a full adder is to think of the sum of the three terms, A + B + C~in~, as a sequence of 
two sums associated left to right: (A + B) + C~in~. One half adder will be used to compute the sum A + B. 
The *sum* bit output by this half adder, along with C~in~, will be fed as input into a second half adder. The 
*sum* bit produced by the second half adder will serve as the *sum* bit of the full adder. The *carry out* bit 
of the full adder is produced by routing the *carry out* bits of both half adders into an *or* gate. This is 
illustrated below:

![](./images/Lesson13-35.png)

::: {.callout-important title="Activity" collapse=false}
Try to develop a complete implementation of the full adder using only and, or, and not gates.

Now verify that this circuit does, in fact, generate the truth table for binary addition.
:::

Just as we encapsulated the half adder, we can encapsulate the single-bit full adder into a black box.

![](./images/Lesson13-36.png)

This representation looks a little different than the previous circuit because it has been rotated clockwise 
90 degrees to make the following figure easier to read. Note that the inputs, outputs, behavior, and 
internal details of the circuit remain unchanged.

Multi-bit adders can be implemented as a chain of single-bit full adders where the *carry out* of each 
adder is routed to the *carry in* of the adder immediately to its left. Under this scheme, each full adder is 
essentially responsible for adding a single bit of each of the two input numbers, plus the carry bit 
generated by the adder immediately to its right. The *carry in* for the rightmost adder is permanently set 
to 0. The *carry out* of the leftmost adder indicates whether or not addition of the inputs produces an 
overflow. We will cover why this is necessary later when discussing how numbers are represented.

Here's a four-bit adder constructed from four single-bit (full) adders. In this example, A holds the 
number six (0110~2~) and B holds seven (0111~2~). The result of this addition operation is 1101~2~, or thirteen:

![](./images/Lesson13-37.png)

Interestingly, we can continue to build this. To illustrate this, let's go back one step to the full adder. 
We can chain two full adders together (each of which can effectively produce the sum and C~out~ of A, B, 
and C~in~) to produce the sum of two 2-bit numbers as follows:

![](./images/Lesson13-38.png)

Indeed, 10~2~ + 11~2~ = 101~2~ (the overflow bit is 1). And now we can box the two full adders into a single 2-
bit adder as follows:

![](./images/Lesson13-39.png)

The result is the same as chaining two full adders. The C~out~ of the first full adder that is wired to the C~in~
of the second full adder is now internal to the 2-bit adder. This 2-bit adder effectively adds two 2-bit
numbers (A and B composed of the bits A~0~, A~1~, B~0~, and B~1~). It produces two sums (S~0~ and S~1~ – one for 
each bit) and a Cout (the overflow bit).

We can chain several 2-bit adders in a similar manner to produce a 4-bit adder as follows:

![](./images/Lesson13-40.png)

The effect is the same as show earlier when we chained four full adders. This combination of two 2-bit 
adders produces the same sum: 0110~2~ + 0111~2~ = 1101~2~ (the overflow bit is 0).
Of course, this can be continued. We could encapsulate the two 2-bit adders into a 4-bit adder, and 
chain two of those to produce a single 8-bit adder. Two 8-bit adders could be encapsulated into a single 
16-bit adder. Two 16-bit adders could be encapsulated into a single 32-bit adder. And this can go on 
and on. The incredible part about this is that, in the end, a seemingly complicated 32-bit adder is still 
just made up of many full adders chained together, which are themselves made up of half adders, which 
are themselves made up of the three primitive logic gates: *and*, *or*, and *not*. Simply amazing!
