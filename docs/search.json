[
  {
    "objectID": "lessons/05 Chaos/01 Introduction.html",
    "href": "lessons/05 Chaos/01 Introduction.html",
    "title": "Chaos",
    "section": "",
    "text": "In this lesson, we are going to study chaos and order. While they intuitively mean the complete opposite of each other, we will find out that there is in fact a very close relationship between the two. Often, if you look closely enough at something apparently chaotic, you may find that there is some order to it after all."
  },
  {
    "objectID": "lessons/05 Chaos/01 Introduction.html#the-coordinate-system",
    "href": "lessons/05 Chaos/01 Introduction.html#the-coordinate-system",
    "title": "Chaos",
    "section": "The coordinate system",
    "text": "The coordinate system\n\n\n\n\n\n\nDefinition\n\n\n\nA coordinate system allows us to represent positions of a specified dimension in a reproducible fashion.\n\n\nThis means that if someone describes a position to us using a coordinate system, we can accurately represent that position. For example, the two-dimensional coordinate system allows us to represent points on a flat plane (similar to the page of a book or a white board on a wall). The system is made up of two axes that are perpendicular (i.e., at 90 degrees) to each other, and which meet at a point referred to as the origin. The position of any point on that plane is described using two values that describe how far away from the origin the given point is along both predefined axes. We typically refer to these axes as X and Y, with the X-axis oriented horizontally (i.e., left-to-right), and the Y-axis oriented vertically (i.e., up-to-down). Although this represents a way to locate points in two dimensions, we can extend this to more dimensions. For example, we can add an axis oriented at an angle (technically, you can think of it as being perpendicular to both the X- and Y-axes and going through the page or the white board). This adds a third dimension to the coordinate system and allows the location of objects in three-dimensional space.\nEach axis in a coordinate system has values along it that demarcate one-dimensional positions. Although we have freedom in what those values are, we typically center the origin at the X-value 0 and the Y-value 0. We call this a point. The origin, then, rests at point (0, 0). The values along an axis typically increase or decrease by 1. Here’s an example of a two-dimensional coordinate system:\n\n\n\n\n\nWhen specifying points on the coordinate system, we typically list the X-component first, followed by the Y-component. That is, the point (2, 3), for example, has an X-value of 2 and a Y-value of 3. We could plot this point as follows:\n\n\n\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nCan you place these five points in their proper positions on the coordinate system below: (3, 5), (5, -2), (1, 2), (-3, -5), and (-4, 0)?\n\n\n\n\n\n\n\n\nAnother benefit of using the coordinate system for describing the position of different points is that it allows us to easily calculate and plot a point in the middle of two points. We call such a point the midpoint of the two points. If two points were drawn on a plain piece of paper, and we were asked to mark the point in the exact middle of those two points, it would be a long and (many times) inaccurate process. However, having the coordinates of the two points makes this simple. The midpoint of two points is calculated by adding the corresponding coordinates and dividing by two to find the average of each component. For example, the midpoint of the points (5, -2) and (1, 2) is given by the following coordinates:\n\\[(\\frac{5+1}{2}, \\frac{-2+2}{2})=(3,0)\\]\nThat is, the x- and y-components of each point are averaged to find the x- and y-components of the midpoint. Similarly, the midpoint of the points (-3, -5) and (7, 3) is given by the following coordinates:\n\\[(\\frac{-3+7}{2}, \\frac{-5+3}{2})=(2,-1)\\]\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to calculate the midpoints of the following point combinations in the space below:\nPoints (0, 0) and (4, 4):\nPoints (-3, 5) and (-1, -3):\nPoints (4, -4) and (-4, -4):\nNow plot the given points and the calculated midpoints below:"
  },
  {
    "objectID": "lessons/05 Chaos/01 Introduction.html#the-chaos-game",
    "href": "lessons/05 Chaos/01 Introduction.html#the-chaos-game",
    "title": "Chaos",
    "section": "The chaos game",
    "text": "The chaos game\nThe chaos game is an interesting (and, hopefully, fun) game that illustrates how seemingly random and chaotic things can produce something orderly (and beautiful) over time. It works in a simple manner. First, plot the three vertices of an equilateral triangle. An equilateral triangle is unique in that each of its three sides are the same length, and each of its three vertices are equidistant to each other. Since the internal angles of a triangle always sum to 180 degrees, each angle of an equilateral triangle is the same (i.e., each angle is 60 degrees).\nHere is an example of the vertices of an (almost) equilateral triangle:\n\n\n\n\n\nNotice that the three vertices of the equilateral triangle are drawn on a coordinate system at the points (0,0), (15,0) and (7.5,13). Although these points are not “perfectly” equidistant, they are nearly so (and good enough for this example).\nSecond, randomly select two of the three vertices. Suppose that the top and bottom-right vertices are randomly selected. Calculate the midpoint between these two vertices using the midpoint formula as illustrated above. In general, given two points (x1, y1) and (x2, y2), the midpoint can be calculated as follows:\n\\[(\\frac{x_1+x_2}{2}, \\frac{y_1,y_2}{2})\\]\nThe midpoint of the top and bottom-right vertices at points (7.5, 13) and (15, 0) is calculated as follows:\n\\[(\\frac{7.5+15}{2}, \\frac{13,0}{2}) = (11.25,6.5)\\]\nThe midpoint, (11.25, 6.5), is then plotted on the coordinate system.\nThe game now follows a repeatable pattern. The calculated midpoint at point (11.25, 6.5) is selected, along with one randomly selected vertex of the equilateral triangle. Suppose that the top vertex at point (7.5, 13) is randomly selected. A new midpoint is now calculated:\n\\[(\\frac{11.25+7.5}{2}, \\frac{6.5,13}{2}) = (9.375,9.75)\\]\nthis new midpoint is then plotted on the coordinate system, and the process continues (i.e., the latest midpoint is selected, along with a randomly selected vertex of the equilateral triangle). Here is the algorithm in pseudocode:\nv1, v2, v3 ← three vertices of an equilateral triangle\nplot v1, v2, and v3\np1, p2 ← two randomly selected vertices from v1, v2, and v3\nm ← the midpoint of p1 and p2\nplot m\nrepeat\n  v ← a randomly selected vertex from v1, v2, and v3\n  m' ← the midpoint of m and v\n  plot m'\n  m ← m'\nuntil midpoints plotted &gt;= 1500 or tired\nBy playing the chaos game for some time, what do you think will happen? Where do you think the points will focus on the coordinate system? Will they collect in any one place at all?\n\n\n\n\n\n\nActivity\n\n\n\n\n\nLet’s play this game a little bit to see if anything can be gleaned (i.e., if anything reveals itself). Mainly, we want to see if the points just randomly fill the coordinate system, or if they somehow produce something orderly.\nTo obtain results quickly, use blank sheets of paper (or even better, transparencies). You should plot the exact same vertices of an equilateral triangle. From there, play the chaos game and plot approximate midpoints. That is, estimate as best as possible (by looking) where the midpoint should be plotted. Remember that, to plot the first midpoint, two random vertices are selected. From that point on, the last plotted midpoint and one randomly selected vertex is used to compute the next midpoint.\nSo what is the result?\n\n\n\n\n\n\n\n\n\n\nDid you know\n\n\n\nFor any pattern to be revealed, a single person would have to plot thousands of points (which would take a really long time). There is a whole branch of computer science that deals with making computers faster, particularly for large tasks. One of the techniques that addresses this involves dividing tasks so that small sub-tasks are done concurrently (i.e., at the same time). This field is called high performance computing, and the technique employed is called parallelism.\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nAs you can see, it takes a lot of points to plot anything reasonable. That is, in order to actually see if anything orderly is produced when playing the chaos game, a lot of midpoints must be calculated and plotted.\nThere are also a lot of other interesting things that can be tried. For example, what would happen if the three vertices were not equidistant; that is, what if the triangle was different? What if we plotted a square instead (i.e., four vertices instead of three)? What about a pentagon? What would happen if, instead of plotting midpoints, points at varying distances were plotted instead. For example, would the result be different if a three-fourths point was plotted instead each time (i.e., instead of 50% of the distance to the randomly selected vertex, 75% of the distance). What about 10% of the distance? What would happen if there was an additional rotation about the randomly selected vertex? That is, what would be the result if some midpoint (or other distance) were calculated and then rotated about the vertex some number of degrees (some angle)?\nThese are all interesting questions that may result in absolute randomness (or perhaps not!). It would be quite difficult to try these manually. Why not automate this process? A frequent task of computing professionals is to automate things that tend to be repeated. To illustrate a number of changes to the chaos game in a configurable manner, a simple application has been created to test out all of the options.\nThe goal of this activity is to play around with this application to see how changes to the chaos game affect the outcome. Try your hand at it!"
  },
  {
    "objectID": "lessons/05 Chaos/01 Introduction.html#fractals",
    "href": "lessons/05 Chaos/01 Introduction.html#fractals",
    "title": "Chaos",
    "section": "Fractals",
    "text": "Fractals\nBy now, you should have noticed that the result of the original chaos game (i.e., three vertices of an equilateral and repeatedly plotting midpoints) results in a beautiful triangular shape. In fact, this shape has an interesting property: it has its pattern repeated over and over. It’s as if we could zoom in forever and obtain the same pattern! This property is found in fractals. This particular fractal has a name: the Sierpinski Triangle.\n\n\n\n\n\n\nDefinition\n\n\n\nA fractal is a geometric shape that can be (infinitely) broken down into similar parts.\n\n\nThis means that it is made up of many parts that are just smaller versions of the whole thing. And these smaller parts are then made up of even smaller versions of the whole thing. And this goes on infinitely (well, basically). Of course, our eyes can’t see this going on infinitely because things get too small."
  },
  {
    "objectID": "lessons/05 Chaos/01 Introduction.html#randomness-and-probablility",
    "href": "lessons/05 Chaos/01 Introduction.html#randomness-and-probablility",
    "title": "Chaos",
    "section": "Randomness and probablility",
    "text": "Randomness and probablility\nIn the chaos game, random vertices of an equilateral were repeatedly selected. What does random mean exactly? We have seen that there is sometimes order in chaos if you look long and close enough. That being said, there are things that seemingly happen in a haphazard manner, have no predictable pattern, and are not predetermined. Such things are called random. Think of selecting one of the three vertices. We have no way of predicting which vertex will be selected. Any one could be selected at each iteration. Think of rolling a die. There is no way to predict which number will be rolled next (other than to say that it will be between 1 and 6 inclusive).\nEven with random things, human beings have come up with a way of measuring the randomness, and that way is called probability. Probability is a way of expressing the knowledge that something will happen. If something is definitely going to happen (i.e., it’s absolute certainty), it is said to have a probability of 1. If something is definitely not going to happen (i.e., it’s an impossibility), it has a probability of 0. Of course, there are an infinite amount of values in between 0 and 1. That is, the probability that something could happen can be stated as a value between 0 and 1.\nFormally, probability is defined as the ratio of the number of ways of achieving success to the total number of possible outcomes. For example, consider the flipping of a coin. There are two possibilities when flipping a coin: either heads or tails. So there are two possible outcomes. The probability of landing on heads when flipping a coin is then 1/2. Why? The only way to land on heads is, well, to flip heads. That is, there is only one way to achieving success. Since there are two possible outcomes when flipping a coin, the probability of landing on heads is therefore 1/2 (one way of achieving success out of two possible outcomes). Similarly, the probability of landing on tails when flipping a coin is also 1/2.\nWhat is the probability of picking the top vertex in the chaos game? There’s only one way to do so out of three possible vertices. Therefore, the probability is 1/3.\nLet’s go back to rolling a typical (six-sided) die. What is the probability that a three is rolled? Rolling a three represents the only way to achieve success. There are six possible rolls of the die. Therefore, the probability of rolling a three is 1/6.\nWhat is the probability that an even number is rolled? Well, how many ways are there of achieving success? That is, how many ways can an even number be rolled? Three (rolling a two, four, or six). The possible outcomes are, of course, rolling a one through six. So the probability of rolling an even number is 3/6 = 1/2.\nWhat is the probability that a number less than six is rolled? There are five ways to roll a number less than six. There are six possible rolls of a die. The probability is therefore 5/6.\nWhat is the probability of rolling two die and getting a total of 7? This one is a bit tricky! We’ll discuss this later (but if you want to know, it’s 1/6).\n\n\n\n\n\n\nActivity\n\n\n\n\n\nFor this activity, we will repeatedly flip two coins simultaneously and record the results. The two coins can either both be heads, both be tails, or they can be different (i.e., one is heads and one is tails). So there are three possible outcomes to this game. The probability of both coins landing on heads is therefore 1/3, both landing on tails is also 1/3, and one landing on heads and the other on tails is also 1/3.\nTo make this interesting, let’s make it a game. If both coins land on heads, all of the students seated in the left half of the class (on the left side from the prof’s perspective) get a point. If both coins land on tails, all of the students seated in the right side of the class get a point. If one coin lands on heads and the other lands on tails, the prof gets a point. The group (or individual) with the most points at the end of some number of flips (say, 15) wins.\nOver time, you will find that the students lose more often. It appears that the heads and tails combination happens significantly more often than initially thought. In fact, the previously calculated probabilities (each 1/3) seem incorrect.\nThe purpose of this activity is to show that perceived probabilities are often different from actual probabilities (i.e., humans are not always so good at estimating probabilities). Think of it like this: there is only one way of both coins landing on heads. There is only one way of both coins landing on tails. Contrary to what was previously assumed, there are two ways of ending up with one coin landing on heads and the other landing on tails: the first coin can be heads and the second coin can be tails, or the first coin can be tails and the second coin can be heads! In fact, there are a total of four possible outcomes. The flipping of two coins can then be shown in the following table:\n\n\n\nCoin 1\nCoin 2\n\n\n\n\nheads\nheads\n\n\nheads\ntails\n\n\ntails\nheads\n\n\ntails\ntails\n\n\n\nThe probability of both coins landing on heads is 1/4 (one possible way of achieving success out of four possible outcomes as show above). The probability of both coins landing on tails is also 1/4. But the probability of one coin landing on heads and the other landing on tails is actually 2/4 = 1/2! The prof wins 50% of the time! Another way of saying this is that the prof wins twice as much as either group of students! Ka-ching!\nWhen you realize how rigged this simple game is, you can begin to think about how even more rigged other games (such as slot machines, the lottery, etc) are…\nTry to calculate the probability of flipping three coins and getting three heads. Or three tails. Or one heads and two tails.\nProbability of ending up with three heads:\nProbability of ending up with three tails:\nProbability of ending up with one heads and two tails:\nProbability of ending up with one tails and two heads:"
  },
  {
    "objectID": "lessons/05 Chaos/01 Introduction.html#random-number-generators",
    "href": "lessons/05 Chaos/01 Introduction.html#random-number-generators",
    "title": "Chaos",
    "section": "Random number generators",
    "text": "Random number generators\nIn the last RPi activity (titled My Binary Addiction…Reloaded), you may have noticed the use of a library that allowed the generation of random numbers. In the activity, it was used to generate random bits (0 or 1) for each of the two 8-bit numbers (in order to generate two random 8-bit numbers). The library was called random and was imported as follows:\nfrom random import randint\nThe function randint was then used to generate the random numbers. As mentioned earlier in this lesson, a truly random event has no predictable pattern. Unfortunately, there is no easy way for that to happen using a computer, even for a task as simple as selecting random numbers within a specific range. As a solution, computers typically use a pseudo-random process to create random numbers in a range.\n\n\n\n\n\n\nDefinition\n\n\n\nA pseudo-random process is one that appears to be random but is technically deterministic in nature. This means that the process looks completely random, and yet its pattern is predictable and can be reproduced exactly.\n\n\n\n\n\n\n\n\n\nDid you know\n\n\n\nThe most common algorithm for random number generation is called Mersenne Twister and is the one Python uses. Google it to find out more.\n\nWhen tasked with creating a random number (or group of numbers), computers typically use a pseudo- random process to produce that number. This means that, given enough generated numbers, one can observe that the created numbers follow a certain sequence. For most purposes, however, the amount of numbers one would require to observe that the pattern is predictable is too large (so the numbers seem random).\nFor most cases, pseudo-random numbers are adequate and even beneficial. How? For instance, often researchers replicate experiments in order to confirm (or refute) experiments performed by peers. For a scientist to make any claim about any experiments carried out, enough information for someone else to reproduce those same results with an experiment of their own must be provided. When a random number (or list of random numbers) is used in an experiment, there would be no way of replicating those exact numbers (and therefore obtaining the same results as in the original experiment). However, since computers produce pseudo-random numbers (which can be replicated exactly), it allows other researchers to carry out their own versions of the original experiment and crosscheck to see if the results are identical.\nIn order to actually generate repeatable (even predictable) patterns of random numbers, most pseudo- random number generators can be configured or initialized with a seed.\n\n\n\n\n\n\nDefinition\n\n\n\nA seed is just a number that is used to initialize a pseudo-random number generator.\n\n\nMost generators use the current time (to the second) as the seed. Clearly, this means that generating a sequence of random numbers will be different each time (since time moves forward continuously). We can, however, specify a seed of our own so that the pseudo-random number generator will always provide the same sequence of numbers!\n\n\n\n\n\n\nActivity\n\n\n\n\n\nLet’s create a simple program generates 100 pseudo-random numbers (in the range 0-99) twice:\nfrom random import randint\n\nfor i in range(1, 101):\n  print(\"{}\\t\".format(randint(0, 99))),\n  if (i % 10 == 0):\n    print()\nprint()\nfor i in range(1, 101):\n  print(\"{}\\t\".format(randint(0, 99))),\n  if (i % 10 == 0):\n    print()\nNote the use of “\\t” (which prints a tab and is typically eight spaces in width). Characters that begin with a backslash (\\) are known as escape characters. Escape characters typically allow the representation of unprintable characters (such as a tab, newline, carriage return, etc). Most general purpose programming languages (including Python) support these unprintable characters. Here are some common ones:\n\\n Linefeed (like pressing Enter)\n\\t Horizontal tab\nNote that there are many others, some of which are even programming language specific.\nThe program above first displays 100 random integers in the range 0-99, and formats them such that ten integers are displayed on each line (i.e., ten rows of ten columns). They are aligned at the columns via a horizontal tab that follows each integer. Note the comma at the end of the print statement. This instructs Python to omit a typically default linefeed at the end of the print statement. Once ten integers have been displayed on a single line (i.e., i % 10 == 0), a blank line is added (via the solitary print statement). The program then displays another 100 random integers in the same manner. Note the variety (and randomness) of the generated integers, although generating 200 integers in the range 0-99 will undoubtedly produce duplicates.\nIn the above example, the pseudo-random number generator was seeded with the current time (by default since no numeric seed was provided). Let’s modify the algorithm and use an identical (but specified) seed value for each 100 random integers:\nfrom random import randint, seed\n\nseed(123456)\nfor i in range(1, 101):\n  print(\"{}\\t\".format(randint(0, 99))),\n  if (i % 10 == 0):\n    print()\nprint()\nseed(123456)\nfor i in range(1, 101):\n  print(\"{}\\t\".format(randint(0, 99))),\n  if (i % 10 == 0):\n    print()\nIn this case, the numeric value 123456 is used as the seed to generate both groups of 100 integers. Technically, the seed could be any value (e.g., 0, some variable containing a value, even the mathematical constant pi). In fact, we could have randomly generated a seed!\nseed(randint(0,65535))\n\n\n\nNow that you have seen how to use Python to generate pseudo-random integers, let’s try to write programs that implement some of the activities shown earlier in this lesson.\n\n\n\n\n\n\nActivity\n\n\n\n\n\nEarlier we discussed rolling a single die and the associated probabilities of each possible roll. Then, we asked what the probability of rolling two dice and getting a total of 7. Let’s try to write a Python program that iterates through all of the possibilities when rolling two dice. Here is the code and output:\n# a list containing the frequencies of the 11 possible sums (2 \n# through 12). this initializes a list of 11 elements, all with the\n# value 0\ndice_sums = [0] * 11\n\n# display the possible rolls of two dice\nprint(\"Die1\\tDie2\\tSum\")\n\n# iterate through the values of die 1\nfor die1 in range(1, 7):\n  # for each value of die 1, iterate through the values of die 2\n  for die2 in range(1, 7):\n    # calculate the sum of both dice\n    dice_sum = die1 + die2\n    \n    # increment the frequency of each sum\n    # the smallest possible sum, 2, is at index 0 of the list\n    # so subtract 2 from the index\n    # the frequency of rolling a 2 is at index 0 of the list\n    dice_sums[dice_sum - 2] += 1\n\n    # display the values for this roll\n    print(\"{}\\t{}\\t{}\".format(die1, die2, dice_sum))\n\n# display the sum frequencies\nprint(\"\\nSum\\tFreq\\tProb\")\nfor i in range(len(dice_sums)):\n  # i starts at 0, but we want to begin the sums at 2\n  print(\"{}\\t{}\\t{}\".format(i + 2, dice_sums[i], dice_sums[i] / sum(dice_sums)))\nThe number of total sums possible is 36. We can calculate this by taking the sum of the frequencies (1 + 2 + 3 + 4 + 5 + 6 + 5 + 4 + 3 + 2 + 1 = 36). Since there are six rolls that sum to 7, then the probability of rolling two dice and getting a 7 is 6/36 = 1/6. In fact, the probability of rolling two dice and getting a 7 is higher than anything else!\nNow let’s try to roll two dice many times and see what results we end up with. Perhaps the frequencies of the sums will match the frequencies shown above! Here’s the code and output:\nfrom random import randint, seed\n\n# simulates the roll of a die\ndef roll():\n  return randint(1, 6)\n\n# get the number of rolls and seed desired\nnum_rolls = 5000\nrand_seed = randint(0, 65535)\ndice_sums = [0] * 11\n\nprint(\"Rolling two dice {} times with a seed of {}.\".format(num_rolls, rand_seed))\n\n# seed the number generator\nseed(rand_seed)\n# roll the dice\nfor i in range(0, num_rolls):\n  die1 = roll()\n  die2 = roll()\n  # calculate the sum\n  dice_sum = die1 + die2\n  # update the sum frequencies\n  dice_sums[dice_sum - 2] += 1\n\n# display a summary\nprint(\"\\nSum\\tFreq\\tProb\")\nfor i in range(len(dice_sums)):\n  print(\"{}\\t{}\\t{}\".format(i + 2, dice_sums[i], dice_sums[i] / sum(dice_sums)))\nNote the probabilities. Although they are not exactly the same as calculated before, they are very similar! More accurate results would be possible with a much higher number of rolls (try one million!)."
  },
  {
    "objectID": "lessons/01 More Python/01 Review.html",
    "href": "lessons/01 More Python/01 Review.html",
    "title": "Review",
    "section": "",
    "text": "You should know that the kinds of values that can be expressed in a programming language are known as its data types. The primitive types of a programming language are those data types that are built-in (or standard) to the language and typically considered as basic building blocks (i.e., more complex types can be created from these primitive types). Python’s standard types can be grouped into several classes: numeric types, sequences, sets, and mappings. You should be familiar with numeric types and sequences (e.g., lists).\nYou should know that a constant is defined as a value of a particular type that does not change over\ntime. In Python both numbers and text may be expressed as constants. Numeric constants are composed of the digits 0 through 9 and, optionally, a negative sign (for negative numbers), and a decimal point (for floating point numbers). Text constants consists of a sequence of characters (also known as a string of characters – or just a string).\nYou should know that a variable is defined to be a named object that can store a value of a particular\ntype. Before a variable can be used, its name must be declared.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Review"
    ]
  },
  {
    "objectID": "lessons/01 More Python/01 Review.html#data-types-constants-and-variables",
    "href": "lessons/01 More Python/01 Review.html#data-types-constants-and-variables",
    "title": "Review",
    "section": "",
    "text": "You should know that the kinds of values that can be expressed in a programming language are known as its data types. The primitive types of a programming language are those data types that are built-in (or standard) to the language and typically considered as basic building blocks (i.e., more complex types can be created from these primitive types). Python’s standard types can be grouped into several classes: numeric types, sequences, sets, and mappings. You should be familiar with numeric types and sequences (e.g., lists).\nYou should know that a constant is defined as a value of a particular type that does not change over\ntime. In Python both numbers and text may be expressed as constants. Numeric constants are composed of the digits 0 through 9 and, optionally, a negative sign (for negative numbers), and a decimal point (for floating point numbers). Text constants consists of a sequence of characters (also known as a string of characters – or just a string).\nYou should know that a variable is defined to be a named object that can store a value of a particular\ntype. Before a variable can be used, its name must be declared.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Review"
    ]
  },
  {
    "objectID": "lessons/01 More Python/01 Review.html#input-and-output",
    "href": "lessons/01 More Python/01 Review.html#input-and-output",
    "title": "Review",
    "section": "Input and Output",
    "text": "Input and Output\nYou should be familiar with obtaining input (via the input function) and generating output (via the\nprint statement) in Python. Here’s a simple example:\nname = input (\"What is your name? \")   \nprint(f\"Hello, {name}!\")",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Review"
    ]
  },
  {
    "objectID": "lessons/01 More Python/01 Review.html#operators",
    "href": "lessons/01 More Python/01 Review.html#operators",
    "title": "Review",
    "section": "Operators",
    "text": "Operators\nYou should be familiar with a variety of operators in Python. Specifically, arithmetic operators, relational (comparison) operators, and assignment operators. Arithmetic operators include addition,subtraction, etc, and perform arithmetic operations on operands. Relational operators include comparison of equality, inequality, less-than, and so on, and perform comparisons on operands and return True or False. Assignment operators include operators such as +=, -=, and so on, and combine assignment with arithmetic.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Review"
    ]
  },
  {
    "objectID": "lessons/01 More Python/01 Review.html#primary-control-constructs",
    "href": "lessons/01 More Python/01 Review.html#primary-control-constructs",
    "title": "Review",
    "section": "Primary control constructs",
    "text": "Primary control constructs\nYou should be very familiar with the three primary control constructs: sequence, selection, and repetition. Sequence implies one statement after another. Selection allows blocks of optional statements to be executed. Repetition provides a mechanism for repeating blocks of statements. There are two main forms of repetition that we have covered: iteration and recursion. Iteration involves repeating a task some fixed number of times, until a condition is reached, or over some structure (such as the items in a list). Although recursion was only briefly covered, you should know that it involves breaking a problem down repeatedly into smaller versions of itself until a base or trivial case is reached. We will cover recursion in much more detail later in the curriculum.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Review"
    ]
  },
  {
    "objectID": "lessons/01 More Python/01 Review.html#subprograms",
    "href": "lessons/01 More Python/01 Review.html#subprograms",
    "title": "Review",
    "section": "Subprograms",
    "text": "Subprograms\nYou should be quite familiar with subprograms and how they can encapsulate behavior in programs. They are organized, reusable, and related statements that perform some action. Specifically, some subprograms perform tasks and terminate; others return a value. You should understand how control flow is transferred to a subprogram when a subprogram is called, and how it is returned when the subprogram terminates.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Review"
    ]
  },
  {
    "objectID": "lessons/01 More Python/01 Review.html#a-review-of-program-flow",
    "href": "lessons/01 More Python/01 Review.html#a-review-of-program-flow",
    "title": "Review",
    "section": "A review of program flow",
    "text": "A review of program flow\nAlthough you should be familiar with this already, it is so important that we should probably go over it in detail again. It is very important to be able to identify the flow of control in any program, particularly to understand what is going on. In fact, this significantly helps to debug problems in programs. Recall that, in Python, function definitions aren’t executed in the order that they are written in the source code. Functions are only executed when they are called. This is perhaps best illustrated with an example that you have seen before:\n 1: def min (a, b):   \n 2:     if  (a  &lt;  b):   \n 3:         return  a   \n 4:     else:   \n 5:         return  b   \n\n 6: def max(a, b):   \n 7:     if (a  &gt;  b):   \n 8:         return  a   \n 9:     else:   \n10:         return  b \n\n11: num1  =  int(input( \"Enter a number: \"))   \n12: num2  =  int(input(\"Enter another number: \"))   \n\n13: print(f\"The smaller is {min (num1, num2)}.\")   \n14: print(f\"The larger is {max (num1, num2)}.\")   \nEach Python statement is numbered for reference.\n\nLines 1 through 5 represent the definition of the function min. This function returns the minimum of two values provided as parameters.\nLines 6 through 10 represent the definition of the function max. This function returns the maximum of two\nvalues provided as parameters.\nLines 11 through 14 represent the main part of the program. Although the Python interpreter does see lines 1 through 10, those lines are not actually executed until the functions min and max are actually called. The first line of the program to actually be executed is line 11.\n\nHere is the order of the statements executed in this program if num1 = 34 and num2 = 55:\n11, 12, 13, 1, 2, 3, 14, 6, 7, 9, 10   \nLet’s explain:\n\nLine 11 asks the user to provide some value for the first number (which is stored in the\nvariable num1 ).\nLine 12 asks the user to provide some value for the second number (which is stored in\nthe variable num2 ).\nLine 13 displays some text; however, part of the text must be obtained by first calling the function min . This transfers control to line 1 (where min is defined).\nOn line 1 the two actual 2 parameters, num1 and num2 , are passed in and mapped to the formal parameters defined in min , a and b .\nThen, line 2 is executed and performs a comparison of the two numbers. Since a = 34 and b = 55, then the condition in the if-statement is true.\nTherefore, line 3 is executed before control is transferred back to the main program with the value of the smaller number returned (and then controlcontinues on to line 14). Note that lines 4 and 5 are never executed in this case!\nLine 14 is then executed and displays some text. Again, part of the text must be obtained by first calling\nthe function max.\nControl is transferred to line 6 (where max is defined). The variables a and b take on the values 34 and 55 respectively.\nLine 7 is then executed, and the result of the comparison is false. Therefore, line 8 is not executed.\nControl then goes to line 9.\nThe control goes to line 10 which returns the larger value, and the program then ends.\n\nWhat is the order of execution if num1 = 55 and num2 = 34?\n\nWhat if num1 = 100 and num2 = 100?\n\nHere’s another example with a simple for loop:\n1:  for a in range (1, 4):   \n2:      for b in range (1, 5 ):   \n3:          print(f\"{a} * {b} = {a*b}\")   \nThis snippet of code displays a portion of a multiplication table. In fact, here’s the output:\n1 * 1 = 1   \n1 * 2 = 2   \n1 * 3 = 3   \n1 * 4 = 4   \n2 * 1 = 2   \n2 * 2 = 4   \n2 * 3 = 6   \n2 * 4 = 8   \n3 * 1 = 3   \n3 * 2 = 6   \n3 * 3 = 9   \n3 * 4 = 12   \nHere’s the order of the statements executed. To make things a bit more clear, it is grouped and highlighted:\n    1, 2, 3, 2, 3, 2, 3, 2, 3,  # 1 * n\n    1, 2, 3, 2, 3, 2, 3, 2, 3,  # 2 * n \n    1, 2, 3, 2, 3, 2, 3, 2, 3   # 3 * n\n\nThe first portion (highlighted in red and labeled 1 * n) represents a single iteration of the outer for loop\nand a full  iteration of the inner for loop. It generates the following output:\n1 * 1 = 1   \n1 * 2 = 2   \n1 * 3 = 3   \n1 * 4 = 4   \nLet’s explain.\n\nLine 1 of the outer for loop generates the list [ 1, 2, 3 ]. It then iterates over the values in the list with the variable a taking on each value, one at a time. Initially, a = 1.\nLine 2 represents the inner for loop and generates the list [ 1, 2, 3, 4 ], and iterates over its values with the variable b taking on each value, one at a time. Initially, b  = 1.\nLine 3 then displays the first line of output: 1 * 1 = 1. This makes sense because a and b are both 1.\nSo far, the order of statements executed is 1, 2, 3. Note that the inner for loop iterates its complete cycle (i.e., through the entire generated list) for each iteration of the outer for loop. Therefore, the inner for loop iterates through the list [ 1, 2, 3, 4 ] for each value in the outer for loop’s list [ 1, 2, 3 ].\nAfter line 3 (when a and b are both 1), the inner for loop then iterates to the next value in the list.\nTherefore, line 2 is executed again so that b = 2.\nSimilarly, line 3 executes again, generating the output: 1 * 2 = 2.\nAt this point, the order of statements executed is 1, 2, 3, 2, 3.\nThe inner for loop continues iterating two more times (lines 2 and 3), setting b to 3 and then to 4.\nAfter the first full iteration of the outer for loop, the order of statements executed is 1, 2, 3, 2, 3, 2, 3, 2, 3.\nSo when a = 1, b goes through the values 1, 2, 3, and 4. The output generated at this point is then:\n\n1 * 1 = 1   \n1 * 2 = 2   \n1 * 3 = 3   \n1 * 4 = 4   \n\nSince the inner for loop has finished a full iteration, control goes back to line 1, thereby allowing the outer for loop to iterate to the next value in the list so that a = 2.\nLine 2 is executed again, generating a new list [ 1, 2, 3, 4 ] and setting b to 1.\nSimilarly, line 3 is executed again, generating the output: 2 * 1 = 2.\nLines 2 and 3 are executed as before, for each value in the inner loop’s list [ 1, 2, 3, 4 ]. Of course, this generates exactly the same order of statements as before: 1, 2, 3, 2, 3, 2, 3, 2, 3. However, this represents the second iteration of the outer loop.\nSince the inner for loop has finished another full iteration, control goes back to line 1, thereby allowing the outer for loop to iterate to the next value in the list so that a = 3.\nAgain, lines 2 and 3 are executed as before, for each value in the inner loop’s list [ 1, 2, 3, 4 ]. Clearly, this generates exactly the same order of statements as before: 1, 2, 3, 2, 3, 2, 3, 2, 3. This time, it represents the third (and final) iteration of the outer loop. Why? Because the outer for loop has iterated through the entire list [ 1, 2, 3 ].\nAfter this final iteration, the variable a has taken on all of these values. Therefore, the outer for loop is exited, and the program terminates. Again, knowing the order in which statements are executed is crucial to debugging programs and ultimately to creating programs that work.\n\nThis concludes a review of what you should already know in Python. From here, we’ll introduce new content.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Review"
    ]
  },
  {
    "objectID": "lessons/01 More Python/06 Operators.html",
    "href": "lessons/01 More Python/06 Operators.html",
    "title": "Operators",
    "section": "",
    "text": "Python provides several more classes of operators than you are already familiar with. Recall that, so far, you have been exposed to (and should be quite familiar with) arithmetic operators, relational (comparison) operators, and assignment operators. In this lesson, we will cover several other classes of operators: logical operators and membership operators.\n\n\n\n\n\n\nDefinition\n\n\n\nDefinition: The logical operators evaluate two operands and return the logical result (i.e., True or False).\n\n\nThink back to the primitive logic gates ( and , or , and not ). It turns out that they can be effectively mapped to conditions in if-statements. Logical operators operate on conditions (that use relational operators) and provide the overall logical result. In the following table, assume that a = True and b = False:",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Operators"
    ]
  },
  {
    "objectID": "lessons/01 More Python/06 Operators.html#other-operators",
    "href": "lessons/01 More Python/06 Operators.html#other-operators",
    "title": "Operators",
    "section": "",
    "text": "Python provides several more classes of operators than you are already familiar with. Recall that, so far, you have been exposed to (and should be quite familiar with) arithmetic operators, relational (comparison) operators, and assignment operators. In this lesson, we will cover several other classes of operators: logical operators and membership operators.\n\n\n\n\n\n\nDefinition\n\n\n\nDefinition: The logical operators evaluate two operands and return the logical result (i.e., True or False).\n\n\nThink back to the primitive logic gates ( and , or , and not ). It turns out that they can be effectively mapped to conditions in if-statements. Logical operators operate on conditions (that use relational operators) and provide the overall logical result. In the following table, assume that a = True and b = False:",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Operators"
    ]
  },
  {
    "objectID": "lessons/01 More Python/06 Operators.html#python-logical-operators",
    "href": "lessons/01 More Python/06 Operators.html#python-logical-operators",
    "title": "Operators",
    "section": "Python Logical Operators",
    "text": "Python Logical Operators\nIn the following code block, assume that a = True and b = False:\nand # logical and; a and b is False \n\nor  # logical or; a or b is True   \n\nnot # logical not; not a is False; not b is True  \nNote that this is equivalent to the primitive logic gates, where 0 is substituted for False and 1 for True.\nHere is the truth table for the and gate shown in this manner:\n\n\n\nA\nB\nA AND B\nA OR B\n\n\n\n\nFalse\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\nTrue\n\n\nTrue\nFalse\nFalse\nTrue\n\n\nTrue\nTrue\nTrue\nTrue\n\n\n\nThe logical operators sometimes make more sense when they are used in the context of a condition (e.g., in an if statement). Suppose that a = 5 and b = 10. The following condition would evaluate to False:\nif (a == 5 and b &lt; 10):   \n    ...   \nWhy? Clearly because, although a is equal to 5, b is not less than 10 (it’s equal to 10). Therefore, the and logical operator will return False if and only if both sides of the operator evaluate to True. In this case, the left side does while the right side does not. However, the following condition would evaluate to True:\nif (a == 5 or b &lt; 10 ):   \n    ...\nThe or logical operator will return True if either (or both) sides of the operator evaluate to True. Since a is equal to 5, then the left side is True. In this case, the right side doesn’t need to be evaluated (and, in fact, it isn’t – more on that below). The logical operators do work when the inputs (i.e., a and b in the previous examples) aren’t necessarily\nequal to True and False. That is, they also work when they are numeric values. Take, for example, the following statements:\n1: a = 23   \n2: b = 13  \n3: print(a and b)   \n4: print(a or b)   \n5: print(not a)   \n6: print(not b)   \n7: a = 0   \n8: print(not a)   \nHere’s the output (with lines numbers matching those of the print statements above):\n3: 13   \n4: 23   \n5: False   \n6: False   \n8: True   \nThe output of lines 3 and 4 can be a bit confusing. Why, for example, is a and b 13? Or why is a or b\n23? This can be explained by the following table, where the variables a and b have numeric values (as\nin the examples above):\n\n\n\n\n\n\n\n\nOperator\nMeaning\nDescription\n\n\n\n\nand\nlogical and\nreturns a if a is False, b otherwise\n\n\nor\nlogical or\nreturns b if a is False, a otherwise\n\n\nnot\nlogical not\nreturns False if a is True, True otherwise\n\n\n\nThe output of lines 5, 6, and 8 makes sense when we realize that, in Python, 0 is False and any non-zero value is True! When a is 23 and b is 13, a evaluates to True (since it is non-zero); therefore, not a evaluates to False. This is the same with b . However, when a is 0, then it evaluates to False; therefore, not a evaluates to True. Formally, in the context of Boolean expressions, the following values are interpreted as false: False, None, numeric zero of all types, and empty strings and containers. All other values are interpreted as true.\n\n\n\n\n\n\nDid you know?\n\n\n\nThe and and or logical operators are short circuit operators. That is, to evaluate a True or False result,the minimum number of inputs required to produce such an output is evaluated. For example, suppose that a = False and b = True. The expression a and b is only True if both a and b are True. Since a is False, then there is no need to evaluate (or test) the value of b. This would be useless and waste CPU cycles.\nSimilarly, if a = True and b = True, the evaluation of the expression a or b only requires checking that a is True for the entire expression to evaluate to True (i.e., there is no need to evaluate/test the value of b ).",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Operators"
    ]
  },
  {
    "objectID": "lessons/01 More Python/06 Operators.html#membership-operators",
    "href": "lessons/01 More Python/06 Operators.html#membership-operators",
    "title": "Operators",
    "section": "Membership Operators",
    "text": "Membership Operators\n\n\n\n\n\n\nDefinition\n\n\n\nMembership operators test for some value’s membership in a sequence (e.g., to test if an element exists in a list, or if a character exists in a string).\n\n\nIn the following table, suppose that the Python list numbers** = [ 1, 3, 5, 7, 9 ], x = 2, and y = 3.\nPython Membership Operators and Examples\n\n\n\n\n\n\n\n\nOperator\nDescription\nExample\n\n\n\n\nin\nReturns True if a specified value is in a specified sequence or False otherwise\nx in numbers is False; y in numbers is True\n\n\nnot in\nReturns True if a specified value is not in a specified sequence or False otherwise\nx not in numbers is True; y not in numbers is False\n\n\n\nYou have seen this in previous for loop examples (e.g., for i in a_list ). This for loop configuration has the variable i take on each of the values in a_list, one at a time.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Operators"
    ]
  },
  {
    "objectID": "lessons/01 More Python/04 Python Lists.html",
    "href": "lessons/01 More Python/04 Python Lists.html",
    "title": "Python Lists",
    "section": "",
    "text": "Although you should be familiar with Python lists, they are quite important and used often; therefore, we will go over it again. Generally, a Python sequence is composed of elements (typically related elements). Each element in a sequence is assigned an index (or position). A sequence with n elements has indexes 0 to n–1. Python has many built-in types of sequences; however, the most popular is called the list.\nThe list in Python is quite versatile. Recall that a list is declared using square brackets; for example:\ngrades = [94, 78, 100, 86]   \nThe statement above declares the list grades with four integers: 94, 78, 100, and 86. The list can be displayed in its entirety (e.g., with the statement print(grades) ); however, we can access each element individually by its index (specified within brackets). Accessing can mean to read a value in the list, or it can mean to change a value in the list; for example:\nprint(grades[0])   # reading the value  at index 0 \ngrades[3] = 87     # setting the value at index 3   \ngrades[1] += 2     # adding 2 to the value at index 1",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Python Lists"
    ]
  },
  {
    "objectID": "lessons/01 More Python/04 Python Lists.html#list-basics",
    "href": "lessons/01 More Python/04 Python Lists.html#list-basics",
    "title": "Python Lists",
    "section": "",
    "text": "Although you should be familiar with Python lists, they are quite important and used often; therefore, we will go over it again. Generally, a Python sequence is composed of elements (typically related elements). Each element in a sequence is assigned an index (or position). A sequence with n elements has indexes 0 to n–1. Python has many built-in types of sequences; however, the most popular is called the list.\nThe list in Python is quite versatile. Recall that a list is declared using square brackets; for example:\ngrades = [94, 78, 100, 86]   \nThe statement above declares the list grades with four integers: 94, 78, 100, and 86. The list can be displayed in its entirety (e.g., with the statement print(grades) ); however, we can access each element individually by its index (specified within brackets). Accessing can mean to read a value in the list, or it can mean to change a value in the list; for example:\nprint(grades[0])   # reading the value  at index 0 \ngrades[3] = 87     # setting the value at index 3   \ngrades[1] += 2     # adding 2 to the value at index 1",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Python Lists"
    ]
  },
  {
    "objectID": "lessons/01 More Python/04 Python Lists.html#slicing",
    "href": "lessons/01 More Python/04 Python Lists.html#slicing",
    "title": "Python Lists",
    "section": "Slicing",
    "text": "Slicing\nRecall that more than one value in a list can be accessed at a time. We can specify a range (or interval) of indexes in the format [lower:upper+1] which means the interval \\([lower, upper)\\) (i.e., closed atlower and open at upper). That is, the lower index in the range is inclusive but the upper is not. For\nexample:\nstuff[3:4]  # accesses index 3 (the same as stuff[3])   \nstuff[0:5]  # accesses indexes 0 through 4   \nstuff[-3]   # accesses the third index  from the right",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Python Lists"
    ]
  },
  {
    "objectID": "lessons/01 More Python/04 Python Lists.html#other-usages",
    "href": "lessons/01 More Python/04 Python Lists.html#other-usages",
    "title": "Python Lists",
    "section": "Other Usages",
    "text": "Other Usages\nRecall that various keywords and functions exist for us to modify or find information about a list. Here is a list of a few.\ndel grades[2]   # delete the item at index 2\n\nlen(grades)   # Returns the length of a list   \n\nmax(grades)   # Returns the item in the list with the maximum value   \n\nmin(grades)   # Returns the item in the list with the minimum value",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Python Lists"
    ]
  },
  {
    "objectID": "lessons/01 More Python/04 Python Lists.html#list-methods",
    "href": "lessons/01 More Python/04 Python Lists.html#list-methods",
    "title": "Python Lists",
    "section": "List Methods",
    "text": "List Methods\nLastly, recall that lists have various methods that can be used to operate on the list. Here are a few of them.\ngrades.append(item)           # Inserts item at the end of the list   \n\ngrades.count(item)            # Returns the number of times an item appears in the list   \n\ngrades.index(item)            # Returns the index of the first occurrence of item   \n\ngrades.insert(index, item)    # Inserts an item at the specified index in the list   \n\ngrades.remove(item)           # Removes the first occurrence of item from the list   \n\ngrades.reverse()              # Reverses the items in the list   \n\ngrades.sort()                 # Sorts a list",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Python Lists"
    ]
  },
  {
    "objectID": "lessons/01 More Python/index.html",
    "href": "lessons/01 More Python/index.html",
    "title": "01 More Python",
    "section": "",
    "text": "In this lesson, we will build on what you have already learned about the Python programming language. To be sure that we are all on the same page, let’s briefly review the things about Python that you should already be familiar with. For more detail, review the lesson on Introduction to Computer Programming .",
    "crumbs": [
      "Lessons",
      "01 More Python"
    ]
  },
  {
    "objectID": "lessons/01 More Python/index.html#overview",
    "href": "lessons/01 More Python/index.html#overview",
    "title": "01 More Python",
    "section": "",
    "text": "In this lesson, we will build on what you have already learned about the Python programming language. To be sure that we are all on the same page, let’s briefly review the things about Python that you should already be familiar with. For more detail, review the lesson on Introduction to Computer Programming .",
    "crumbs": [
      "Lessons",
      "01 More Python"
    ]
  },
  {
    "objectID": "lessons/01 More Python/index.html#contents",
    "href": "lessons/01 More Python/index.html#contents",
    "title": "01 More Python",
    "section": "Contents",
    "text": "Contents\n\nReview\nFormal vs Actual Parameters\nVariable Scope\nPython Lists\nSearching and Sorting\nOperators\nString Methods\nExternal Libraries",
    "crumbs": [
      "Lessons",
      "01 More Python"
    ]
  },
  {
    "objectID": "lessons/01 More Python/05 Searching and Sorting.html",
    "href": "lessons/01 More Python/05 Searching and Sorting.html",
    "title": "Searching and Sorting",
    "section": "",
    "text": "In previous lessons, we designed several searching algorithms (sequential/linear search and binary search) and sorting algorithms (bubble sort, selection sort, and insertion sort). We first specified them in pseudocode, and for some we showed how they could be implemented in Python (sequential search, binary search, and selection sort). To help get a better understanding of Python, let’s briefly revisit some of these.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Searching and Sorting"
    ]
  },
  {
    "objectID": "lessons/01 More Python/05 Searching and Sorting.html#introduction",
    "href": "lessons/01 More Python/05 Searching and Sorting.html#introduction",
    "title": "Searching and Sorting",
    "section": "",
    "text": "In previous lessons, we designed several searching algorithms (sequential/linear search and binary search) and sorting algorithms (bubble sort, selection sort, and insertion sort). We first specified them in pseudocode, and for some we showed how they could be implemented in Python (sequential search, binary search, and selection sort). To help get a better understanding of Python, let’s briefly revisit some of these.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Searching and Sorting"
    ]
  },
  {
    "objectID": "lessons/01 More Python/05 Searching and Sorting.html#sequential-search",
    "href": "lessons/01 More Python/05 Searching and Sorting.html#sequential-search",
    "title": "Searching and Sorting",
    "section": "Sequential Search",
    "text": "Sequential Search\nFirst, here’s the sequential search for the smallest value in a list (from an earlier lesson). Note that a\nPython list is first populated with 20 random integers (from 1 to 99, also from an earlier lesson):\n 1: from random import randint   \n\n 2: numbers = []   \n 3: while (len(numbers) &lt; 20):   \n 4:     numbers.append(randint(1, 99))   \n 5: print(numbers)\n\n 6: minIndex = 0   \n 7: for index in range(1, len(numbers)):   \n 8:     if(numbers[index] &lt; numbers[minIndex]):   \n 9:         minIndex  =  index  \n\n10: print(\"The smallest value is at index: {}\".format(minIndex))   \n11: print(\"The smallest value is: {}\" . format(numbers[minIndex]))  \nThis version of the sequential search technically outputs the index of the smallest value (which is typically what programmers are interested in). Since the value can be easily accessed through the index, returning the index is much more meaningful. To generalize the sequential search so that it can return the index of a specified value (as opposed to the smallest value), it can be modified by replacing lines 6 through 11 as follows:\nnum = int(input(\"What integer would you like to search for? \"))   \nfor index in range(len(numbers)):   \n    if(numbers[index] == num):   \n        print ( \"The value {} was found at index {}!\".format(num, index))   \nWhat happens if the specified value is duplicated several times in the list? Clearly, each index would be\ndisplayed. Here’s example (with user input highlighted in red):\n[20, 47, 80, 52, 98, 80, 1, 14, 31, 48, 70, 31, 97, 30, 31, 43, 59, 2, 38, 50]   \nWhat integer would you like to search for? 31   \nThe value 31 was found at index 8!   \nThe value 31 was found at index 11!   \nThe value 31 was found at index 14!   \n\nBut what if it’s only necessary to find the first occurrence of a specified value (and then abort)? Python provides a way to exit a repetition construct early (a.k.a. an “early exit”) through the break keyword! Formally, the break keyword exits the nearest enclosing repetition construct. More on this in a bit. To illustrate the use of the break keyword, the sequential search code above can be modified to output only the first instance of a specified value:\nfor index in range(len(numbers)):   \n    if (numbers[index] == num):   \n        print(\"The value {} was found at index {}!\".format(num, index))   \n        break\nHere’s an example:\n[87, 44, 37, 69, 92, 74, 49, 97, 65, 69, 27, 61, 22, 77, 3, 3, 25, 86, 53, 45]   \nWhat integer would you like to search for?  3   \nThe value 3 was found at index 14!   \n\nNote that the value 3 occurs twice in the list (at index 14 and index 15); however, only the first instance is reported to the user before the search terminates. The break statement exits the enclosing repetition construct: in this case, the for loop.\nWhat if the break keyword is located in a repetition construct that is also located inside of another\nrepetition construct? In this case, it will exit the inner repetition construct only. Here’s an example:\nfor i in  range(2):   \n    print(\"i={}\".format(i)),   \n    for j in range(5):   \n        print ( \"j={}\" . format(j)),   \n        if (j &gt; 1):   \n            break   \n    print()\nHere’s the output:\ni=0 j=0 j=1 j=2   \ni=1 j=0 j=1 j=2  \nThe outer for loops iterates i from 0 through 1. The inner for loop iterates j from 0 through 4. Moreover, the inner for loop exits early if j is greater than 1. Technically, the print statement in the inner for loop will display values of j that are less than or equal to 1. So why is a value of 2 for j displayed? When j is 2, the value is displayed, after which the if statement is executed (which breaks out of the inner for loop). The outer for loop continues (the lone print() statement is there to add a line break in between increasing values of i ), and i  becomes 1. This occurs again until the outer for loop terminates (when i  is 2).",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Searching and Sorting"
    ]
  },
  {
    "objectID": "lessons/01 More Python/05 Searching and Sorting.html#binary-search",
    "href": "lessons/01 More Python/05 Searching and Sorting.html#binary-search",
    "title": "Searching and Sorting",
    "section": "Binary Search",
    "text": "Binary Search\nLet’s now take a look at the binary search that was also covered in an earlier lesson. Recall that it is a very efficient search that requires a list to be sorted. Here’s the Python code that was developed in an earlier lesson:\nnum = int(input(\"What integer would you like to search for? \"))\nfound = False   \nfirst = 0   \nlast = len(numbers) - 1   \nwhile (first &lt;= last and found != True):   \n    mid = (first + last) // 2   \n    if (num == numbers[mid]):   \n        found = True   \n    elif (num &gt; numbers[mid]):   \n        first = mid + 1   \n    else:   \n        last = mid - 1 \n\nif (found):   \n    print(\"{} was found at index {}!\".format(num, mid))   \nelse :   \n    print(\"{} was not found.\".format(num))   \nThis version of the binary search keeps tracks of two boundaries ( first and last ) that identify the beginning and end indexes of the current portion of the list. Initially, first is 0 and last is n-1 (i.e., the entire list). If the middle value of the current portion of the list does not match the specified value, the appropriate half of the list is “discarded” by modifying either first (to discard the left half) or last (to discard the right half).",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Searching and Sorting"
    ]
  },
  {
    "objectID": "lessons/01 More Python/05 Searching and Sorting.html#selection-sort",
    "href": "lessons/01 More Python/05 Searching and Sorting.html#selection-sort",
    "title": "Searching and Sorting",
    "section": "Selection Sort",
    "text": "Selection Sort\nRecall that the binary search required a list to be sorted, thereby taking advantage of the algorithm’s efficiency improvement over the sequential search. Here’s the selection sort that was developed in an\nearlier lesson:\nn = len(numbers)   \nfor i in range(0, n - 1):   \n    minPosition  =  i   \n    for j in range (i + 1, n):   \n        if (numbers[j] &lt; numbers[minPosition]):   \n            minPosition = j  \n\n    temp = numbers[i]   \n    numbers[i] = numbers[minPosition]   \n    numbers[minPosition] = temp   \nRecall how the selection sort works:\n\nthe list is sorted from left to right;\nat each pass (controlled by the outer for loop), the smallest value is swapped with the first item in the unsorted portion of the list;\nthe inner for loop performs the comparison of every remaining item in the unsorted portion of\nthe list to find the smallest value.\n\nFor a review, see the lesson on Searching and Sorting from CSC 130.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Searching and Sorting"
    ]
  },
  {
    "objectID": "lessons/01 More Python/05 Searching and Sorting.html#bubble-sort",
    "href": "lessons/01 More Python/05 Searching and Sorting.html#bubble-sort",
    "title": "Searching and Sorting",
    "section": "Bubble Sort",
    "text": "Bubble Sort\nThere were two other sorting algorithms that were covered in earlier lessons: bubble sort and insertion\nsort. We never developed Python code for them. Let’s do this now. First, the bubble sort. Here is a\nversion in pseudocode:\nfor  i ← 1..list length-1   \n     for  j ← 1..list length-i   \n         if  item j of list &lt; item j-1 of list   \n         then   \n            temp ← item j of list   \n            item j of list ← item j-1 of list   \n            item j-1 of list ← temp   \n         end   \n     next   \nnext   \nYou may not have seen a for loop described in pseudocode before; however, this is a common way to accomplish this repetition construct in pseudocode. So what’s happening here? The basic idea is that a value in the list will be compared to the one before it. If they are out of order, then they are swapped. This continues, one index over (to the right), until the end of the list is reached. After the first pass, the largest value is guaranteed to be in its final position (i.e., at the end of the list). The next pass starts again at the beginning of the list; however, this time comparisons and swaps only take place until the second-to-last value in the list (because the last value has already been placed there during the last pass). Each time, the sorted list grows from right-to-left until the entire list is sorted. The outer for loop controls the number of passes, while also providing a way to reduce the size of the unsorted portion of the list after each pass. It iterates from 1 through n-1. The inner loop controls the comparisons and swaps. Initially, the inner loop begins at 1 (the index of the second value in the list), and compares this value to the one before it (the first value in the list). If they are out of order, they are swapped. The swap works by using a variable ( temp ) that temporarily takes on one of the values in the list. This continues with the next index (i.e., 2), and so on. The last index compared is n - i . If the algorithms is in the first pass (i.e., i is 1) and the length of the list is 10, the last valid index in the list is 10 – 1 = 9.\nLet’s take a look at what a Python version of the bubble sort looks like:\nn = len (list)   \nfor i in  range(1, n):   \n    for j in range(1, n - i + 1):   \n        if (list [j] &lt; list [j-1]):   \n            temp = list [j]   \n            list[j] = list [j-1]   \n            list[j - 1] = temp   \nRecall that Python’s range function uses the first parameter as a lower bound and the second parameter as one above the upper bound. That is, it operates on the interval [ a , b ), where a is the (closed) lower bound and b is the (open) upper bound. Therefore, the upper bound of the outer loop is n : it iterates from 1 through (and including) n-1 as intended. Similarly, the upper bound of the inner loop is n - i + 1: it iterates from 1 through (and including) n - i as intended. In the inner loop, if any value at an index is less than the value of the one before it, they are swapped.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Searching and Sorting"
    ]
  },
  {
    "objectID": "lessons/01 More Python/05 Searching and Sorting.html#insertion-sort",
    "href": "lessons/01 More Python/05 Searching and Sorting.html#insertion-sort",
    "title": "Searching and Sorting",
    "section": "Insertion Sort",
    "text": "Insertion Sort\nNext, let’s take a look at the Python code for the insertion sort. Recall that the insertion sort works somewhat as you would arrange a hand of cards being dealt to you: a new card is inserted in its appropriate position in the hand of cards dealt so far.\n 1: i = 1   \n 2: while  (i  &lt;  n):   \n 3:     if (list[i - 1] &gt; list[i]):   \n 4:         temp = list [i]   \n 5:         j = i – 1   \n 6:         while (j &gt;= 0 and list[j] &gt; temp):   \n 7:             list[j + 1] = list [j]   \n 8:             j -= 1   \n 9:             list[j + 1] = temp   \n10:     i +=  1 \nHere’s an explanation of the code. Line 2 controls the number of passes through the list ( n-1 total passes). The variable i is initialized to 1 (the second index in the list) and iterates through (but not including) n ; therefore, through the last index in the list. So, starting with the second value in the list, it looks to the left (of this current value). Line 3 checks if that value is greater, and if so, then it must move it to the right. Line 4 temporarily stores the current item, and lines 5 and 6 then begin the process of iterating from the previous element, continuing to the left. At any point, if a value to the left is greater than the current item, it is shifted one index to the right. This continues either until (1) the beginning of the list is reached; or (2) a value that is not greater is found. Ultimately, the current item is placed into its proper position in the list. The outer loop then continues with the next value in the list (through the last value in the list). Note that there are many other ways that the searches and sorts shown could have been implemented in Python. For example, the use of for loops in the selection sort could have been replaced with while loops (or vice versa in the insertion sort).",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Searching and Sorting"
    ]
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/01 Introduction.html",
    "href": "lessons/04 Graphical User Interfaces/01 Introduction.html",
    "title": "Graphical User Interfaces",
    "section": "",
    "text": "Computing devices are indeed ubiquitous. We use them all the time for a variety of tasks. To use them, we must inherently interact with them. In fact, there’s an entire branch of computer science that deals with the way humans interact with machines (primarily computing machines) called human-computer interaction (HCI). In this lesson, we will focus on the way that we typically interact with computing devices: through graphical user interfaces.\n\n\n\n\n\n\nDefinition\n\n\n\nA graphical user interface (GUI – pronounced “gooey”) is a type of interface that allows users to interact with computing machines through graphical entities. An interface is just a program that provides a way of interacting with a computing machine so that a user can use it to do its bidding!\n\n\nThe interface typically monitors input (e.g., clicking with the mouse, typing on the keyboard, etc) and controls output (e.g., the result of inputs rendered to a monitor). GUIs are the most common type of interface between humans and computers. In fact, most software products and virtually all popular computer operating systems are GUI-based.\nFormally, GUIs implement an interface metaphor, such as a desktop, that allows users to interact with computer systems. Software objects, such as programs and data files, are generally represented as postage stamp sized pictures called icons. A human can access one of these objects by selecting it with a pointing device, such as a mouse. When opened, an icon expands to become a window. A window is a portion of the computer screen used to communicate with a particular program. Generally, windows and icons can be resized (i.e., made larger or smaller) and repositioned anywhere on the desktop. But of course, you already know all this!"
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/01 Introduction.html#introduction",
    "href": "lessons/04 Graphical User Interfaces/01 Introduction.html#introduction",
    "title": "Graphical User Interfaces",
    "section": "",
    "text": "Computing devices are indeed ubiquitous. We use them all the time for a variety of tasks. To use them, we must inherently interact with them. In fact, there’s an entire branch of computer science that deals with the way humans interact with machines (primarily computing machines) called human-computer interaction (HCI). In this lesson, we will focus on the way that we typically interact with computing devices: through graphical user interfaces.\n\n\n\n\n\n\nDefinition\n\n\n\nA graphical user interface (GUI – pronounced “gooey”) is a type of interface that allows users to interact with computing machines through graphical entities. An interface is just a program that provides a way of interacting with a computing machine so that a user can use it to do its bidding!\n\n\nThe interface typically monitors input (e.g., clicking with the mouse, typing on the keyboard, etc) and controls output (e.g., the result of inputs rendered to a monitor). GUIs are the most common type of interface between humans and computers. In fact, most software products and virtually all popular computer operating systems are GUI-based.\nFormally, GUIs implement an interface metaphor, such as a desktop, that allows users to interact with computer systems. Software objects, such as programs and data files, are generally represented as postage stamp sized pictures called icons. A human can access one of these objects by selecting it with a pointing device, such as a mouse. When opened, an icon expands to become a window. A window is a portion of the computer screen used to communicate with a particular program. Generally, windows and icons can be resized (i.e., made larger or smaller) and repositioned anywhere on the desktop. But of course, you already know all this!"
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/01 Introduction.html#gui-components",
    "href": "lessons/04 Graphical User Interfaces/01 Introduction.html#gui-components",
    "title": "Graphical User Interfaces",
    "section": "GUI components",
    "text": "GUI components\nAlthough the types of components that make up a GUI can vary depending on operating system, application, and various other factors, there are many standard ones that virtually all GUIs support:\n• Window: an area on the screen that displays information.\n• Menu: allows users to execute commands by selecting from a list of options.\n• Icon: a small picture that represents something else (e.g., a file, an application, a command).\n• Control: also known as a widget, a component that users directly interact with (e.g., by clicking, dragging, etc) to perform some task (e.g., launch an application, set a configuration setting, etc). There are many types of controls that you may be familiar with: list, label, check box, radio button, slider, spinner, and so on.\n• Tab: a way of grouping GUI components in an area of a window."
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/01 Introduction.html#events",
    "href": "lessons/04 Graphical User Interfaces/01 Introduction.html#events",
    "title": "Graphical User Interfaces",
    "section": "Events",
    "text": "Events\nOn their own, GUIs really do nothing. That is, they are specifically designed for user interaction. Users must interact with a GUI, and when that happens, an event occurs that triggers some sort of action. An action can be virtually anything, such as opening a file, launching an application, performing a background task, and so on. We often say that some GUI components listen for user interaction; that is,they implement what is known as a listener. When the listener detects user interaction (e.g., through a mouse click), the interaction is registered as an event. The event then triggers some predefined action that handles it and typically produces some output that is expected by the user."
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/03 Tkinter Widgets.html",
    "href": "lessons/04 Graphical User Interfaces/03 Tkinter Widgets.html",
    "title": "Tkinter Widgets",
    "section": "",
    "text": "Before we go on to create more elaborate GUIs, let’s discuss a few of the more common Tkinter (in general, GUI) widgets. In fact, the Tkinter library supports fifteen core widgets:\n• Button: a button that can be used to execute an action when clicked.\n• Canvas: used to draw graphs, plot points, create drawings, etc.\n• Checkbutton: a button that can represent two distinct values by being checked or unchecked.\n• Entry: used to provide text-based user input.\n• Frame: a container that can group other widgets.\n• Label: used to display text or an image.\n• Listbox: used to display a list of options that the user can select from.\n• Menu: used to implement pull-down menus by grouping menu items.\n• Menubutton: a single menu item that is used in pull-down menus.\n• Message: like a Label, used to display text; however, it is more configurable.\n• Radiobutton: a button in a group of buttons that represents one of the values associated with the group.\n• Scale: supports the selection of a numeric value by dragging a slider.\n• Scrollbar: provides horizontal and vertical scroll bars for various GUI components.\n• Text: supports formatted text, including embedded images and even windows.\n• Toplevel: a container that can be displayed as a separate window on top of other components.\nDiscussing all of these widgets in detail and showing how they can be used in GUIs is beyond the scope of this lesson. If you wish, you can visit many online tutorials to see these widgets (and more) used in the creation of GUIs."
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/03 Tkinter Widgets.html#introduction",
    "href": "lessons/04 Graphical User Interfaces/03 Tkinter Widgets.html#introduction",
    "title": "Tkinter Widgets",
    "section": "",
    "text": "Before we go on to create more elaborate GUIs, let’s discuss a few of the more common Tkinter (in general, GUI) widgets. In fact, the Tkinter library supports fifteen core widgets:\n• Button: a button that can be used to execute an action when clicked.\n• Canvas: used to draw graphs, plot points, create drawings, etc.\n• Checkbutton: a button that can represent two distinct values by being checked or unchecked.\n• Entry: used to provide text-based user input.\n• Frame: a container that can group other widgets.\n• Label: used to display text or an image.\n• Listbox: used to display a list of options that the user can select from.\n• Menu: used to implement pull-down menus by grouping menu items.\n• Menubutton: a single menu item that is used in pull-down menus.\n• Message: like a Label, used to display text; however, it is more configurable.\n• Radiobutton: a button in a group of buttons that represents one of the values associated with the group.\n• Scale: supports the selection of a numeric value by dragging a slider.\n• Scrollbar: provides horizontal and vertical scroll bars for various GUI components.\n• Text: supports formatted text, including embedded images and even windows.\n• Toplevel: a container that can be displayed as a separate window on top of other components.\nDiscussing all of these widgets in detail and showing how they can be used in GUIs is beyond the scope of this lesson. If you wish, you can visit many online tutorials to see these widgets (and more) used in the creation of GUIs."
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/03 Tkinter Widgets.html#configuring-widgets",
    "href": "lessons/04 Graphical User Interfaces/03 Tkinter Widgets.html#configuring-widgets",
    "title": "Tkinter Widgets",
    "section": "Configuring widgets",
    "text": "Configuring widgets\nMost Tkinter widgets can be configured as they are instantiated by specifying various parameters in the constructor. Here’s an example with the Button widget shown above:\nb = Button(master, text=\"Submit\", fg=\"blue\", bg=\"yellow\")\nAnother way of configuring a widget is to invoke its config function. In general, a widget, w, can be configured as follows:\nw.config(option=value, option=value, ...)\nFor example:\nb.config(text=\"Send\", fg=\"red\")"
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/03 Tkinter Widgets.html#positioning-widgets",
    "href": "lessons/04 Graphical User Interfaces/03 Tkinter Widgets.html#positioning-widgets",
    "title": "Tkinter Widgets",
    "section": "Positioning widgets",
    "text": "Positioning widgets\nWidgets can be positioned in the main window or in a frame using a variety of layouts. The one that has been used in previous examples is called the pack manager. It configures widgets in rows and columns. Options such as fill, expand, and side, help determine where a widget is placed and how it behaves graphically. The pack manager is good for placing a single widget and having it fill an entire container. It is also good for placing widgets next to each other vertically or horizontally.\nThe pack manager’s fill option is used to have a widget fill the entire space assigned to it. There are several values that can be assigned to this option: BOTH makes the widget expand both horizontally and vertically; X makes the widget expand only horizontally; and Y makes the widget expand only vertically.\nThe pack manager’s expand option is used to assign any additional space in a container to a widget. That is, if the parent container has any remaining space after packing all widgets, it will be distributed among all widgets that have the expand option set to a non-zero value.\nThe pack manager’s side option is used to specify which side of the container to place the widget against. Values for this option are: TOP (the default) which packs widgets vertically; LEFT which packs widgets horizontally; BOTTOM which packs a widget against the bottom; and RIGHT which packs a widget to the right. Note that, although these values can be mixed, the results may not be as intended. Of course, you can easily experiment!\nHere’s an example of aligning Tkinter Labels vertically, while expanding them horizontally:\nfrom tkinter import *\n\nwindow = Tk()\n\nl1 = Label(window, text=\"A\", bg=\"red\", fg=\"white\")\nl1.pack(fill=X)\nl2 = Label(window, text=\"B\", bg=\"green\", fg=\"white\")\nl2.pack(fill=X)\nl3 = Label(window, text=\"C\", bg=\"blue\", fg=\"white\")\nl3.pack(fill=X)\n\nwindow.mainloop()\nAnd here’s the output (note that the window was manually resized to be larger horizontally):\n\n\n\n\n\nAnd here’s a GUI aligning the labels horizontally, expanding them horizontally, and expanding only the middle one vertically:\nfrom tkinter import *\nwindow = Tk()\n\nl1 = Label(window, text=\"A\", bg=\"red\", fg=\"white\")\nl1.pack(side=LEFT, expand=1, fill=X)\nl2 = Label(window, text=\"B\", bg=\"green\", fg=\"white\")\nl2.pack(side=LEFT, expand=1, fill=BOTH)\nl3 = Label(window, text=\"C\", bg=\"blue\", fg=\"white\")\nl3.pack(side=LEFT, expand=1, fill=X)\n\nwindow.mainloop()\nAnd here’s the output (again, the window was manually resized):\n\n\n\n\n\nThere is a much more powerful and flexible layout manager in the Tkinter library called the grid manager. It also configures widgets in rows and columns; however, each widget’s row and column (and how it behaves in its position in the row and column) can be individually specified. For the purpose of this lesson, the row and column in which a widget is placed is known as a cell. The grid manager supports several options: row, column, sticky, columnspan, and rowspan.\nThe row option is a numeric value that specifies which row in the grid the widget should be placed in. Rows begin at 0. The column option is a numeric value that specifies which column in the grid the widget should be placed in. Similarly, columns begin at 0.\nThe sticky option aligns the widget based on several values: N aligns the widget to the North (i.e., the top); S aligns the widget to the South (bottom); E aligns the widget to the East (right); and W aligns the widget to the West (left). Values can be combined; for example, NE aligns the widget to the Northeast (top-right). They can also be stacked; for example, N+S expands the widget vertically, E+W expands the widget horizontally, and N+S+E+W expands the widget both vertically and horizontally.\nThe columnspan option allows a widget to span multiple columns. Similarly, the rowspan option allows a widget to span multiple rows.\nHere’s a first example using the grid manager:\nfrom tkinter import *\n\nwindow = Tk()\n\nl1 = Label(window, text=\"A label\")\nl1.grid(row=0, column=0)\nl2 = Label(window, text=\"Another label\")\nl2.grid(row=1, column=0)\n\ne1 = Entry(window)\ne1.grid(row=0, column=1)\ne2 = Entry(window)\ne2.grid(row=1, column=1)\n\nwindow.mainloop()\nThe program creates two labels and two text entry fields. Here’s its output:\n\n\n\n\n\nNotice how the labels are, by default, aligned in the center of their cell. We can force them to be aligned to the left by slightly modifying the source code as follows:\nfrom tkinter import *\n\nwindow = Tk()\n\nl1 = Label(window, text=\"A label\")\nl1.grid(row=0, column=0, sticky=W)\nl2 = Label(window, text=\"Another label\")\nl2.grid(row=1, column=0, sticky=W)\n\ne1 = Entry(window)\ne1.grid(row=0, column=1)\ne2 = Entry(window)\ne2.grid(row=1, column=1)\n\nwindow.mainloop()\nNote how the sticky option has been added to the two labels. Here’s the output of the modified program:\n\n\n\n\n\nLet’s add more widgets to see how the rest of the grid manager options can be used. First, however, it is good practice to doodle by drawing what it is that we are trying to accomplish, especially for GUIs that are complicated (typically, that’s when there are more than just a few widgets). Here’s a quick mock-up of what the GUI will look like:\n\n\n\n\n\nFor clarity, here are the widget variable names, and their types and descriptions:\n• l1: a Label with the text “A label”, left-aligned in row 0, column 0.\n• l2: a Label with the text “Another label”, left-aligned in row 1, column 0.\n• l3: a Label with the text “A third label, centered”, centered horizontally in row 2, spanning across columns 0 and 1.\n• l4: a Label with a “smiley” image (100x100 pixels), centered horizontally and vertically, spanning across rows 0 and 1, and columns 2 and 3.\n• e1: an empty Entry, centered horizontally in row 0, column 1.\n• e2: an Entry with the text “user input”, centered horizontally in row 1, column 1.\n• c1: a Checkbutton with the text “Some Checkbutton option”, left-aligned in row 3, spanning across columns 0 and 1.\n• b1: a Button with the text “A button”, centered horizontally in row 3, column 2.\n• b2: a Button with the text “Another button”, centered horizontally in row 3, column 3.\nBefore we get to the source code that creates this GUI, let’s take a look at the end result:\n\n\n\n\n\nNow, let’s build the code to create this GUI, a little at a time. We’ll start with the following:\nfrom tkinter import *\n\nclass GUITest(Frame):\n  def __init__(self, master):\n    ...\n  def setupGUI(self):\n    ...\n\nwindow = Tk()\nt = GUITest(window)\nt.setupGUI()\nwindow.mainloop()\nAt this point, all that’s been done is to create the main window. Note that we will be implementing the GUI as a class (called GUITest) that inherits from the Tkinter Frame class. That is, it’s just a frame on which other widgets will be placed. The GUITest class will, of course, have a constructor. We’ll also implement a setupGUI function that does the bulk of instantiating and positioning the widgets. This explains the statement t.setupGUI() in the main part of the program at the bottom. The process is to first create the main window, then create the instance of the GUITest class (which is a frame), then invoke its setupGUI function to create the GUI, and finally to display the GUI with the statement window.mainloop().\nLet’s work on the constructor of the GUITest class:\ndef __init__(self, master):\n  Frame.__init__(self, master)\n  self.master = master\nThe constructor first calls the constructor of its superclass (the Frame class). Then, it declares an instance variable, master, that stores the main window. This is necessary so that the setupGUI function can add widgets as children of the main window.\nNow on to the setupGUI function. We’ll build the function a little at a time. First, let’s add the first label, l1:\ndef setupGUI(self):\n  l1 = Label(self.master, text=\"A label\")\n  l1.grid(row=0, column=0, sticky=W)\nThe first statement instantiates a new Label, makes it a child of the main window (again, called master in the GUITest class), and sets its text. The second statement defines its properties with respect to the grid manager. It is to be positioned in row 0, column 0, and is to be left-aligned (to the West).\nThe next label, l2, is similarly created; however, it is to be positioned in row 1, column 0, and has different text:\nl2 = Label(self.master, text=\"Another label\")\nl2.grid(row=1, column=0, sticky=W)\nThe third label is centered across two columns (0 and 1; therefore, it spans across two columns) in row 2. It also sets the sticky option to E+W, meaning that it will evenly split any leftover space within its container to the left and right (i.e., it will be centered):\nl3 = Label(self.master, text=\"A third label, centered\")\nl3.grid(row=2, column=0, columnspan=2, sticky=E+W)\nThe fourth and final label is an image that is centered across two rows (0 and 1) and two columns (2 and 3). Images are handled a bit differently than text. The image must first be loaded from a file and stored in a variable. This is done by using Tkinter’s PhotoImage class:\nimg = PhotoImage(file=\"smile.gif\")\nNote that the specified image file must be located in the same directory as the Python program. The label can then be created, with the image set as its contents:\nl4 = Label(self.master, image=img)\nl4.image = img\nl4.grid(row=0, column=2, columnspan=2, rowspan=2,\\\n sticky=N+S+E+W)\nThe second statement appears to be redundant. That is, the first seems to assign the variable img as the label’s image; however, the second statement seems to do the same thing. It turns out that an image created using the PhotoImage class is “garbage collected” when a function that created it terminates. Once the setupGUI function terminates, the image disappears from the GUI. To prevent this from happening, we can keep an extra reference to the image. The second statement does this. The sticky option is set to N+S+E+W, which centers the image both horizontally and vertically.\nNext, the first text entry is created, centered in row 0, column 1:\ne1 = Entry(self.master)\ne1.grid(row=0, column=1)\nAs mentioned earlier, widgets are centered by default when positioned using the grid manager. The second text entry widget is similarly added; however, it is in row 1, column 1. In addition, it contains default text that is added by using the insert function in the Entry class. This is accomplished by inserting text at the END position of the text entry widget:\ne2 = Entry(self.master)\ne2.insert(END, \"user input\")\ne2.grid(row=1, column=1)\nThe Checkbutton widget is left-aligned in row 3 and spans across columns 0 and 1:\nc1 = Checkbutton(self.master,\\\n text=\"Some Checkbutton option\")\nc1.grid(row=3, column=0, columnspan=2, sticky=W)\nFinally, the two buttons are added. The first button is centered in row 3, column 2:\nb1 = Button(self.master, text=\"A button\")\nb1.grid(row=3, column=2)\nAnd the second button is centered in row 3, column 3:\nb2 = Button(self.master, text=\"Another button\")\nb2.grid(row=3, column=3)\nThis completes the setupGUI function. Here’s a complete listing of the function for reference:\nfrom tkinter import *\nclass GUITest(Frame):\n def __init__(self, master):\n Frame.__init__(self, master)\n self.master = master\n def setupGUI(self):\n l1 = Label(self.master, text=\"A label\")\n l1.grid(row=0, column=0, sticky=W)\n\n l2 = Label(self.master, text=\"Another label\")\n l2.grid(row=1, column=0, sticky=W)\n\n l3 = Label(self.master, text=\"A third label, centered\")\n l3.grid(row=2, column=0, columnspan=2, sticky=E+W)\n\n img = PhotoImage(file=\"smile.gif\")\n l4 = Label(self.master, image=img)\n l4.image = img\n l4.grid(row=0, column=2, columnspan=2, rowspan=2,\\\n sticky=N+S+E+W)\n\n e1 = Entry(self.master)\n e1.grid(row=0, column=1)\n\n e2 = Entry(self.master)\n e2.insert(END, \"user input\")\n e2.grid(row=1, column=1)\n\n c1 = Checkbutton(self.master, text=\\\n \"Some Checkbutton option\")\n c1.grid(row=3, column=0, columnspan=2, sticky=W)\n\n b1 = Button(self.master, text=\"A button\")\n b1.grid(row=3, column=2)\n\n b2 = Button(self.master, text=\"Another button\")\n b2.grid(row=3, column=3)\n\nwindow = Tk()\nt = GUITest(window)\nt.setupGUI()\nwindow.mainloop()\nAs a final example, let’s create a GUI on which two-dimensional points are plotted in various colors as follows:\n\n\n\n\n\nThe Canvas widget allows plotting points, among other useful things. It is quite important to note that the top-left of the canvas is the origin with the coordinates (0,0). It is possible to shift the origin, but this is beyond the scope of this lesson.\nContinuing with the strategy of implementing a class that inherits from a Tkinter widget, we’ll structure this example such that our user-defined class, Points, inherits from Tkinter’s Canvas class. Since some of the points that will be plotted are random (that is, with random x- and y-coordinates), the randint function of Python’s random class will be used. For flexibility, several constants will be defined: the width and height of the window, the various colors that points can be plotted in, the radius of the points, and the total number of points to plot. Structuring the program in this way will make it very easy to quickly test the program with different parameters\nLet’s take a look at the source code:\nfrom tkinter import *\nfrom random import randint\n\nWIDTH = 400\nHEIGHT = 400\nPOINT_COLORS = [ \"black\", \"red\", \"green\", \"blue\" ]\nPOINT_RADIUS = 0\nNUM_POINTS = 2500\n\nclass Points(Canvas):\n def __init__(self, master):\n Canvas.__init__(self, master, bg=\"white\")\n self.pack(fill=BOTH, expand=1)\n \n def plotPoints(self, n):\n    for i in range(WIDTH):\n        self.plot(i, i)\n        self.plot(WIDTH - i - 1, i)\n    for i in range(n):\n        x = randint(0, WIDTH - 1)\n        y = randint(0, HEIGHT - 1)\n        self.plot(x, y)\n \n def plot(self, x, y):\n    color = POINT_COLORS[randint(0, len(POINT_COLORS) - 1)]\n    color2 = POINT_COLORS[randint(0, len(POINT_COLORS) - 1)]\n    self.create_oval(x, y,\\\n        x + POINT_RADIUS * 2,\\\n        y + POINT_RADIUS * 2,\\\n        outline=color, fill=color2)\n\nwindow = Tk()\nwindow.geometry(\"{}x{}\".format(WIDTH, HEIGHT))\nwindow.title(\"Check out these points!\")\np = Points(window)\np.plotPoints(NUM_POINTS)\nwindow.mainloop()\nBy default, the width and height of the main window is defined to be 400x400 pixels. Knowing that the top-left of the canvas is the origin, then the bottom-right must have the coordinates (399,399). The points are plotted in four colors: black, red, green, and blue. Using the Canvas class, points are drawn as ovals. An oval is specified by a rectangular bounding box (specifically by its top-left and bottomright coordinates). If these coordinates are the same, the the oval is just a point. You will see how the constant POINT_RADIUS will be used in a later example. Finally, 2,500 points are plotted.\nThe main part of the program (at the bottom of the source code) should be familiar. There are, however, two new statements. The first sets the width and height of the window (collectively known as the window’s geometry):\nwindow.geometry(\"{}x{}\".format(WIDTH, HEIGHT))\nThis statement sets the window’s dimensions to the values of the constants WIDTH and HEIGHT. The second statement sets the window’s title (the text at the top of the window):\nwindow.title(\"Check out these points!\")\nThe final three statements create the GUI, plot the points, and display the GUI on the desktop.\nLet’s take a look at the Points class:\n1: class Points(Canvas):\n2:     def __init__(self, master):\n3:         Canvas.__init__(self, master, bg=\"white\")\n4:         self.pack(fill=BOTH, expand=1)\n\n5:     def plotPoints(self, n):\n6:         for i in range(WIDTH):\n7:             self.plot(i, i)\n8:             self.plot(WIDTH - i - 1, i)\n9:         for i in range(n):\n10:             x = randint(0, WIDTH - 1)\n11:             y = randint(0, HEIGHT - 1)\n12:             self.plot(x, y)\n\n13:    def plot(self, x, y):\n14:         color = POINT_COLORS[randint(0,\\\n15:             len(POINT_COLORS) - 1)]\n16:         self.create_oval(x, y, x + POINT_RADIUS * 2,\\\n17:             y + POINT_RADIUS * 2, outline=color)\nThe constructor of the Points class first calls the constructor of its superclass, Tkinter’s Canvas class. Note that the constructor can take various configuration parameters. In this case, the background is additionally set to white. The canvas is then configured to expand horizontally and vertically to fill the main window (i.e., it will expand to fit in the 400x400 pixel window).\nThe plotPoints function does the bulk of generating the points to plot. The first part of the code (in lines 6 through 8) generates the set of points required to produce an X shape in the GUI. The variable i iterates from 0 through 399 (all valid x- and y- coordinate locations on the canvas). The first set of points generated have matching coordinates (e.g., (0,0), (1,1), (2,2), and so on). This forms the set of points from the top-left to the bottom-right of the canvas. The second set of points generated have opposite coordinates with respect to the width of the canvas. That is, when the x-component is 0, the ycomponent is 399; when the x-component is 1, the y-component is 398; and so on. This forms the set of points from the bottom-left to the top-right of the canvas.\nThe second part of the plotPoints function (in lines 9 through 12) generates n random points (2,500 in the case of the program above). Recall that the randint function takes a closed interval. That is, the first and last parameters passed in to the function express the valid range of random integers to generate, inclusive of the low and high values.\nFinally, the plot function (in lines 13 through 17) actually plots the points on the canvas. First, in lines 14 and 15, a color is randomly selected from the list of colors that was defined as a constant near the top of the program. Next, an oval is drawn on the canvas within the specified bounding box. With the current set of parameters, the oval is just a point with no radius. The oval is drawn in the randomly selected color by specifying its outline to be of that color\nWe can observe the behavior of the create_oval function in the Canvas class a bit more by changing the radius of the points to something larger (say, 2) by modifying the POINT_RADIUS constant at the top of the program as follows:\nPOINT_RADIUS = 2\nThe output of the program looks a bit different:\n\n\n\n\n\nThe “points” now have a radius that is greater than 0. The bounding box of a “point” is defined by the x- and y-coordinates of the point and the point’s radius. The top-left of the bounding box is just the xand y-coordinates of the point. The bottom-right takes the radius into account. That is, the coordinates of the point really represent its top-left “corner”, while its bottom-right “corner” is adjusted to account for the specified radius (twice, in fact, to make up the entire diameter). When we keep the radius the same for both corners of the bounding box, the oval becomes a circle. In fact, a circle is just a special case of an oval.\nWe can actually fill the points as well by slightly modifying the statement on lines 16 and 17:\n16: self.create_oval(x, y, x + POINT_RADIUS * 2,\\\n17:     y + POINT_RADIUS * 2, outline=color, fill=color)\nWe include a fill option that takes a color that the center of the oval will be filled with. Clearly, an oval can have two different colors: one for its outline, and one for its “inside”.\nHere’s the output of the program with the fill option set as specified above:\n\n\n\n\n\nLastly, here’s the output of the program with the fill option set to a random color, and the outline option set to another random color (note that it is possible that both colors are the same):"
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/01 Introduction.html",
    "href": "lessons/03 Number Systems and Binary Arithmetic/01 Introduction.html",
    "title": "Number Systems and Binary Arithmetic",
    "section": "",
    "text": "The most basic unit of storage is the bit. At any point in time, a bit can be in only one of two states:\n\n0 or 1\n\nBits are generally implemented as two-state electronic devices (e.g., a current is flowing or not flowing, a voltage is high or low, a magnetic field is polarized in one direction or the opposite direction, etc). The symbol “0” is used to represent one of these states and the symbol “1” is used to represent the other. It really doesn’t matter which symbol (the “0” or the “1”) represents which physical state (e.g., “high” or “low”). All that is important is that the symbols be assigned consistently and that the two states be clearly distinguishable from each other.\nSequences (or “patterns”) of bit values can be used to represent numbers (both positive and negative, integer and real), alphanumeric characters, images, sounds, and even program instructions. In fact, anything that can be stored in a computer must ultimately be stored as a pattern of bit values.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Introduction"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/01 Introduction.html#introduction",
    "href": "lessons/03 Number Systems and Binary Arithmetic/01 Introduction.html#introduction",
    "title": "Number Systems and Binary Arithmetic",
    "section": "",
    "text": "The most basic unit of storage is the bit. At any point in time, a bit can be in only one of two states:\n\n0 or 1\n\nBits are generally implemented as two-state electronic devices (e.g., a current is flowing or not flowing, a voltage is high or low, a magnetic field is polarized in one direction or the opposite direction, etc). The symbol “0” is used to represent one of these states and the symbol “1” is used to represent the other. It really doesn’t matter which symbol (the “0” or the “1”) represents which physical state (e.g., “high” or “low”). All that is important is that the symbols be assigned consistently and that the two states be clearly distinguishable from each other.\nSequences (or “patterns”) of bit values can be used to represent numbers (both positive and negative, integer and real), alphanumeric characters, images, sounds, and even program instructions. In fact, anything that can be stored in a computer must ultimately be stored as a pattern of bit values.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Introduction"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/03 Hexadecimal.html",
    "href": "lessons/03 Number Systems and Binary Arithmetic/03 Hexadecimal.html",
    "title": "CSC 131",
    "section": "",
    "text": "Base sixteen, or hexadecimal, uses sixteen symbols: “0” through “9” for the numbers zero through nine, and “A” through “F” for the numbers ten through fifteen. The number sixteen is written as “10” in base sixteen, since after the symbol “F” is encountered, it is necessary to cycle back to the beginning of the sequence, “0.” When this occurs, the digit immediately to the left of the current digit (an understood “0”) is incremented to “1,” giving “10.” The following illustrates the base ten, base two, and base sixteen representations of the numbers zero through twenty. For readability, binary numbers have been padded to the left with zeros:\n\n\n\nBase 10 (decimal)\nBase 2 (binary)\nBase 16 (hexadecimal)\n\n\n\n\n0\n00000\n0\n\n\n1\n00001\n1\n\n\n2\n00010\n2\n\n\n3\n00011\n3\n\n\n4\n00100\n4\n\n\n5\n00101\n5\n\n\n6\n00110\n6\n\n\n7\n00111\n7\n\n\n8\n01000\n8\n\n\n9\n01001\n9\n\n\n10\n01010\nA\n\n\n11\n01011\nB\n\n\n12\n01100\nC\n\n\n13\n01101\nD\n\n\n14\n01110\nE\n\n\n15\n01111\nF\n\n\n16\n10000\n10\n\n\n17\n10001\n11\n\n\n18\n10010\n12\n\n\n19\n10011\n13\n\n\n20\n10100\n14\n\n\n\nIn order to clearly distinguish which base a number-symbol is to be interpreted under, we generally write the base (two, ten, or sixteen) as a subscript immediately following the digits of the number. Therefore, 112 is three, 1110 is eleven, and 1116 is seventeen. It is standard operating procedure to omit the subscript base if the number is in base 10 (decimal). Repeating the above examples: 112 is three, 11 is eleven, and 1116 is seventeen.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Hexadecimal"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/03 Hexadecimal.html#the-hexadecimal-number-system",
    "href": "lessons/03 Number Systems and Binary Arithmetic/03 Hexadecimal.html#the-hexadecimal-number-system",
    "title": "CSC 131",
    "section": "",
    "text": "Base sixteen, or hexadecimal, uses sixteen symbols: “0” through “9” for the numbers zero through nine, and “A” through “F” for the numbers ten through fifteen. The number sixteen is written as “10” in base sixteen, since after the symbol “F” is encountered, it is necessary to cycle back to the beginning of the sequence, “0.” When this occurs, the digit immediately to the left of the current digit (an understood “0”) is incremented to “1,” giving “10.” The following illustrates the base ten, base two, and base sixteen representations of the numbers zero through twenty. For readability, binary numbers have been padded to the left with zeros:\n\n\n\nBase 10 (decimal)\nBase 2 (binary)\nBase 16 (hexadecimal)\n\n\n\n\n0\n00000\n0\n\n\n1\n00001\n1\n\n\n2\n00010\n2\n\n\n3\n00011\n3\n\n\n4\n00100\n4\n\n\n5\n00101\n5\n\n\n6\n00110\n6\n\n\n7\n00111\n7\n\n\n8\n01000\n8\n\n\n9\n01001\n9\n\n\n10\n01010\nA\n\n\n11\n01011\nB\n\n\n12\n01100\nC\n\n\n13\n01101\nD\n\n\n14\n01110\nE\n\n\n15\n01111\nF\n\n\n16\n10000\n10\n\n\n17\n10001\n11\n\n\n18\n10010\n12\n\n\n19\n10011\n13\n\n\n20\n10100\n14\n\n\n\nIn order to clearly distinguish which base a number-symbol is to be interpreted under, we generally write the base (two, ten, or sixteen) as a subscript immediately following the digits of the number. Therefore, 112 is three, 1110 is eleven, and 1116 is seventeen. It is standard operating procedure to omit the subscript base if the number is in base 10 (decimal). Repeating the above examples: 112 is three, 11 is eleven, and 1116 is seventeen.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Hexadecimal"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/06 Binary Adder.html",
    "href": "lessons/03 Number Systems and Binary Arithmetic/06 Binary Adder.html",
    "title": "CSC 131",
    "section": "",
    "text": "An adder, as its name implies, is a circuit for adding binary numbers. The simplest adder adds two bits. As shown above, adding two bits can result in the following:\n\nWhen adding, two parts are produced: a sum and a carry (each of which can be either 0 or 1). A circuit to implement the behavior of an adder will need two inputs (one for each of the single-bit numbers) and two outputs (one for the sum and one for the carry). Constructing such a circuit is fairly straightforward. Consider the following truth table for the adder (where S is sum and C is carry):\n\nNotice that the values in the S column correspond to an xor of the two inputs, while the values in the C column correspond to an and of the two inputs. Here are their respective truth tables for reference:\n\nNote how the output of the xor gate is exactly the same as the sum bit produced by the adder. Similarly, the output of the and gate is exactly the same as the carry bit produced by the adder. Constructing the circuit is almost too easy:\n\nThis circuit is called a half adder. It has two Boolean expressions: \\(S=(A \\cdot \\bar{B})+(\\bar{A} \\cdot B)\\) and \\(C=A \\cdot B\\) . While a half adder does add two single-bit numbers and can generate a carry, it has no provision for a carry input into the circuit. As shown above, when adding two multi-bit binary numbers, one works column by column from right-to-left, making sure that the carry bit from the previous column is added into the current column. Here is the illustration of this process show earlier, on 38 and 15:\n\nA half adder could be used to add the right-most (low-order) bits of the two numbers, but it is not general enough to add the digits of an arbitrary column since it does not support a carry as input.\nA full adder overcomes this limitation of the half adder by allowing a carry to be fed into the circuit along with a bit from each of the numbers to be added. Thus, a full adder will have three inputs: the two bits being added, plus a carry in. Only two output bits, the sum and a carry out, are needed because the largest result that can be produced by the circuit will be three (112). This occurs when all three inputs are 1. Here is a complete truth table for a full adder. The inputs are almost the same as before, except that the carry in is labeled Cin, and the carry out is labeled Cout:\n\n\n\nCin\nA\nB\nS\nCout\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n1\n0\n\n\n0\n1\n1\n0\n1\n\n\n1\n0\n0\n1\n0\n\n\n1\n0\n1\n0\n1\n\n\n1\n0\n0\n0\n1\n\n\n1\n1\n1\n1\n1\n\n\n\nDesigning a circuit to implement this behavior from scratch would be challenging. However, through careful observation and the use of two half adders, the job is manageable. Since we’ll be using half adders to build the full adder, our circuit diagram will be simpler if we imagine the half adder encapsulated into a black box, as shown below:\n\nThe trick to building a full adder is to think of the sum of the three terms, A + B + Cin, as a sequence of two sums associated left to right: (A + B) + Cin. One half adder will be used to compute the sum A + B. The sum bit output by this half adder, along with Cin, will be fed as input into a second half adder. The sum bit produced by the second half adder will serve as the sum bit of the full adder. The carry out bit of the full adder is produced by routing the carry out bits of both half adders into an or gate. This is illustrated below:\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to develop a complete implementation of the full adder using only and, or, and not gates.\nNow verify that this circuit does, in fact, generate the truth table for binary addition.\n\n\n\nJust as we encapsulated the half adder, we can encapsulate the single-bit full adder into a black box.\n\nThis representation looks a little different than the previous circuit because it has been rotated clockwise 90 degrees to make the following figure easier to read. Note that the inputs, outputs, behavior, and internal details of the circuit remain unchanged.\nMulti-bit adders can be implemented as a chain of single-bit full adders where the carry out of each adder is routed to the carry in of the adder immediately to its left. Under this scheme, each full adder is essentially responsible for adding a single bit of each of the two input numbers, plus the carry bit generated by the adder immediately to its right. The carry in for the rightmost adder is permanently set to 0. The carry out of the leftmost adder indicates whether or not addition of the inputs produces an overflow. We will cover why this is necessary later when discussing how numbers are represented.\nHere’s a four-bit adder constructed from four single-bit (full) adders. In this example, A holds the number six (01102) and B holds seven (01112). The result of this addition operation is 11012, or thirteen:\n\nInterestingly, we can continue to build this. To illustrate this, let’s go back one step to the full adder. We can chain two full adders together (each of which can effectively produce the sum and Cout of A, B, and Cin) to produce the sum of two 2-bit numbers as follows:\n\nIndeed, 102 + 112 = 1012 (the overflow bit is 1). And now we can box the two full adders into a single 2- bit adder as follows:\n\nThe result is the same as chaining two full adders. The Cout of the first full adder that is wired to the Cin of the second full adder is now internal to the 2-bit adder. This 2-bit adder effectively adds two 2-bit numbers (A and B composed of the bits A0, A1, B0, and B1). It produces two sums (S0 and S1 – one for each bit) and a Cout (the overflow bit).\nWe can chain several 2-bit adders in a similar manner to produce a 4-bit adder as follows:\n\nThe effect is the same as show earlier when we chained four full adders. This combination of two 2-bit adders produces the same sum: 01102 + 01112 = 11012 (the overflow bit is 0). Of course, this can be continued. We could encapsulate the two 2-bit adders into a 4-bit adder, and chain two of those to produce a single 8-bit adder. Two 8-bit adders could be encapsulated into a single 16-bit adder. Two 16-bit adders could be encapsulated into a single 32-bit adder. And this can go on and on. The incredible part about this is that, in the end, a seemingly complicated 32-bit adder is still just made up of many full adders chained together, which are themselves made up of half adders, which are themselves made up of the three primitive logic gates: and, or, and not. Simply amazing!",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Binary Adder"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/06 Binary Adder.html#binary-adder",
    "href": "lessons/03 Number Systems and Binary Arithmetic/06 Binary Adder.html#binary-adder",
    "title": "CSC 131",
    "section": "",
    "text": "An adder, as its name implies, is a circuit for adding binary numbers. The simplest adder adds two bits. As shown above, adding two bits can result in the following:\n\nWhen adding, two parts are produced: a sum and a carry (each of which can be either 0 or 1). A circuit to implement the behavior of an adder will need two inputs (one for each of the single-bit numbers) and two outputs (one for the sum and one for the carry). Constructing such a circuit is fairly straightforward. Consider the following truth table for the adder (where S is sum and C is carry):\n\nNotice that the values in the S column correspond to an xor of the two inputs, while the values in the C column correspond to an and of the two inputs. Here are their respective truth tables for reference:\n\nNote how the output of the xor gate is exactly the same as the sum bit produced by the adder. Similarly, the output of the and gate is exactly the same as the carry bit produced by the adder. Constructing the circuit is almost too easy:\n\nThis circuit is called a half adder. It has two Boolean expressions: \\(S=(A \\cdot \\bar{B})+(\\bar{A} \\cdot B)\\) and \\(C=A \\cdot B\\) . While a half adder does add two single-bit numbers and can generate a carry, it has no provision for a carry input into the circuit. As shown above, when adding two multi-bit binary numbers, one works column by column from right-to-left, making sure that the carry bit from the previous column is added into the current column. Here is the illustration of this process show earlier, on 38 and 15:\n\nA half adder could be used to add the right-most (low-order) bits of the two numbers, but it is not general enough to add the digits of an arbitrary column since it does not support a carry as input.\nA full adder overcomes this limitation of the half adder by allowing a carry to be fed into the circuit along with a bit from each of the numbers to be added. Thus, a full adder will have three inputs: the two bits being added, plus a carry in. Only two output bits, the sum and a carry out, are needed because the largest result that can be produced by the circuit will be three (112). This occurs when all three inputs are 1. Here is a complete truth table for a full adder. The inputs are almost the same as before, except that the carry in is labeled Cin, and the carry out is labeled Cout:\n\n\n\nCin\nA\nB\nS\nCout\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n0\n\n\n0\n1\n0\n1\n0\n\n\n0\n1\n1\n0\n1\n\n\n1\n0\n0\n1\n0\n\n\n1\n0\n1\n0\n1\n\n\n1\n0\n0\n0\n1\n\n\n1\n1\n1\n1\n1\n\n\n\nDesigning a circuit to implement this behavior from scratch would be challenging. However, through careful observation and the use of two half adders, the job is manageable. Since we’ll be using half adders to build the full adder, our circuit diagram will be simpler if we imagine the half adder encapsulated into a black box, as shown below:\n\nThe trick to building a full adder is to think of the sum of the three terms, A + B + Cin, as a sequence of two sums associated left to right: (A + B) + Cin. One half adder will be used to compute the sum A + B. The sum bit output by this half adder, along with Cin, will be fed as input into a second half adder. The sum bit produced by the second half adder will serve as the sum bit of the full adder. The carry out bit of the full adder is produced by routing the carry out bits of both half adders into an or gate. This is illustrated below:\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to develop a complete implementation of the full adder using only and, or, and not gates.\nNow verify that this circuit does, in fact, generate the truth table for binary addition.\n\n\n\nJust as we encapsulated the half adder, we can encapsulate the single-bit full adder into a black box.\n\nThis representation looks a little different than the previous circuit because it has been rotated clockwise 90 degrees to make the following figure easier to read. Note that the inputs, outputs, behavior, and internal details of the circuit remain unchanged.\nMulti-bit adders can be implemented as a chain of single-bit full adders where the carry out of each adder is routed to the carry in of the adder immediately to its left. Under this scheme, each full adder is essentially responsible for adding a single bit of each of the two input numbers, plus the carry bit generated by the adder immediately to its right. The carry in for the rightmost adder is permanently set to 0. The carry out of the leftmost adder indicates whether or not addition of the inputs produces an overflow. We will cover why this is necessary later when discussing how numbers are represented.\nHere’s a four-bit adder constructed from four single-bit (full) adders. In this example, A holds the number six (01102) and B holds seven (01112). The result of this addition operation is 11012, or thirteen:\n\nInterestingly, we can continue to build this. To illustrate this, let’s go back one step to the full adder. We can chain two full adders together (each of which can effectively produce the sum and Cout of A, B, and Cin) to produce the sum of two 2-bit numbers as follows:\n\nIndeed, 102 + 112 = 1012 (the overflow bit is 1). And now we can box the two full adders into a single 2- bit adder as follows:\n\nThe result is the same as chaining two full adders. The Cout of the first full adder that is wired to the Cin of the second full adder is now internal to the 2-bit adder. This 2-bit adder effectively adds two 2-bit numbers (A and B composed of the bits A0, A1, B0, and B1). It produces two sums (S0 and S1 – one for each bit) and a Cout (the overflow bit).\nWe can chain several 2-bit adders in a similar manner to produce a 4-bit adder as follows:\n\nThe effect is the same as show earlier when we chained four full adders. This combination of two 2-bit adders produces the same sum: 01102 + 01112 = 11012 (the overflow bit is 0). Of course, this can be continued. We could encapsulate the two 2-bit adders into a 4-bit adder, and chain two of those to produce a single 8-bit adder. Two 8-bit adders could be encapsulated into a single 16-bit adder. Two 16-bit adders could be encapsulated into a single 32-bit adder. And this can go on and on. The incredible part about this is that, in the end, a seemingly complicated 32-bit adder is still just made up of many full adders chained together, which are themselves made up of half adders, which are themselves made up of the three primitive logic gates: and, or, and not. Simply amazing!",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Binary Adder"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/07 Bitwise Operators.html",
    "href": "lessons/03 Number Systems and Binary Arithmetic/07 Bitwise Operators.html",
    "title": "CSC 131",
    "section": "",
    "text": "Up to this point, we’ve left out one final class of operators in Python: the bitwise operators. The reason is that they really only make sense once we understand how numbers are represented in computers. Moreover, how binary arithmetic works is fundamental to understanding them.\nThe bitwise operators work on bits and perform bit-by-bit operations. Think back to the primitive logic gates (and, or, and not) and some derivatives (e.g., xor). Each of these concepts operated on bits and produced bits. In the following table, assume that a = 60 (or 00111100 in binary) and b = 13 (or 00001101 in binary):\n\n\n\n\n\n\n\n\n\n\nOperator\nLogical Operation\nDefinition\n\n\n\n\n\n\n&\nbitwise and\na & b = 00001100 (or 12 in decimal)\n\n\n\n\n|\nbitwise or\na | b = 001111101 (or 61 in decimal)\n\n\n\n\n^\nbitwise xor\na ^ b = 00110001 (or 49 in decimal)\n\n\n\n\n~\nbitwise not\n~a = 11000011 (or -61 in decimal; we will explain this one later)\n\n\n\n\n&lt;&lt;\nleft shift\na &lt;&lt; 2 = 11110000 (or 240 in decimal)\n\n\n\n\n&gt;&gt;\nright shift\na &gt;&gt; 2 = 1111 (or 15 in decimal)\n\n\n\n\n\nThe bitwise not has the effect of inverting the bits. Why 11000011 in binary is equal to -61 in decimal will be explained in a later lesson. Here is output of the examples in the previous table in IDLE:\n&gt;&gt;&gt; a = 60\n&gt;&gt;&gt; b = 13\n&gt;&gt;&gt; bin(a)\n'0b111100'\n&gt;&gt;&gt; bin(b)\n'0b1101'\n&gt;&gt;&gt; a & b\n12\n&gt;&gt;&gt; bin(a & b)\n'0b1100'\n&gt;&gt;&gt; a | b\n&gt;&gt;&gt; bin(a | b)\n'0b111101'\n&gt;&gt;&gt; a ^ b\n49\n&gt;&gt;&gt; bin(a ^ b)\n'0b110001'\n&gt;&gt;&gt; ~a\n-61\n\n&gt;&gt;&gt; a = 60\n&gt;&gt;&gt; b = 13\n&gt;&gt;&gt; a &lt;&lt; 2\n240\n&gt;&gt;&gt; bin(a &lt;&lt; 2)\n'0b11110000'\n&gt;&gt;&gt; a &gt;&gt; 2\n15\n&gt;&gt;&gt; bin(a &gt;&gt; 2)\n'0b1111'\nNote the use of the bin function. It returns the binary representation of a value. If a = 60, the statement bin(a) returns 0b111100 (which is 60 in binary). The prefix 0b implies binary. In fact, you can assign values to variables in binary form using this prefix:\n&gt;&gt;&gt; a = 0b00111100\n&gt;&gt;&gt; a\n60\nThis can be done in other bases as well. For example, in hexadecimal (with the prefix 0x) or in octal (with the prefix 0o):\n&gt;&gt;&gt; a = 0b00111100\n&gt;&gt;&gt; a\n60\n&gt;&gt;&gt; b = 0xff\n&gt;&gt;&gt; b\n255\n&gt;&gt;&gt; c = 0o15\n&gt;&gt;&gt; c\n13",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Bitwise Operators"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/07 Bitwise Operators.html#bitwise-operators-in-python",
    "href": "lessons/03 Number Systems and Binary Arithmetic/07 Bitwise Operators.html#bitwise-operators-in-python",
    "title": "CSC 131",
    "section": "",
    "text": "Up to this point, we’ve left out one final class of operators in Python: the bitwise operators. The reason is that they really only make sense once we understand how numbers are represented in computers. Moreover, how binary arithmetic works is fundamental to understanding them.\nThe bitwise operators work on bits and perform bit-by-bit operations. Think back to the primitive logic gates (and, or, and not) and some derivatives (e.g., xor). Each of these concepts operated on bits and produced bits. In the following table, assume that a = 60 (or 00111100 in binary) and b = 13 (or 00001101 in binary):\n\n\n\n\n\n\n\n\n\n\nOperator\nLogical Operation\nDefinition\n\n\n\n\n\n\n&\nbitwise and\na & b = 00001100 (or 12 in decimal)\n\n\n\n\n|\nbitwise or\na | b = 001111101 (or 61 in decimal)\n\n\n\n\n^\nbitwise xor\na ^ b = 00110001 (or 49 in decimal)\n\n\n\n\n~\nbitwise not\n~a = 11000011 (or -61 in decimal; we will explain this one later)\n\n\n\n\n&lt;&lt;\nleft shift\na &lt;&lt; 2 = 11110000 (or 240 in decimal)\n\n\n\n\n&gt;&gt;\nright shift\na &gt;&gt; 2 = 1111 (or 15 in decimal)\n\n\n\n\n\nThe bitwise not has the effect of inverting the bits. Why 11000011 in binary is equal to -61 in decimal will be explained in a later lesson. Here is output of the examples in the previous table in IDLE:\n&gt;&gt;&gt; a = 60\n&gt;&gt;&gt; b = 13\n&gt;&gt;&gt; bin(a)\n'0b111100'\n&gt;&gt;&gt; bin(b)\n'0b1101'\n&gt;&gt;&gt; a & b\n12\n&gt;&gt;&gt; bin(a & b)\n'0b1100'\n&gt;&gt;&gt; a | b\n&gt;&gt;&gt; bin(a | b)\n'0b111101'\n&gt;&gt;&gt; a ^ b\n49\n&gt;&gt;&gt; bin(a ^ b)\n'0b110001'\n&gt;&gt;&gt; ~a\n-61\n\n&gt;&gt;&gt; a = 60\n&gt;&gt;&gt; b = 13\n&gt;&gt;&gt; a &lt;&lt; 2\n240\n&gt;&gt;&gt; bin(a &lt;&lt; 2)\n'0b11110000'\n&gt;&gt;&gt; a &gt;&gt; 2\n15\n&gt;&gt;&gt; bin(a &gt;&gt; 2)\n'0b1111'\nNote the use of the bin function. It returns the binary representation of a value. If a = 60, the statement bin(a) returns 0b111100 (which is 60 in binary). The prefix 0b implies binary. In fact, you can assign values to variables in binary form using this prefix:\n&gt;&gt;&gt; a = 0b00111100\n&gt;&gt;&gt; a\n60\nThis can be done in other bases as well. For example, in hexadecimal (with the prefix 0x) or in octal (with the prefix 0o):\n&gt;&gt;&gt; a = 0b00111100\n&gt;&gt;&gt; a\n60\n&gt;&gt;&gt; b = 0xff\n&gt;&gt;&gt; b\n255\n&gt;&gt;&gt; c = 0o15\n&gt;&gt;&gt; c\n13",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Bitwise Operators"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/01 Introduction.html",
    "href": "lessons/02 Object Oriented Programming/01 Introduction.html",
    "title": "The Object-Oriented Paradigm",
    "section": "",
    "text": "As discussed in lessons early in the curriculum, three paradigms of programming languages have emerged over the years:\n\nthe imperative paradigm\nthe functional paradigm\nthe logical paradigm.\n\nA language is classified as belonging to a particular paradigm based on the programming features it supports. In addition, during the past decade or so these paradigms have been extended to include object-oriented features. Some computer scientists view object-oriented programming as a fourth paradigm. Others prefer to view it as an extension to the imperative, functional, and logical paradigms, in that object-oriented constructs and behaviors are often viewed as higher-level organizational attributes that can be incorporated into each of the three basic paradigms, rather than as a separate programming paradigm unto itself.\nObject-oriented concepts have revolutionized programming languages. The vast majority of widely used programming languages are now object-oriented. In fact, they are, by far, the most popular type of programming languages. Python, Java, and C++ are object-oriented, imperative languages. Specifically, Python is an imperative, interpreted language that can optionally be object-oriented. That is, non-object-oriented programs can be written in Python if desired. In a sense, this makes Python quite powerful (like a Swiss army knife of programming).\nThe object-oriented paradigm is an elegant and clean way to conceptually think about computer programming. When used properly, it can produce programs that are more robust, less likely to have errors, and are easy for others to understand and modify. Specifically, the object-oriented approach adds the concepts of objects and messages to the paradigms listed above. We don’t think of programs as procedures or lists of instructions to be executed in order from beginning to end; rather, we think of them as modeling a collection of objects interacting with each other.\nEssentially, programs and the data on which they act are viewed as objects. In order to perform a task, an object must receive a message indicating that work needs to be done. Object-oriented languages are extremely useful for writing complex programs; for example, programs that support mouse-based, graphical user interfaces. Object-oriented programming helps in the construction of software systems by enabling large, complex systems to be subdivided into isolated functional units with well-defined external interfaces to other system components. There are many other distinguishing characteristics of object-oriented programs, including inheritance, polymorphism, and data encapsulation. Some of these will be discussed in this lesson, while others will be covered in later lessons",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Introduction"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/01 Introduction.html#introduction",
    "href": "lessons/02 Object Oriented Programming/01 Introduction.html#introduction",
    "title": "The Object-Oriented Paradigm",
    "section": "",
    "text": "As discussed in lessons early in the curriculum, three paradigms of programming languages have emerged over the years:\n\nthe imperative paradigm\nthe functional paradigm\nthe logical paradigm.\n\nA language is classified as belonging to a particular paradigm based on the programming features it supports. In addition, during the past decade or so these paradigms have been extended to include object-oriented features. Some computer scientists view object-oriented programming as a fourth paradigm. Others prefer to view it as an extension to the imperative, functional, and logical paradigms, in that object-oriented constructs and behaviors are often viewed as higher-level organizational attributes that can be incorporated into each of the three basic paradigms, rather than as a separate programming paradigm unto itself.\nObject-oriented concepts have revolutionized programming languages. The vast majority of widely used programming languages are now object-oriented. In fact, they are, by far, the most popular type of programming languages. Python, Java, and C++ are object-oriented, imperative languages. Specifically, Python is an imperative, interpreted language that can optionally be object-oriented. That is, non-object-oriented programs can be written in Python if desired. In a sense, this makes Python quite powerful (like a Swiss army knife of programming).\nThe object-oriented paradigm is an elegant and clean way to conceptually think about computer programming. When used properly, it can produce programs that are more robust, less likely to have errors, and are easy for others to understand and modify. Specifically, the object-oriented approach adds the concepts of objects and messages to the paradigms listed above. We don’t think of programs as procedures or lists of instructions to be executed in order from beginning to end; rather, we think of them as modeling a collection of objects interacting with each other.\nEssentially, programs and the data on which they act are viewed as objects. In order to perform a task, an object must receive a message indicating that work needs to be done. Object-oriented languages are extremely useful for writing complex programs; for example, programs that support mouse-based, graphical user interfaces. Object-oriented programming helps in the construction of software systems by enabling large, complex systems to be subdivided into isolated functional units with well-defined external interfaces to other system components. There are many other distinguishing characteristics of object-oriented programs, including inheritance, polymorphism, and data encapsulation. Some of these will be discussed in this lesson, while others will be covered in later lessons",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Introduction"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/05 Accessors and Mutators.html",
    "href": "lessons/02 Object Oriented Programming/05 Accessors and Mutators.html",
    "title": "CSC 131",
    "section": "",
    "text": "Consider the following simple dog class:\nclass Dog:\n    kind = \"canine\"\n    \n    def __init__(self, name):\n        self.name = name\n        self.age = 0\n    \nd1 = Dog(\"Maya\")\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age))\nd1.age = -5\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age))\nEverything seems to work fine; however, note that no dog can actually be -5 years old. This value is not possible for a dog’s age (at least not in the world that we live in). This illustrates an important point: sometimes, we may want to check that the values supplied to function parameters are sensible. For numeric types, we typically call this range checking. That is, we may need to ensure that a supplied value falls within a valid range. For example, a valid range for a dog’s age could be 0 to 29.\n\n\n\n\n\n\nDefinition\n\n\n\nRange checking is a subset of a more general concept called input validation, which attempts to validate input (whether it be from a user during program execution, from actual parameters passed in to a function’s formal parameters, etc).\n\n\nTo ensure proper execution of a program that processes inputs, the inputs must first be validated. In the example above, the input to a dog’s age must first be validated before the instance variable is assigned the value of the input.\nTo accomplish this, we can define a mutator (also known as a setter) that provides write access to an instance variable defined in a class.\n\n\n\n\n\n\nDefinition\n\n\n\nA mutator is a method that wraps an instance variable for the purpose of input validation (and often access control in some object-oriented programming languages).\n\n\nThe instance variable still exists; however, to change it, the mutator must be called instead. Once the supplied input is validated, the instance variable is then changed with the provided value. Here is a modified dog class with a mutator for the instance variable age:\nclass Dog:\n    kind = \"canine\"\n    def __init__(self, name):\n        self.name = name\n        self.age = 0\n    \n    def setAge(self, age):\n        if (age &gt;= 0 and age &lt;= 29):\n            self.age = age\n\nd1 = Dog(\"Maya\")\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age))\nd1.setAge(-5)\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age)) \nNote that the mutator is called setAge. Typically, we specifically set the name of a mutator to the word “set” followed by the name of the instance variable (initially capitalized). Since the mutator’s purpose is to change the value of an instance variable, then that value must be passed in as a function parameter. The mutator then performs range checking. In the case of the dog class above, a value from 0 through 29 is valid (and would subsequently be assigned to the instance variable age). To change the value of a dog’s age, the mutator must be called.\nBased on the output, note that the attempt to change d1’s age to -5 was not successful.\nUsing the function setAge as the mutator that enables modification of the instance variable age seems a bit tedious. In a perfect world, changing d1’s age (with input validation) would perhaps be done as follows:\nd1.age = 11\nHowever, doing it this way would effectively bypass the mutator, setAge, and ignore input validation (as seen in the earlier example). Python does provide a neat way to accomplish this, however. We often call this kind of neat behavior syntactic sugar.\n\n\n\n\n\n\nDefinition\n\n\n\nSyntactic sugar just means that a programming language provides a sensible (and often shorthand) way to accomplish a task that may, under the hood, be a bit more convoluted.\n\n\nPython provides direct support for wrapping instance variables with mutators that perform input validation through a concept called a decorator. For now, a decorator is just a wrapper. It is something that wraps something else. In this case, it is a mutator in the form of a function that wraps an instance variable.\nHowever, to properly explain how Python supports this, we must first discuss the concept of an accessor.\n\n\n\n\n\n\nDefinition\n\n\n\nAn accessor (also known as a getter) is a method that wraps an instance variable for the purpose of providing read access (i.e., to allow us to read the value of an instance variable).\n\n\nIn Python, the meaning behind this is lost because all of a class’ instance variables are directly accessible. However, in other object-oriented programming languages (such as Java, for example), we can enforce the privacy of instance variables. That is, we can restrict them such that they can only be accessed through accessors and mutators. Nevertheless, the only way that Python supports decorators as mutators is to additionally provide decorators as accessors. It may be best to first show the source code that demonstrates this:\nclass Dog:\n    kind = \"canine\"\n    def __init__(self, name):\n        self.name = name\n        self.age = 0\n\n    # accessor\n    @property\n    def age(self):\n        \n\n    # mutator\n    @age.setter\n    def age(self, age):\n        if (age &gt;= 0 and age &lt;= 29):\n        self._age = age\n\nd1 = Dog(\"Maya\")\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age))\n\nd1.age = -5\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age))\nNote that there are seemingly erroneous statements beginning with that “@” symbol (e.g., @property and @age.setter). In Python, these tags formally define decorators. The tag @property defines a decorator (or wrapper) that serves as an accessor, and the tag @age.setter defines a decorator (or wrapper) that serves as a mutator for a member called age.\nBoth the accessor and mutator are functions with the same name. In the case above, both are functions called age. Semantically, they refer to a dog’s age. Since the identifier age is now used to refer to the accessor and mutator, the instance variable that these methods wrap must be renamed. In Python, it is typical to begin instance variables with an underscore. For example, the instance variable that stores a dog’s age would be called _age.\nLet’s explain the accessor and mutator, one at a time. First, the accessor:\n@property\ndef age(self):\n    return self._age\nHere, the tag @property defines a decorator that will serve as an accessor for the instance variable that represents a dog’s age. The next statement defines the accessor itself. The function is called age (and only takes a single parameter, the object). Since the sole purpose of an accessor is to provide read access to an instance variable, then all that is required is to return its value (via the return keyword). Since the identifier age is used as the function’s name, then the instance variable has been renamed to _age as noted earlier.\nNow, the mutator:\n@age.setter\ndef age(self, age):\n    if (age &gt;= 0 and age &lt;= 29):\n        self._age = age\nHere, the tag @age.setter defines a decorator that will serve as a mutator for the instance variable that represents a dog’s age. The next statement defines the mutator itself. The function is also called age (and takes two parameters: the object and the value to change the instance variable to). Since the purpose of a mutator is to provide write access to an instance variable with input validation, it appropriately ensures that the provided value is within an acceptable range. If so, the instance variable _age is changed to reflect the provided input value.\nYou may have noticed that the decorator for the mutator, @age.setter, contains the name of the function, age. This must be adhered to when defining a decorator as a mutator. If, for instance, we wished to provide a mutator for a dog’s name, we could use the decorator tag @name.setter, call the mutator function name, and use the instance variable _name.\nNote the following statement in the constructor:\nself.age = 0\nBe careful! Here, self.age does not refer to an instance variable. It actually refers to the mutator. This assignment statement effectively calls the mutator, passing in the value on the right-hand side (0) as the second parameter of the mutator (age). That is, the value 0 is passed in to the mutator, which is then validated in the mutator. Since it is within the acceptable range (0 through 29), then the instance variable _age is set to 0.\nIt is important to note that the accessor must be defined before the mutator. Using the @property tag defines the property by name (e.g., age) so that it can be used to subsequently define the mutator (@age.setter).\nTo illustrate accessors and mutators a bit more, consider the following class that defines a 2D point (with an x- and y-coordinate):\n# points must fall within the range (-10,-10) and (10,10)\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    # getter for x\n    @property\n    def x(self):\n        return self._x\n\n    # setter for x\n    @x.setter\n    def x(self, value):\n        if (value &lt; -10):\n            self._x = -10\n        elif (value &gt; 10):\n            self._x = 10\n        else:\n            self._x = value\n\n    # getter for y\n    @property\n    def y(self):\n        return self._y\n\n    # setter for y\n    @y.setter\n    def y(self, value):\n        if (value &lt; -10):\n            self._y = -10\n        elif (value &gt; 10):\n            self._y = 10\n        else:\n            self._y = value\n\np1 = Point()\np2 = Point(5, 5)\np3 = Point(-50, 50)\nprint(\"p1=({},{})\".format(p1.x, p1.y))\nprint(\"p2=({},{})\".format(p2.x, p2.y))\nprint(\"p3=({},{})\".format(p3.x, p3.y))\nAlthough the class for a 2D point is a bit more involved, it only contains two instance variables. The first, _x, represents the position of the point in the x-direction. The second, _y, represents the position of the point in the y-direction. Accessors and mutators for each are provided (via the methods called x for the instance variable _x, and the methods called y for the instance variable _y). In addition, range checking is performed for both the x- and y-components. Each component may not be less than -10 or greater than 10.\nDid you notice something odd in the constructor? Here it is for reference:\ndef __init__(self, x=0, y=0):\n    self.x = x\n    self.y = y\nTake a look at the constructor’s parameters: (self, x=0, y=0). You probably expected something more like this: (self, x, y). In Python, we can provide default values for function parameters. This works for any function (not just the constructor). This means that, should parameter values be unspecified when the function is called, the default values will be used. In this example, a point’s default x- and y-values are 0 and 0 respectively. Therefore, a point at the origin could be instantiated as follows:\np = Point()\nOf course, such a point could also be instantiated as follows:\np = Point(0, 0)\nThe default values are only used if parameter values are not specified when the function is called. It is important to note that a function can have a mix of both standard and default parameters. In fact, the constructor is just like this (self is a standard parameter without a default value, while x and y have default values). In Python, all parameters with default values must be specified after standard parameters. This way, it is clear if values for default parameters are specified in a function call. For example:\ndef foo(a, b, c, d=5, e=7, f=8):\n    pass\n\n...\nfoo(1, 2, 3, 4)\nIn this case, the actual parameters 1, 2, 3, and 4 are mapped to the formal parameters a, b, c, and d. The default values for the formal parameters e and f are used.\nTo wrap up this section, let’s add line numbers to the point class above and trace the program’s execution:\n1: # points must fall within the range (-10,-10) and (10,10)\n2: class Point:\n3:      def __init__(self, x=0, y=0):\n4:          self.x = x\n5:          self.y = y\n\n6:      # getter for x\n7:      @property\n8:      def x(self):\n9:          self._x\n\n10:     # setter for x\n11:     @x.setter\n12:     def x(self, value):\n13:         if (value &lt; -10):\n14:             self._x = -10\n15:         elif (value &gt; 10):\n16:             self._x = 10\n17:         else:\n18:             self._x = value\n\n19:         # getter for y\n20:         @property\n21:         def y(self):\n22:             return self._y\n\n23:         # setter for y\n24:         @y.setter\n25:         def y(self, value):\n26:             if (value &lt; -10):\n27:                 self._y = -10\n28:             elif (value &gt; 10):\n29:                 self._y = 10\n30:             else:\n31:                 self._y = value\n\n32: p1 = Point()\n33: p2 = Point(5, 5)\n34: p3 = Point(-50, 50)\n35: print(\"p1=({},{})\".format(p1.x, p1.y))\n36: print(\"p2=({},{})\".format(p2.x, p2.y))\n37: print(\"p3=({},{})\".format(p3.x, p3.y))\n\n\n\n\n\n\n\nDid you know\n\n\n\nAlthough some object-oriented languages actually prevent accessing instance variables that are protected (or wrapped) with accessors and mutators, Python does not enforce this. For example, it is possible to change the x-component or access the y-component of a point via statements such as:\np1._x = -22\nprint(p1._y)\nMany Python programmers prefer to change the way they implement classes so that any value that requires protection is not stored in instance variables. There are other mechanisms that will, in fact, protect these values. However, this discussion is beyond the scope of this lesson.\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nActivity 2: Fractions\nIn this activity, we will create a class that represents a fraction. The first step is to determine what makes up a fraction (i.e., what it can be – its state). This task is pretty simple! Fractions have a numerator and a denominator. We can create instance variables for these and also provide accessors and mutators for each.\nWe may also want to provide the numeric representation of a fraction. For example, the fraction 1/2 has the numeric representation 0.5. In Python, simply dividing the numerator by the denominator (i.e., 1/2) won’t produce the anticipated result because it will perform integer division. That is, the expression 1/2 will result in 0 (since 2 goes into 1 exactly 0 times). To produce a floating point result, we must convert one of the two operands to a floating point value. In Python, we can do this as follows:\nfloat(1)/2\nThe expression float(1) converts the integer value 1 into the floating point value 1.0. Generally, the expression float(x) converts the operand x into a floating point value. Formally, this conversion is called a typecast, in that the operand’s type is cast to a different type.\nThe expression float(1) / 2 produces the expected result (0.5). In fact, typecasting either operand works – as shown in the example below:\n1//2\nfloat(1) / 2\n1 / float(2)\nThere are other typecast operators that perform various type conversions. Here are a few of them: int(x) – converts x to an integer long(x) – converts x to a long integer complex(x, y) – creates a complex number; x is the real part, y is the imaginary part str(x) – converts x to a string\nLastly, we must not allow the denominator of a fraction to ever be 0 (since division by 0 is mathematically illegal). Therefore, we will need to provide range checking (via if-statements, for example), to ensure that such an assignment is prevented.\nHere’s the beginning of the fraction class, along with a brief main program to test the class:\n# defines a fraction\nclass Fraction:\n    # by default, a fraction is 0/1\n    def __init__(self, num=0, den=1):\n        self.num = num\n        # make sure not to set the denominator to 0 if specified\n        if (den == 0):\n            den = 1\n        self.den = den\n    \n    # getter for the numerator\n    @property\n    def num(self):\n        return self._num\n    \n    # setter for the numerator\n    @num.setter\n    def num(self, value):\n        self._num = value\n    \n    # getter for the denominator\n    @property\n    def den(self):\n        return self._den\n    \n    # setter for the denominator\n    @den.setter\n    def den(self, value):\n    # ignore if the specified denominator is 0\n        if (value != 0):\n            self._den = value\n    \n    # returns a fraction's numeric representation\n    def getReal(self):\n        return float(self.num) / self.den\n\n# main program\nf1 = Fraction()\nf2 = Fraction(1, 2)\nf3 = Fraction(0, 0)\n\nprint(\"{}/{} ({})\".format(f1.num, f1.den, f1.getReal()))\nprint(\"{}/{} ({})\".format(f2.num, f2.den, f2.getReal()))\nprint(\"{}/{} ({})\".format(f3.num, f3.den, f3.getReal()))\nNote how the class prevents the third fraction from being initialized as 0/0 and instead changes it to 0/1.\n\n\n\n\n\n\n\n\n\n\nDid you know\n\n\n\nThere is a better way of displaying a fraction than what is shown in the example above. Note how we earlier structured a print statement that built the string representation of a fraction:\nprint(\"{}/{} ({})\".format(f1.num, f1.den, f1.getReal()))\nIn Python, we can define a built-in magic function that is automatically called when we wish to display an object. In fact, this built-in function is user-definable and is named using a similar format as the constructor (i.e., the function begins and ends with two underscores). The function is called __str__ and must return a string representation of the class. So for a fraction, such a function could be implemented as follows:\ndef __str__(self):\nreturn \"{}/{} ({})\".format(self.num, self.den, self.getReal())\nDisplaying a fraction would then be possible via the following much simpler statement (via syntactic sugar):\nprint(f1)\nAdding this function to the fraction class is simple. Here’s a snippet of the addition:\n# defines a fraction\n    class Fraction:\n    ...\n    # returns a fraction's string representation\n    def __str__(self):\n        return \"{}/{} ({})\".format(self.num, self.den,\\\n            self.getReal())\n...\n# main program\nf1 = Fraction(1, 2)\nf2 = Fraction(1, 4)\nf3 = f1.add(f2)\nprint(f1)\nprint(f2)\nprint(f3)\nOf course, the output is the same as before!\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nActivity 3: Reducing fractions You may have noticed that instantiating the fraction 6/8 would work just fine. The problem is that this fraction is not expressed in lowest terms. That is, it can be reduced (to 3/4). Our fraction class would greatly benefit from a function that can reduce a fraction. Such a function could be called in the constructor after setting the numerator and denominator in case it is not in lowest terms.\nAlthough there are many ways to reduce a fraction, here’s a simple algorithm that calculates the greatest common divisor (GCD) among the numerator and denominator. First, initially assume that the GCD is 1. From there, iterate, starting with 2 through the smaller of the numerator or denominator. Each time, the objective is to try to find a value that evenly divides both the numerator and denominator. As such a value is found, the GCD is updated. The final step is to divide the numerator and denominator by the GCD (which reduces the fraction). As a cleanup operation, if the numerator is 0 (i.e., the fraction’s numeric value is 0.0), the denominator is set to 1 (i.e., 0/1).\nThis is shown in the snippet of code below (which can be placed anywhere in the fraction class):\n# reduces a fraction\ndef reduce(self):\n    # we initially assume that the GCD is 1\n    # from there, we iterate starting at 2 through the smaller\n    # of the numerator or denominator\n    # since the numerator and denominator could be negative,\n    # we use their absolute values\n    # each time, we try to find a value that evenly divides\n    # both the numerator and denominator\n    # as we find such a value, we update the GCD\n    # the final step is two divide the numerator and\n    # denominator by the GCD to reduce the fraction\n    # as cleanup, if the numerator is 0 (i.e., the fraction is\n    # 0) then set the denominator to 1\n    gcd = 1\n    minimum = min(abs(self.num), abs(self.den))\n\n    # find common divisors\n    for i in range(2, int(minimum + 1)):\n        # when we find one, update the GCD\n        if (self.num % i == 0 and self.den % i == 0):\n            gcd = i\n    \n    # divide the numerator and denominator by the GCD\n    self.num /= gcd\n    self.den /= gcd\n    # if the numerator is 0, set the denominator to 1\n    if (self.num == 0):\n    self.den = 1\nThe Python math library has many useful functions. The min function returns the minimum value of a number of values passed in as parameters. This makes it quite easy to determine which of the numerator or denominator is smaller. Since a function’s numerator or denominator could be negative, we use their absolute value to determine which is smaller. The abs function returns the absolute value of a specified value.\nSo where (and when) do we call the reduce function? For the fraction class shown earlier, we could do so in the constructor as follows:\n# defines a fraction\nclass Fraction:\n    # by default, a fraction is 0/1\n    def __init__(self, num=0, den=1):\n        self.num = num\n        # make sure not to set the denominator to 0 if specified\n        if (den == 0):\n            den = 1\n        self.den = den\n        self.reduce()\nThis works; however, the mutators for the numerator and denominator may cause a fraction to no longer be reduced. We could, therefore, call the reduce function at the end of the mutators. There is a problem with this, however. Since the constructor uses the mutator for the numerator (in self.num = num) before the denominator is even set, a call to the function reduce in the mutator for the numerator would attempt to access the denominator (which doesn’t exist). This would result in an error.\nWe could try to place a call to the reduce function in the mutator for the denominator. But this is also problematic, because the reduce function uses the mutator for the denominator to change the denominator (i.e., when dividing it by the gcd). Placing it here would cause the reduce function to be recursively called infinitely!\nPerhaps the best place to put the call to the reduce function is in the __str__ function (i.e., when displaying a fraction).\n\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nActivity 4: Adding fractions… and more* Let’s now implement the functionality to add two fractions and produce the sum of these as a new fraction. We must first discuss how two fractions can be added. Typically, the least common denominator is found. A simpler version, however, is to multiply each fraction by the other’s denominator to obtain a common denominator (that is not necessarily the least common denominator).\nHere’s an illustration: \\[\n\\frac{a}{b}+\\frac{c}{d} = \\frac{a*b}{b*d}+\\frac{b*c}{b*d}\n\\]\nAs an example, take the following: \\[\n\\frac{1}{2}+\\frac{1}{4} = \\frac{1*4}{2*4}+\\frac{2*1}{2*4} = \\frac{4}{8}+\\frac{2}{8} = \\frac{6}{8} = \\frac{3}{4}\n\\]\nSo now, how do we implement a method in the fraction class that does this? One way is as follows:\n# calculates and returns the sum of two fractions\ndef add(self, other):\n    num = (self.num * other.den) + (other.num * self.den)\n    den = self.den * other.den\n    sum = Fraction(num, den)\n    sum.reduce()\n        return sum\nThis function is called as follows (specifically in the third statement below):\nf1 = Fraction(1, 2)\nf2 = Fraction(1, 4)\nf3 = f1.add(f2)\nNote that both fractions are effectively passed in to the add function. The first, f1, represents the current instance and is mapped to the first parameter, self. The second, f2, is mapped to the second parameter, other.\nThe function implements the common denominator method shown above and generates a fraction representing the sum of self and other. The new fraction is then reduced and returned. Note that calling the reduce function here is not necessary if it is called in the __str__ function.\nThe function could be optimized (perhaps at the expense of not being quite as readable) by returning a new fraction directly instead of creating one and returning it. For example:\nreturn Fraction(num, den)\nIn fact, the function could be optimized even more as follows:\nreturn Fraction(self.num * other.den + other.num * self.den,\\\nself.den * other.den)\nOf course, we could implement functions to subtract, multiply, and divide fractions! In fact, we could implement a subtract method by using the already defined add method. How? Recall that subtracting is just adding the negative. Since this will be assigned as a program later, it is left as an individual exercise for now.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Accessors and Mutators"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/05 Accessors and Mutators.html#accessors-and-mutators",
    "href": "lessons/02 Object Oriented Programming/05 Accessors and Mutators.html#accessors-and-mutators",
    "title": "CSC 131",
    "section": "",
    "text": "Consider the following simple dog class:\nclass Dog:\n    kind = \"canine\"\n    \n    def __init__(self, name):\n        self.name = name\n        self.age = 0\n    \nd1 = Dog(\"Maya\")\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age))\nd1.age = -5\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age))\nEverything seems to work fine; however, note that no dog can actually be -5 years old. This value is not possible for a dog’s age (at least not in the world that we live in). This illustrates an important point: sometimes, we may want to check that the values supplied to function parameters are sensible. For numeric types, we typically call this range checking. That is, we may need to ensure that a supplied value falls within a valid range. For example, a valid range for a dog’s age could be 0 to 29.\n\n\n\n\n\n\nDefinition\n\n\n\nRange checking is a subset of a more general concept called input validation, which attempts to validate input (whether it be from a user during program execution, from actual parameters passed in to a function’s formal parameters, etc).\n\n\nTo ensure proper execution of a program that processes inputs, the inputs must first be validated. In the example above, the input to a dog’s age must first be validated before the instance variable is assigned the value of the input.\nTo accomplish this, we can define a mutator (also known as a setter) that provides write access to an instance variable defined in a class.\n\n\n\n\n\n\nDefinition\n\n\n\nA mutator is a method that wraps an instance variable for the purpose of input validation (and often access control in some object-oriented programming languages).\n\n\nThe instance variable still exists; however, to change it, the mutator must be called instead. Once the supplied input is validated, the instance variable is then changed with the provided value. Here is a modified dog class with a mutator for the instance variable age:\nclass Dog:\n    kind = \"canine\"\n    def __init__(self, name):\n        self.name = name\n        self.age = 0\n    \n    def setAge(self, age):\n        if (age &gt;= 0 and age &lt;= 29):\n            self.age = age\n\nd1 = Dog(\"Maya\")\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age))\nd1.setAge(-5)\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age)) \nNote that the mutator is called setAge. Typically, we specifically set the name of a mutator to the word “set” followed by the name of the instance variable (initially capitalized). Since the mutator’s purpose is to change the value of an instance variable, then that value must be passed in as a function parameter. The mutator then performs range checking. In the case of the dog class above, a value from 0 through 29 is valid (and would subsequently be assigned to the instance variable age). To change the value of a dog’s age, the mutator must be called.\nBased on the output, note that the attempt to change d1’s age to -5 was not successful.\nUsing the function setAge as the mutator that enables modification of the instance variable age seems a bit tedious. In a perfect world, changing d1’s age (with input validation) would perhaps be done as follows:\nd1.age = 11\nHowever, doing it this way would effectively bypass the mutator, setAge, and ignore input validation (as seen in the earlier example). Python does provide a neat way to accomplish this, however. We often call this kind of neat behavior syntactic sugar.\n\n\n\n\n\n\nDefinition\n\n\n\nSyntactic sugar just means that a programming language provides a sensible (and often shorthand) way to accomplish a task that may, under the hood, be a bit more convoluted.\n\n\nPython provides direct support for wrapping instance variables with mutators that perform input validation through a concept called a decorator. For now, a decorator is just a wrapper. It is something that wraps something else. In this case, it is a mutator in the form of a function that wraps an instance variable.\nHowever, to properly explain how Python supports this, we must first discuss the concept of an accessor.\n\n\n\n\n\n\nDefinition\n\n\n\nAn accessor (also known as a getter) is a method that wraps an instance variable for the purpose of providing read access (i.e., to allow us to read the value of an instance variable).\n\n\nIn Python, the meaning behind this is lost because all of a class’ instance variables are directly accessible. However, in other object-oriented programming languages (such as Java, for example), we can enforce the privacy of instance variables. That is, we can restrict them such that they can only be accessed through accessors and mutators. Nevertheless, the only way that Python supports decorators as mutators is to additionally provide decorators as accessors. It may be best to first show the source code that demonstrates this:\nclass Dog:\n    kind = \"canine\"\n    def __init__(self, name):\n        self.name = name\n        self.age = 0\n\n    # accessor\n    @property\n    def age(self):\n        \n\n    # mutator\n    @age.setter\n    def age(self, age):\n        if (age &gt;= 0 and age &lt;= 29):\n        self._age = age\n\nd1 = Dog(\"Maya\")\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age))\n\nd1.age = -5\nprint(\"I have a dog named {} that is {} year(s) \\\nold.\".format(d1.name, d1.age))\nNote that there are seemingly erroneous statements beginning with that “@” symbol (e.g., @property and @age.setter). In Python, these tags formally define decorators. The tag @property defines a decorator (or wrapper) that serves as an accessor, and the tag @age.setter defines a decorator (or wrapper) that serves as a mutator for a member called age.\nBoth the accessor and mutator are functions with the same name. In the case above, both are functions called age. Semantically, they refer to a dog’s age. Since the identifier age is now used to refer to the accessor and mutator, the instance variable that these methods wrap must be renamed. In Python, it is typical to begin instance variables with an underscore. For example, the instance variable that stores a dog’s age would be called _age.\nLet’s explain the accessor and mutator, one at a time. First, the accessor:\n@property\ndef age(self):\n    return self._age\nHere, the tag @property defines a decorator that will serve as an accessor for the instance variable that represents a dog’s age. The next statement defines the accessor itself. The function is called age (and only takes a single parameter, the object). Since the sole purpose of an accessor is to provide read access to an instance variable, then all that is required is to return its value (via the return keyword). Since the identifier age is used as the function’s name, then the instance variable has been renamed to _age as noted earlier.\nNow, the mutator:\n@age.setter\ndef age(self, age):\n    if (age &gt;= 0 and age &lt;= 29):\n        self._age = age\nHere, the tag @age.setter defines a decorator that will serve as a mutator for the instance variable that represents a dog’s age. The next statement defines the mutator itself. The function is also called age (and takes two parameters: the object and the value to change the instance variable to). Since the purpose of a mutator is to provide write access to an instance variable with input validation, it appropriately ensures that the provided value is within an acceptable range. If so, the instance variable _age is changed to reflect the provided input value.\nYou may have noticed that the decorator for the mutator, @age.setter, contains the name of the function, age. This must be adhered to when defining a decorator as a mutator. If, for instance, we wished to provide a mutator for a dog’s name, we could use the decorator tag @name.setter, call the mutator function name, and use the instance variable _name.\nNote the following statement in the constructor:\nself.age = 0\nBe careful! Here, self.age does not refer to an instance variable. It actually refers to the mutator. This assignment statement effectively calls the mutator, passing in the value on the right-hand side (0) as the second parameter of the mutator (age). That is, the value 0 is passed in to the mutator, which is then validated in the mutator. Since it is within the acceptable range (0 through 29), then the instance variable _age is set to 0.\nIt is important to note that the accessor must be defined before the mutator. Using the @property tag defines the property by name (e.g., age) so that it can be used to subsequently define the mutator (@age.setter).\nTo illustrate accessors and mutators a bit more, consider the following class that defines a 2D point (with an x- and y-coordinate):\n# points must fall within the range (-10,-10) and (10,10)\nclass Point:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    # getter for x\n    @property\n    def x(self):\n        return self._x\n\n    # setter for x\n    @x.setter\n    def x(self, value):\n        if (value &lt; -10):\n            self._x = -10\n        elif (value &gt; 10):\n            self._x = 10\n        else:\n            self._x = value\n\n    # getter for y\n    @property\n    def y(self):\n        return self._y\n\n    # setter for y\n    @y.setter\n    def y(self, value):\n        if (value &lt; -10):\n            self._y = -10\n        elif (value &gt; 10):\n            self._y = 10\n        else:\n            self._y = value\n\np1 = Point()\np2 = Point(5, 5)\np3 = Point(-50, 50)\nprint(\"p1=({},{})\".format(p1.x, p1.y))\nprint(\"p2=({},{})\".format(p2.x, p2.y))\nprint(\"p3=({},{})\".format(p3.x, p3.y))\nAlthough the class for a 2D point is a bit more involved, it only contains two instance variables. The first, _x, represents the position of the point in the x-direction. The second, _y, represents the position of the point in the y-direction. Accessors and mutators for each are provided (via the methods called x for the instance variable _x, and the methods called y for the instance variable _y). In addition, range checking is performed for both the x- and y-components. Each component may not be less than -10 or greater than 10.\nDid you notice something odd in the constructor? Here it is for reference:\ndef __init__(self, x=0, y=0):\n    self.x = x\n    self.y = y\nTake a look at the constructor’s parameters: (self, x=0, y=0). You probably expected something more like this: (self, x, y). In Python, we can provide default values for function parameters. This works for any function (not just the constructor). This means that, should parameter values be unspecified when the function is called, the default values will be used. In this example, a point’s default x- and y-values are 0 and 0 respectively. Therefore, a point at the origin could be instantiated as follows:\np = Point()\nOf course, such a point could also be instantiated as follows:\np = Point(0, 0)\nThe default values are only used if parameter values are not specified when the function is called. It is important to note that a function can have a mix of both standard and default parameters. In fact, the constructor is just like this (self is a standard parameter without a default value, while x and y have default values). In Python, all parameters with default values must be specified after standard parameters. This way, it is clear if values for default parameters are specified in a function call. For example:\ndef foo(a, b, c, d=5, e=7, f=8):\n    pass\n\n...\nfoo(1, 2, 3, 4)\nIn this case, the actual parameters 1, 2, 3, and 4 are mapped to the formal parameters a, b, c, and d. The default values for the formal parameters e and f are used.\nTo wrap up this section, let’s add line numbers to the point class above and trace the program’s execution:\n1: # points must fall within the range (-10,-10) and (10,10)\n2: class Point:\n3:      def __init__(self, x=0, y=0):\n4:          self.x = x\n5:          self.y = y\n\n6:      # getter for x\n7:      @property\n8:      def x(self):\n9:          self._x\n\n10:     # setter for x\n11:     @x.setter\n12:     def x(self, value):\n13:         if (value &lt; -10):\n14:             self._x = -10\n15:         elif (value &gt; 10):\n16:             self._x = 10\n17:         else:\n18:             self._x = value\n\n19:         # getter for y\n20:         @property\n21:         def y(self):\n22:             return self._y\n\n23:         # setter for y\n24:         @y.setter\n25:         def y(self, value):\n26:             if (value &lt; -10):\n27:                 self._y = -10\n28:             elif (value &gt; 10):\n29:                 self._y = 10\n30:             else:\n31:                 self._y = value\n\n32: p1 = Point()\n33: p2 = Point(5, 5)\n34: p3 = Point(-50, 50)\n35: print(\"p1=({},{})\".format(p1.x, p1.y))\n36: print(\"p2=({},{})\".format(p2.x, p2.y))\n37: print(\"p3=({},{})\".format(p3.x, p3.y))\n\n\n\n\n\n\n\nDid you know\n\n\n\nAlthough some object-oriented languages actually prevent accessing instance variables that are protected (or wrapped) with accessors and mutators, Python does not enforce this. For example, it is possible to change the x-component or access the y-component of a point via statements such as:\np1._x = -22\nprint(p1._y)\nMany Python programmers prefer to change the way they implement classes so that any value that requires protection is not stored in instance variables. There are other mechanisms that will, in fact, protect these values. However, this discussion is beyond the scope of this lesson.\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nActivity 2: Fractions\nIn this activity, we will create a class that represents a fraction. The first step is to determine what makes up a fraction (i.e., what it can be – its state). This task is pretty simple! Fractions have a numerator and a denominator. We can create instance variables for these and also provide accessors and mutators for each.\nWe may also want to provide the numeric representation of a fraction. For example, the fraction 1/2 has the numeric representation 0.5. In Python, simply dividing the numerator by the denominator (i.e., 1/2) won’t produce the anticipated result because it will perform integer division. That is, the expression 1/2 will result in 0 (since 2 goes into 1 exactly 0 times). To produce a floating point result, we must convert one of the two operands to a floating point value. In Python, we can do this as follows:\nfloat(1)/2\nThe expression float(1) converts the integer value 1 into the floating point value 1.0. Generally, the expression float(x) converts the operand x into a floating point value. Formally, this conversion is called a typecast, in that the operand’s type is cast to a different type.\nThe expression float(1) / 2 produces the expected result (0.5). In fact, typecasting either operand works – as shown in the example below:\n1//2\nfloat(1) / 2\n1 / float(2)\nThere are other typecast operators that perform various type conversions. Here are a few of them: int(x) – converts x to an integer long(x) – converts x to a long integer complex(x, y) – creates a complex number; x is the real part, y is the imaginary part str(x) – converts x to a string\nLastly, we must not allow the denominator of a fraction to ever be 0 (since division by 0 is mathematically illegal). Therefore, we will need to provide range checking (via if-statements, for example), to ensure that such an assignment is prevented.\nHere’s the beginning of the fraction class, along with a brief main program to test the class:\n# defines a fraction\nclass Fraction:\n    # by default, a fraction is 0/1\n    def __init__(self, num=0, den=1):\n        self.num = num\n        # make sure not to set the denominator to 0 if specified\n        if (den == 0):\n            den = 1\n        self.den = den\n    \n    # getter for the numerator\n    @property\n    def num(self):\n        return self._num\n    \n    # setter for the numerator\n    @num.setter\n    def num(self, value):\n        self._num = value\n    \n    # getter for the denominator\n    @property\n    def den(self):\n        return self._den\n    \n    # setter for the denominator\n    @den.setter\n    def den(self, value):\n    # ignore if the specified denominator is 0\n        if (value != 0):\n            self._den = value\n    \n    # returns a fraction's numeric representation\n    def getReal(self):\n        return float(self.num) / self.den\n\n# main program\nf1 = Fraction()\nf2 = Fraction(1, 2)\nf3 = Fraction(0, 0)\n\nprint(\"{}/{} ({})\".format(f1.num, f1.den, f1.getReal()))\nprint(\"{}/{} ({})\".format(f2.num, f2.den, f2.getReal()))\nprint(\"{}/{} ({})\".format(f3.num, f3.den, f3.getReal()))\nNote how the class prevents the third fraction from being initialized as 0/0 and instead changes it to 0/1.\n\n\n\n\n\n\n\n\n\n\nDid you know\n\n\n\nThere is a better way of displaying a fraction than what is shown in the example above. Note how we earlier structured a print statement that built the string representation of a fraction:\nprint(\"{}/{} ({})\".format(f1.num, f1.den, f1.getReal()))\nIn Python, we can define a built-in magic function that is automatically called when we wish to display an object. In fact, this built-in function is user-definable and is named using a similar format as the constructor (i.e., the function begins and ends with two underscores). The function is called __str__ and must return a string representation of the class. So for a fraction, such a function could be implemented as follows:\ndef __str__(self):\nreturn \"{}/{} ({})\".format(self.num, self.den, self.getReal())\nDisplaying a fraction would then be possible via the following much simpler statement (via syntactic sugar):\nprint(f1)\nAdding this function to the fraction class is simple. Here’s a snippet of the addition:\n# defines a fraction\n    class Fraction:\n    ...\n    # returns a fraction's string representation\n    def __str__(self):\n        return \"{}/{} ({})\".format(self.num, self.den,\\\n            self.getReal())\n...\n# main program\nf1 = Fraction(1, 2)\nf2 = Fraction(1, 4)\nf3 = f1.add(f2)\nprint(f1)\nprint(f2)\nprint(f3)\nOf course, the output is the same as before!\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nActivity 3: Reducing fractions You may have noticed that instantiating the fraction 6/8 would work just fine. The problem is that this fraction is not expressed in lowest terms. That is, it can be reduced (to 3/4). Our fraction class would greatly benefit from a function that can reduce a fraction. Such a function could be called in the constructor after setting the numerator and denominator in case it is not in lowest terms.\nAlthough there are many ways to reduce a fraction, here’s a simple algorithm that calculates the greatest common divisor (GCD) among the numerator and denominator. First, initially assume that the GCD is 1. From there, iterate, starting with 2 through the smaller of the numerator or denominator. Each time, the objective is to try to find a value that evenly divides both the numerator and denominator. As such a value is found, the GCD is updated. The final step is to divide the numerator and denominator by the GCD (which reduces the fraction). As a cleanup operation, if the numerator is 0 (i.e., the fraction’s numeric value is 0.0), the denominator is set to 1 (i.e., 0/1).\nThis is shown in the snippet of code below (which can be placed anywhere in the fraction class):\n# reduces a fraction\ndef reduce(self):\n    # we initially assume that the GCD is 1\n    # from there, we iterate starting at 2 through the smaller\n    # of the numerator or denominator\n    # since the numerator and denominator could be negative,\n    # we use their absolute values\n    # each time, we try to find a value that evenly divides\n    # both the numerator and denominator\n    # as we find such a value, we update the GCD\n    # the final step is two divide the numerator and\n    # denominator by the GCD to reduce the fraction\n    # as cleanup, if the numerator is 0 (i.e., the fraction is\n    # 0) then set the denominator to 1\n    gcd = 1\n    minimum = min(abs(self.num), abs(self.den))\n\n    # find common divisors\n    for i in range(2, int(minimum + 1)):\n        # when we find one, update the GCD\n        if (self.num % i == 0 and self.den % i == 0):\n            gcd = i\n    \n    # divide the numerator and denominator by the GCD\n    self.num /= gcd\n    self.den /= gcd\n    # if the numerator is 0, set the denominator to 1\n    if (self.num == 0):\n    self.den = 1\nThe Python math library has many useful functions. The min function returns the minimum value of a number of values passed in as parameters. This makes it quite easy to determine which of the numerator or denominator is smaller. Since a function’s numerator or denominator could be negative, we use their absolute value to determine which is smaller. The abs function returns the absolute value of a specified value.\nSo where (and when) do we call the reduce function? For the fraction class shown earlier, we could do so in the constructor as follows:\n# defines a fraction\nclass Fraction:\n    # by default, a fraction is 0/1\n    def __init__(self, num=0, den=1):\n        self.num = num\n        # make sure not to set the denominator to 0 if specified\n        if (den == 0):\n            den = 1\n        self.den = den\n        self.reduce()\nThis works; however, the mutators for the numerator and denominator may cause a fraction to no longer be reduced. We could, therefore, call the reduce function at the end of the mutators. There is a problem with this, however. Since the constructor uses the mutator for the numerator (in self.num = num) before the denominator is even set, a call to the function reduce in the mutator for the numerator would attempt to access the denominator (which doesn’t exist). This would result in an error.\nWe could try to place a call to the reduce function in the mutator for the denominator. But this is also problematic, because the reduce function uses the mutator for the denominator to change the denominator (i.e., when dividing it by the gcd). Placing it here would cause the reduce function to be recursively called infinitely!\nPerhaps the best place to put the call to the reduce function is in the __str__ function (i.e., when displaying a fraction).\n\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nActivity 4: Adding fractions… and more* Let’s now implement the functionality to add two fractions and produce the sum of these as a new fraction. We must first discuss how two fractions can be added. Typically, the least common denominator is found. A simpler version, however, is to multiply each fraction by the other’s denominator to obtain a common denominator (that is not necessarily the least common denominator).\nHere’s an illustration: \\[\n\\frac{a}{b}+\\frac{c}{d} = \\frac{a*b}{b*d}+\\frac{b*c}{b*d}\n\\]\nAs an example, take the following: \\[\n\\frac{1}{2}+\\frac{1}{4} = \\frac{1*4}{2*4}+\\frac{2*1}{2*4} = \\frac{4}{8}+\\frac{2}{8} = \\frac{6}{8} = \\frac{3}{4}\n\\]\nSo now, how do we implement a method in the fraction class that does this? One way is as follows:\n# calculates and returns the sum of two fractions\ndef add(self, other):\n    num = (self.num * other.den) + (other.num * self.den)\n    den = self.den * other.den\n    sum = Fraction(num, den)\n    sum.reduce()\n        return sum\nThis function is called as follows (specifically in the third statement below):\nf1 = Fraction(1, 2)\nf2 = Fraction(1, 4)\nf3 = f1.add(f2)\nNote that both fractions are effectively passed in to the add function. The first, f1, represents the current instance and is mapped to the first parameter, self. The second, f2, is mapped to the second parameter, other.\nThe function implements the common denominator method shown above and generates a fraction representing the sum of self and other. The new fraction is then reduced and returned. Note that calling the reduce function here is not necessary if it is called in the __str__ function.\nThe function could be optimized (perhaps at the expense of not being quite as readable) by returning a new fraction directly instead of creating one and returning it. For example:\nreturn Fraction(num, den)\nIn fact, the function could be optimized even more as follows:\nreturn Fraction(self.num * other.den + other.num * self.den,\\\nself.den * other.den)\nOf course, we could implement functions to subtract, multiply, and divide fractions! In fact, we could implement a subtract method by using the already defined add method. How? Recall that subtracting is just adding the negative. Since this will be assigned as a program later, it is left as an individual exercise for now.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Accessors and Mutators"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/index.html",
    "href": "lessons/02 Object Oriented Programming/index.html",
    "title": "01 More Python",
    "section": "",
    "text": "In this lesson, we will cover a variety of topics concerning Object Oriented Programming and implement object oriented programs in Python.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/index.html#overview",
    "href": "lessons/02 Object Oriented Programming/index.html#overview",
    "title": "01 More Python",
    "section": "",
    "text": "In this lesson, we will cover a variety of topics concerning Object Oriented Programming and implement object oriented programs in Python.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/index.html#contents",
    "href": "lessons/02 Object Oriented Programming/index.html#contents",
    "title": "01 More Python",
    "section": "Contents",
    "text": "Contents\n\nIntroduction\nBasic Concepts\nRepresenting State and Behavior\nInstance and Class Variables\nAccessors and Mutators\nOperator Overloading\nClass Diagrams\nInheritance\nThe Object Class\nQuick Reference",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/09 The Object Class.html",
    "href": "lessons/02 Object Oriented Programming/09 The Object Class.html",
    "title": "CSC 131",
    "section": "",
    "text": "The inheritance relationship is easily implemented in Python classes in the class header. In python 2.x, in order to define accessors and mutators, the class definition must explicitly include what you now know to be an inheritance relationship with a class called object. The inheritance from class object is implicit in Python 3.x. The class header for the dog class could have been written:\nclass Dog(object):\n    ...\nFormally, the class object is defined to be the ultimate superclass for all built-in (i.e., user-defined) types. As shown, it is possible to have multiple levels of inheritance (e.g., the class Car is a subclass of the class LandVehicle which is a subclass of the class Vehicle). At the top of this inheritance hierarchy lies the object class.\n\n\n\n\n\nFrom this class diagram, we can quickly begin laying out the source code for the classes. In fact, the class headers can be directly inferred from the class diagram:\nclass Vehicle: #implicitly inherits from class object\n    ...\nclass DodgeRam(Vehicle):\n    ...\nclass Engine: #implicitly inherits from class object\n    ...\nSince the class diagram includes the state of each class, declaring instance variables in the constructors of each class and providing appropriate accessors and mutators is also relatively straightforward. In fact, here’s the entire Vehicle class:\nclass Vehicle: #implicitly inherits from class object\n    def __init__(self, year, make, model):\n        self.year = year\n        self.make = make\n        self.model = model\n        self.engine = None\n\n    @property\n    def year(self):\n        return self._year\n\n    @year.setter\n        def year(self, value):\n        self._year = None\n        if (value &gt; 1800 and value &lt; 2018):\n            self._year = value\n    \n    @property\n    def make(self):\n        return self._make\n    \n    @make.setter\n    def make(self, value):\n        self._make = value\n    \n    @property\n    def model(self):\n        return self._model\n    \n    @model.setter\n    def model(self, value):\n        self._model = value\n    \n    @property\n    def engine(self):\n        return self._engine\n    \n    @engine.setter\n    def engine(self, value):\n        self._engine = value\n    \n    def __str__(self):\n        return \"Year: {}\\nMake: {}\\nModel: {}\\nEngine:\\\n            {}\".format(self.year, self.make, self.model,\\\n            self.engine)\nThe constructor includes parameters for a vehicle’s year, make, and model. By default, a vehicle’s engine is undefined (i.e., None). The class contains getters and setters for each of the instance variables. Finally, the __str__ function defines how to represent a vehicle as a string, which is in the following format (with an example for clarity):\nYear: 2016\nMake: Dodge\nModel: Ram\nEngine: V6\nHere is the entire Engine class:\nclass Engine: #implicitly inherits from class object\n    def __init__(self, kind=None):\n        self.kind = kind\n    \n    @property\n    def kind(self):\n        return self._kind\n    \n    @kind.setter\n    def kind(self, value):\n        self._kind = value\n    \n    def __str__(self):\n        return str(self.kind)\nThe Engine class has a single instance variable (its kind). Its constructor includes one parameter for the kind of engine (None by default). A getter and setter is provided for the instance variable. The string representation of an engine is just its kind.\nLastly, here is the DodgeRam class:\nclass DodgeRam(Vehicle):\n    make = \"Dodge\"\n    model = \"Ram\"\n\n    def __init__(self, name=None, year=None):\n        super().__init__(year, DodgeRam.make, DodgeRam.model)\n        self.name = name\n    \n    @property\n    def name(self):\n    \n        return self._name\n    @name.setter\n    def name(self, value):\n        self._name = value\n    \n    def __str__(self):\n        return \"Name: {}\\n{}\".format(self.name,\\\n            super().__str__())\nThe DodgeRam class has a single instance variable (its name). Its constructor takes two parameters (for a DodgeRam’s name and year). Note that the class contains two class variables that are shared among all instances of the class: make and model. This makes sense, because all instances of the class DodgeRam are Dodge Rams! That is, their make is Dodge, and their model is Ram.\nThere are two more interesting (and new) things in the class DodgeRam. Take a look at the first statement in the constructor:\nsuper().__init__(year, DodgeRam.make, DodgeRam.model)\nWhen implementing inheritance relationships, it often becomes useful and sometimes necessary to invoke or call functions in a subclass’ superclass. Formally, state and behavior that are defined in the superclass are inherited in a subclass. They can be redefined in the subclass; however, they don’t necessarily need to be. In fact, a subclass may inherit a function and need to implement the inherited behavior first. This is accomplished by calling the function in the superclass. Since the current object (self) is not an instance of the superclass, then invoking a function in the superclass is done by using the super() function. So the first part of the statement, super().__init__, means to call the constructor in the Vehicle class (the superclass of the DodgeRam class).\nIn this case, the year, make, and model are passed as parameters to the constructor in the Vehicle class. This effectively sets up the appropriate instance variables in the Vehicle class (which are inherited in the DodgeRam class). Subsequently, the constructor in the DodgeRam class then initializes its only instance variable, name.\nAnother new thing in the class is the statement in the __str__ function:\nreturn \"Name: {}\\n{}\".format(self.name, super().__str__())\nThe string representation of a DodgeRam is its name, followed by the string representation of a Vehicle (which was illustrated earlier). The latter part of the statement calls the __str__ function in the Vehicle class:\nsuper().__str__()\nAgain, this illustrates a call to a function in the superclass. This call returns the string representation of a vehicle – which is displayed below the name of the DodgeRam; for example:\nName: Boss Hog\nYear: 2016\nMake: Dodge\nModel: Ram\nEngine: V6\nSo the string representation of a DodgeRam is simply its name, followed by the inherited string representation of a Vehicle.\n\n\nThere are clear benefits of using inheritance in our programs. In a sense, it makes the reasoning of an application more possible since it attempts to mimic the world that we live in. But it also reduces code duplication, because similarities between objects can be encapsulated in superclasses. This has the downstream effect of promoting the reuse of code, and intrinsically makes code maintenance much easier. In fact, we often say that if software is not maintained, it dies! So we maintain software often. It behooves us to make this process easier.\nLastly, inheritance makes applications easier to extend. Think of adding a different type of vehicle (say, a HondaCivic). Without inheritance, we would have to include instance variables for year, make, model, and so on. However, these are already defined in the Vehicle class! We simply need to define the class HondaCivic as a subclass of the class Vehicle in order to inherit its state and behavior:\nclass HondaCivic(Vehicle):\n    ...\n\n\n\nThe inheritance relationship that has been discussed thus far is known as single inheritance. That is, a subclass inherits state and behavior from a single superclass. Most object-oriented programming languages support single inheritance. Often, however, there is a need to support multiple inheritance, where a subclass can inherit from more than one superclass.\nTo illustrate this, consider a grocery store’s items. A banana, for example, is a fruit. Therefore, it may inherit traits from a fruit superclass such as type, country of origin, etc. However, in the context of a grocery store, a banana is also an item for sale. Such a sale item has a price, an inventory, a shelf location, etc. Inheriting from both a Fruit superclass and a SaleItem superclass, for example, would be useful in implementing the point-of-sale system for a grocery store.\nMost object-oriented programming languages do not support multiple inheritance. Some do, but only in a limited form. Java, for example, supports it in a limited form by utilizing something known as an interface. The technical details of this are beyond the scope of this lesson. Python, however, directly supports multiple inheritance. One must merely list all of a subclass’ superclasses in the class header; for example:\nclass Banana(Fruit, SaleItem):\n    ...",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "The Object Class"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/09 The Object Class.html#the-object-class",
    "href": "lessons/02 Object Oriented Programming/09 The Object Class.html#the-object-class",
    "title": "CSC 131",
    "section": "",
    "text": "The inheritance relationship is easily implemented in Python classes in the class header. In python 2.x, in order to define accessors and mutators, the class definition must explicitly include what you now know to be an inheritance relationship with a class called object. The inheritance from class object is implicit in Python 3.x. The class header for the dog class could have been written:\nclass Dog(object):\n    ...\nFormally, the class object is defined to be the ultimate superclass for all built-in (i.e., user-defined) types. As shown, it is possible to have multiple levels of inheritance (e.g., the class Car is a subclass of the class LandVehicle which is a subclass of the class Vehicle). At the top of this inheritance hierarchy lies the object class.\n\n\n\n\n\nFrom this class diagram, we can quickly begin laying out the source code for the classes. In fact, the class headers can be directly inferred from the class diagram:\nclass Vehicle: #implicitly inherits from class object\n    ...\nclass DodgeRam(Vehicle):\n    ...\nclass Engine: #implicitly inherits from class object\n    ...\nSince the class diagram includes the state of each class, declaring instance variables in the constructors of each class and providing appropriate accessors and mutators is also relatively straightforward. In fact, here’s the entire Vehicle class:\nclass Vehicle: #implicitly inherits from class object\n    def __init__(self, year, make, model):\n        self.year = year\n        self.make = make\n        self.model = model\n        self.engine = None\n\n    @property\n    def year(self):\n        return self._year\n\n    @year.setter\n        def year(self, value):\n        self._year = None\n        if (value &gt; 1800 and value &lt; 2018):\n            self._year = value\n    \n    @property\n    def make(self):\n        return self._make\n    \n    @make.setter\n    def make(self, value):\n        self._make = value\n    \n    @property\n    def model(self):\n        return self._model\n    \n    @model.setter\n    def model(self, value):\n        self._model = value\n    \n    @property\n    def engine(self):\n        return self._engine\n    \n    @engine.setter\n    def engine(self, value):\n        self._engine = value\n    \n    def __str__(self):\n        return \"Year: {}\\nMake: {}\\nModel: {}\\nEngine:\\\n            {}\".format(self.year, self.make, self.model,\\\n            self.engine)\nThe constructor includes parameters for a vehicle’s year, make, and model. By default, a vehicle’s engine is undefined (i.e., None). The class contains getters and setters for each of the instance variables. Finally, the __str__ function defines how to represent a vehicle as a string, which is in the following format (with an example for clarity):\nYear: 2016\nMake: Dodge\nModel: Ram\nEngine: V6\nHere is the entire Engine class:\nclass Engine: #implicitly inherits from class object\n    def __init__(self, kind=None):\n        self.kind = kind\n    \n    @property\n    def kind(self):\n        return self._kind\n    \n    @kind.setter\n    def kind(self, value):\n        self._kind = value\n    \n    def __str__(self):\n        return str(self.kind)\nThe Engine class has a single instance variable (its kind). Its constructor includes one parameter for the kind of engine (None by default). A getter and setter is provided for the instance variable. The string representation of an engine is just its kind.\nLastly, here is the DodgeRam class:\nclass DodgeRam(Vehicle):\n    make = \"Dodge\"\n    model = \"Ram\"\n\n    def __init__(self, name=None, year=None):\n        super().__init__(year, DodgeRam.make, DodgeRam.model)\n        self.name = name\n    \n    @property\n    def name(self):\n    \n        return self._name\n    @name.setter\n    def name(self, value):\n        self._name = value\n    \n    def __str__(self):\n        return \"Name: {}\\n{}\".format(self.name,\\\n            super().__str__())\nThe DodgeRam class has a single instance variable (its name). Its constructor takes two parameters (for a DodgeRam’s name and year). Note that the class contains two class variables that are shared among all instances of the class: make and model. This makes sense, because all instances of the class DodgeRam are Dodge Rams! That is, their make is Dodge, and their model is Ram.\nThere are two more interesting (and new) things in the class DodgeRam. Take a look at the first statement in the constructor:\nsuper().__init__(year, DodgeRam.make, DodgeRam.model)\nWhen implementing inheritance relationships, it often becomes useful and sometimes necessary to invoke or call functions in a subclass’ superclass. Formally, state and behavior that are defined in the superclass are inherited in a subclass. They can be redefined in the subclass; however, they don’t necessarily need to be. In fact, a subclass may inherit a function and need to implement the inherited behavior first. This is accomplished by calling the function in the superclass. Since the current object (self) is not an instance of the superclass, then invoking a function in the superclass is done by using the super() function. So the first part of the statement, super().__init__, means to call the constructor in the Vehicle class (the superclass of the DodgeRam class).\nIn this case, the year, make, and model are passed as parameters to the constructor in the Vehicle class. This effectively sets up the appropriate instance variables in the Vehicle class (which are inherited in the DodgeRam class). Subsequently, the constructor in the DodgeRam class then initializes its only instance variable, name.\nAnother new thing in the class is the statement in the __str__ function:\nreturn \"Name: {}\\n{}\".format(self.name, super().__str__())\nThe string representation of a DodgeRam is its name, followed by the string representation of a Vehicle (which was illustrated earlier). The latter part of the statement calls the __str__ function in the Vehicle class:\nsuper().__str__()\nAgain, this illustrates a call to a function in the superclass. This call returns the string representation of a vehicle – which is displayed below the name of the DodgeRam; for example:\nName: Boss Hog\nYear: 2016\nMake: Dodge\nModel: Ram\nEngine: V6\nSo the string representation of a DodgeRam is simply its name, followed by the inherited string representation of a Vehicle.\n\n\nThere are clear benefits of using inheritance in our programs. In a sense, it makes the reasoning of an application more possible since it attempts to mimic the world that we live in. But it also reduces code duplication, because similarities between objects can be encapsulated in superclasses. This has the downstream effect of promoting the reuse of code, and intrinsically makes code maintenance much easier. In fact, we often say that if software is not maintained, it dies! So we maintain software often. It behooves us to make this process easier.\nLastly, inheritance makes applications easier to extend. Think of adding a different type of vehicle (say, a HondaCivic). Without inheritance, we would have to include instance variables for year, make, model, and so on. However, these are already defined in the Vehicle class! We simply need to define the class HondaCivic as a subclass of the class Vehicle in order to inherit its state and behavior:\nclass HondaCivic(Vehicle):\n    ...\n\n\n\nThe inheritance relationship that has been discussed thus far is known as single inheritance. That is, a subclass inherits state and behavior from a single superclass. Most object-oriented programming languages support single inheritance. Often, however, there is a need to support multiple inheritance, where a subclass can inherit from more than one superclass.\nTo illustrate this, consider a grocery store’s items. A banana, for example, is a fruit. Therefore, it may inherit traits from a fruit superclass such as type, country of origin, etc. However, in the context of a grocery store, a banana is also an item for sale. Such a sale item has a price, an inventory, a shelf location, etc. Inheriting from both a Fruit superclass and a SaleItem superclass, for example, would be useful in implementing the point-of-sale system for a grocery store.\nMost object-oriented programming languages do not support multiple inheritance. Some do, but only in a limited form. Java, for example, supports it in a limited form by utilizing something known as an interface. The technical details of this are beyond the scope of this lesson. Python, however, directly supports multiple inheritance. One must merely list all of a subclass’ superclasses in the class header; for example:\nclass Banana(Fruit, SaleItem):\n    ...",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "The Object Class"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/02 Basic Concepts.html",
    "href": "lessons/02 Object Oriented Programming/02 Basic Concepts.html",
    "title": "Basic Concepts",
    "section": "",
    "text": "We live in a world in which objects exist all around us. In fact, we interact with objects all the time. For example, the author of this document interacted with a keyboard and mouse while writing this sentence! The author’s brain (an object) somehow sent a message to hands and fingers (all objects) to make contact with keyboard keys (again, all objects). The keyboard (an object) somehow sent a message to the computer (an object made up of many other objects) to interpret key presses as characters to be placed in this document (an object) and displayed on the screen (yet another object).\nFundamentally, an object is a thing. In object-oriented programming, the objects model things in our problem domain. Objects have properties (or attributes) that, in a sense, define them. They capture the properties or characteristics of an object. For example, a person object has many attributes, some of which include sex, name, age, height, hair color, eye color, and so on. These are the things that a person can be.\n\n\n\n\n\n\nDefinition\n\n\n\nThe collection of attributes that make up an object are called its state.\n\n\nObjects can also do things. That is, they can have behaviors. In object-oriented programming, these behaviors are implemented by program modules (e.g., methods, procedures, functions, etc) that contain the instructions required to model the behavior in computer software. For example, a person object can eat, sleep, talk, walk, and so on.\n\n\n\n\n\n\nDefinition\n\n\n\nThe collection of actions that an object can do are called its behavior.\n\n\nCollectively, state and behavior define an object. When you begin to adopt this way of thinking, you can begin to see many things in our world as objects with attributes and behaviors interacting with other objects.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Basic Concepts"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/02 Basic Concepts.html#state-and-behavior",
    "href": "lessons/02 Object Oriented Programming/02 Basic Concepts.html#state-and-behavior",
    "title": "Basic Concepts",
    "section": "",
    "text": "We live in a world in which objects exist all around us. In fact, we interact with objects all the time. For example, the author of this document interacted with a keyboard and mouse while writing this sentence! The author’s brain (an object) somehow sent a message to hands and fingers (all objects) to make contact with keyboard keys (again, all objects). The keyboard (an object) somehow sent a message to the computer (an object made up of many other objects) to interpret key presses as characters to be placed in this document (an object) and displayed on the screen (yet another object).\nFundamentally, an object is a thing. In object-oriented programming, the objects model things in our problem domain. Objects have properties (or attributes) that, in a sense, define them. They capture the properties or characteristics of an object. For example, a person object has many attributes, some of which include sex, name, age, height, hair color, eye color, and so on. These are the things that a person can be.\n\n\n\n\n\n\nDefinition\n\n\n\nThe collection of attributes that make up an object are called its state.\n\n\nObjects can also do things. That is, they can have behaviors. In object-oriented programming, these behaviors are implemented by program modules (e.g., methods, procedures, functions, etc) that contain the instructions required to model the behavior in computer software. For example, a person object can eat, sleep, talk, walk, and so on.\n\n\n\n\n\n\nDefinition\n\n\n\nThe collection of actions that an object can do are called its behavior.\n\n\nCollectively, state and behavior define an object. When you begin to adopt this way of thinking, you can begin to see many things in our world as objects with attributes and behaviors interacting with other objects.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Basic Concepts"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/02 Basic Concepts.html#objects-classes-and-instances",
    "href": "lessons/02 Object Oriented Programming/02 Basic Concepts.html#objects-classes-and-instances",
    "title": "Basic Concepts",
    "section": "Objects, classes, and instances",
    "text": "Objects, classes, and instances\n\n\n\n\n\n\nDefinition\n\n\n\nAn object represents a specific thing from the real world with defined attributes\n\n\nFor example, “the white truck down there parked by the road” is an object. It is a truck that could ostensibly be observed on the road. In fact, it could be a white 2016 4x4 Dodge Ram 1500 with 450 miles on it.\nClearly, there exist other trucks in the world. In fact, there may even be other trucks parked by the road next to the one just described. One could say, then, that the generic term truck could represent all kinds of truck objects. Trucks are all basically different versions of the same thing. That is, they all behave the same and have the same set of attributes; however, the values of those attributes is what sets them apart. For example, one truck could be red and another white; one truck could be a Dodge and another a Toyota.\n\n\n\n\n\n\nDefinition\n\n\n\nA class represents a blueprint or template for those real world things with defined attributes (i.e., for all of the objects that can be derived).\n\n\nFor example, a truck class could be used to create many truck objects. Another way of saying this is that a class is a collection of objects that share the same attributes and behaviors. The differences between individual objects are abstracted away and ignored. So the class can be thought of as the perfect idea of something. This occurs in the real world in, for example, the way a child learns to abstract away the differences between Aunt Jamie’s schnauzer, a best friend’s bulldog, and dad’s boxer – and learns to classify them all as dogs.\nThis is not a new idea. Plato, quoting Socrates in The Republic, discusses the Theory of Forms or Ideas. For example, no one has ever seen a perfect circle; however, we have an idea of what a perfect circle should be. We have drawn many circles, but none of them were absolutely perfect. The perfect idea of a circle would be considered a class, and each of the circles we draw would be considered objects. Formally, a class defines the state and behavior of a class of objects. The fact that a truck has a color, year, make, model, mileage, and so on, is defined in the class. The fact that a truck can haul, drive, turn, honk, and so on, is also defined in the class. In fact, how a truck hauls, drives, turns, and honks is specified in the truck class as well. From the truck class, many truck instances can be created, each with potentially different attribute values making up each truck’s unique state. We say that, from this class, we can instantiate many objects.\n\n\n\n\n\n\nDefinition\n\n\n\nInstantiation is the process of creating a new instance (a.k.a. an object) of a class.\n\n\nUsually, we use the term object and instance interchangeably. That is, a truck object, for example, is just an instance of the truck class.\n\n\n\n\n\n\nActivity\n\n\n\n\n\nIn this activity, you will play a game using an animal class. This class, formally called Animal, will define what animals can be and do. Some of the students in the class will become objects of the class Animal. The animal class defines several attributes that an animal has: type: a string that represents the animal’s type (e.g., dog)\n`appetite`: an integer that represents how much daily food units the animal requires to live\n\n`stomach`: an integer that represents how much food units are currently in the animal's stomach\n\n`alive`: a Boolean that represents whether or not the animal is alive\n\n`sound`: a sound that represents the sound the animal makes\nThe class also defines several behaviors that an animal can do (and that students will perform when called upon): talk(): make the sound the animal makes\n`burn()`: use the animal's daily food units by subtracting `appetite` from `stomach`\n\n`eat(amount)`: increase the animal's `stomach` food units by the provided `amount`\n\n`getType()`: tell the requester what the animal's type is (i.e., the value of `type`)\n\n`isAlive()`: tell the requester if the animal is alive or not (i.e., the value of `alive`)\nNote that if stomach is less than 0, then alive becomes false – and the animal dies…",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Basic Concepts"
    ]
  },
  {
    "objectID": "programs/06/instructions.html",
    "href": "programs/06/instructions.html",
    "title": "Program: Sale Item",
    "section": "",
    "text": "Your task in this assignment is to write python code that would implement a simple Height class that could potentially be used as a small part of a much larger application. To allow for its use with other systems, the specifications for the Height class are defined below."
  },
  {
    "objectID": "programs/06/instructions.html#overview",
    "href": "programs/06/instructions.html#overview",
    "title": "Program: Sale Item",
    "section": "",
    "text": "Your task in this assignment is to write python code that would implement a simple Height class that could potentially be used as a small part of a much larger application. To allow for its use with other systems, the specifications for the Height class are defined below."
  },
  {
    "objectID": "programs/06/instructions.html#the-height-class-specifications",
    "href": "programs/06/instructions.html#the-height-class-specifications",
    "title": "Program: Sale Item",
    "section": "The Height Class Specifications",
    "text": "The Height Class Specifications\n\nThe class should be called Height and should be implemented in a file called height.py\nThe constructor takes two arguments: the first for the feet element and the second for the inch element of any Height object. This constructor uses default values of 0 for both feet and inch elements if they are not provided. The constructor is responsible for setting an instance variable called inchs and an instance variable called feet.\nThe class should have accessors and mutators for all instance variables which use the decorator method discussed in class. Additionally:\n\nThe ft and inch mutators should not allow for those variables to be set to negative values. If that is attempted,the program should raise a ValueError.\nThe inch instance variable should never be allowed to be a value larger than or equal to 12. If that is attempted, the inch mutator should update the feet and inch value accordingly. For example, creating a Height object with 1ft and 26 inches should result in a height object with 3 ft and 2 inches. Modifying an object that is already 1 ft and 2 inches by setting the instance variable to 16, should result in the object being 2 ft and 4 inches.\n\nThe class should have a method called to_inches that returns the total number of inches that the height object is worth as an integer.\nThe class should have a method called to_feet that returns the total number of feet that the height object is worth as a float.\nThe class should have a method called to_centimeters that returns the total number of centimeters that the height object is worth as a float.\nThe class should also contain a __str__ method that determines how Height objects are represented when printed. Example: 3’2” for an object with 3 ft and 2 inch. Note there are no spaces in the string representation of a height object.\nThe class should also overload some mathematical and comparison operators i.e. defines what those operators mean in the context of Height objects. The operators in question to include are +, - , &gt;, &gt;=, &lt;=, &lt;, ==, and !=.\nFeel free to add any other functions that you feel will help to make your class more efficient and/ or cleaner, just be sure they do not conflict with the autograder or cause errors."
  },
  {
    "objectID": "programs/06/instructions.html#tests",
    "href": "programs/06/instructions.html#tests",
    "title": "Program: Sale Item",
    "section": "Tests",
    "text": "Tests\nThe Height class will be subject to the following tests. Some examples are provided for you to test your code locally.\n\nThe ability to instantiate a Height object. That is, your constructor accepts the appropriate arguments and runs without error.\n# instantiating a height of x feet and y inches would not result in any errors\nh1 = Height(1, 2)   # here we used 1ft and 2in\n\n# instantiating a height where no feet or inches are specified\nh2 = Height()       # by default, it should set feet and inches to 0\nThe existance of the feet instance variable after instantiation.\nh1 = Height(1, 2)\nprint(h1.feet)      # no errors thrown\n\nh2 = Height()\nprint(h2.feet)      # no errors thrown\nThe existance of the inches instance variable after instantiation.\nh1 = Height(1, 2)\nprint(h1.inches)      # no errors\n\nh2 = Height()\nprint(h2.inches)      # no errors\nThe feet instance variable is correct after instantiation.\nh1 = Height(1, 2)\nprint(h1.feet)      # outputs a value of 1\n\nh2 = Height()\nprint(h2.feet)      # outputs a value of 0\nThe inches instance variable is correct after instantiation.\nh1 = Height(1, 2)\nprint(h1.inches)      # outputs a value of 2\n\nh2 = Height()\nprint(h2.inches)      # outputs a value of 0\nThe feet instance variable cannot be set to a negative value.\nh1 = Height()\nh1.feet = -10       # this should raise a ValueError\nThe inches instance variable cannot be set to a negative value.\nh1 = Height()\nh1.inches = -1000   # this should raise a ValueError\nThe inches setter overflows into the feet instance variable appropriately.\nh1 = Height()\nh1.inches = 27\nprint(h1.feet)      # outputs 2\nprint(h1.inches)    # outputs 3\nThe to_inch function does not throw any errors when run.\nThe to_inch function returns the correct value. An example of using the profit function follows:\nh1 = Height(2, 3)\nprint(h1.to_inches())   # outputs 27\nThe to_feet function does not throw any errors when run.\nThe to_feet returns the correct value. Accuracy will be checked within 4 decimal places. Do not apply rounding.\nh1 = Height(2, 3)\nprint(h1.to_feet())   # outputs 2.25\nThe to_centimeters function does not throw any errors when run.\nThe to_centimeters returns the correct value. Accuracy will be checked within 4 decimal places. Do not apply rounding.\nh1 = Height(2, 3)\nprint(h1.to_centimeters())   # outputs 68.58\nThe __str__ method returns the appropriate string (must be an exact match).\nh1 = Height(2, 3)\nprint(h1)       # outputs 2'3\"  \nIndividual tests for each of the following operators: +, - , &gt;, &gt;=, &lt;=, &lt;, ==, and !=. In the case of subtraction, if the subtraction would result in a negative value, catch the ValueError that you programmed by using a try...except... and return a Height object with a height of 0 feet and 0 inches.\nh1 = Height(1, 10)\nh2 = Height(1, 3)\nh3 = Height(1, 10)\n\n# Addition\nh4 = h1 + h2\nprint(h3)       # outputs 3'1\"\n\n# Subtraction\nh4 = h1 - h2\nprint(h3)       # outputs 0'7\"\n\nh4 = h2 - h1    # catch the value error in the __sub__ function\nprint(h3)       # outputs 0'0\"\n\n# Equal To\nprint(h1 == h2) # outputs False\nprint(h1 == h3) # outputs True\n\n# Not Equal To\nprint(h1 != h2) # outputs True\nprint(h1 != h3) # outputs False\n\n# Greater Than\nprint(h1 &gt; h2)  # outputs True\nprint(h2 &gt; h1)  # outputs False\nprint(h1 &gt; h3)  # outputs False\n\n# Greater Than or Equal To\nprint(h1 &gt;= h2)  # outputs True\nprint(h2 &gt;= h1)  # outputs False\nprint(h1 &gt;= h3)  # outputs True\n\n# Less Than\nprint(h1 &lt; h2)  # outputs False\nprint(h2 &lt; h1)  # outputs True\nprint(h1 &lt; h3)  # outputs False\n\n# Less Than or Equal To\nprint(h1 &lt;= h2) # outputs False\nprint(h2 &lt;= h1) # outputs True\nprint(h1 &lt;= h3) # outputs True"
  },
  {
    "objectID": "programs/06/instructions.html#additional-files",
    "href": "programs/06/instructions.html#additional-files",
    "title": "Program: Sale Item",
    "section": "Additional Files",
    "text": "Additional Files\nYou are provided with a template that you should use. Note that the template contains a main section with some code already inside of it. Use the main portion of the code and the examples above to test your solution before submitting to the auto-grader.\ntemplate.py"
  },
  {
    "objectID": "programs/06/instructions.html#submission",
    "href": "programs/06/instructions.html#submission",
    "title": "Program: Sale Item",
    "section": "Submission",
    "text": "Submission\nYou must submit your code to the course website as a single .py file."
  },
  {
    "objectID": "programs/07/instructions.html",
    "href": "programs/07/instructions.html",
    "title": "Program: Sale Item",
    "section": "",
    "text": "Your task in this assignment is to write python code that would implement a simple Height class that could potentially be used as a small part of a much larger application. To allow for its use with other systems, the specifications for the Height class are defined below."
  },
  {
    "objectID": "programs/07/instructions.html#overview",
    "href": "programs/07/instructions.html#overview",
    "title": "Program: Sale Item",
    "section": "",
    "text": "Your task in this assignment is to write python code that would implement a simple Height class that could potentially be used as a small part of a much larger application. To allow for its use with other systems, the specifications for the Height class are defined below."
  },
  {
    "objectID": "programs/07/instructions.html#the-height-class-specifications",
    "href": "programs/07/instructions.html#the-height-class-specifications",
    "title": "Program: Sale Item",
    "section": "The Height Class Specifications",
    "text": "The Height Class Specifications\n\nThe class should be called Height and should be implemented in a file called height.py\nThe constructor takes two arguments: the first for the feet element and the second for the inch element of any Height object. This constructor uses default values of 0 for both feet and inch elements if they are not provided. The constructor is responsible for setting an instance variable called inchs and an instance variable called feet.\nThe class should have accessors and mutators for all instance variables which use the decorator method discussed in class. Additionally:\n\nThe ft and inch mutators should not allow for those variables to be set to negative values. If that is attempted,the program should raise a ValueError.\nThe inch instance variable should never be allowed to be a value larger than or equal to 12. If that is attempted, the inch mutator should update the feet and inch value accordingly. For example, creating a Height object with 1ft and 26 inches should result in a height object with 3 ft and 2 inches. Modifying an object that is already 1 ft and 2 inches by setting the instance variable to 16, should result in the object being 2 ft and 4 inches.\n\nThe class should have a method called to_inches that returns the total number of inches that the height object is worth as an integer.\nThe class should have a method called to_feet that returns the total number of feet that the height object is worth as a float.\nThe class should have a method called to_centimeters that returns the total number of centimeters that the height object is worth as a float.\nThe class should also contain a __str__ method that determines how Height objects are represented when printed. Example: 3’2” for an object with 3 ft and 2 inch. Note there are no spaces in the string representation of a height object.\nThe class should also overload some mathematical and comparison operators i.e. defines what those operators mean in the context of Height objects. The operators in question to include are +, - , &gt;, &gt;=, &lt;=, &lt;, ==, and !=.\nFeel free to add any other functions that you feel will help to make your class more efficient and/ or cleaner, just be sure they do not conflict with the autograder or cause errors."
  },
  {
    "objectID": "programs/07/instructions.html#tests",
    "href": "programs/07/instructions.html#tests",
    "title": "Program: Sale Item",
    "section": "Tests",
    "text": "Tests\nThe Height class will be subject to the following tests. Some examples are provided for you to test your code locally.\n\nThe ability to instantiate a Height object. That is, your constructor accepts the appropriate arguments and runs without error.\n# instantiating a height of x feet and y inches would not result in any errors\nh1 = Height(1, 2)   # here we used 1ft and 2in\n\n# instantiating a height where no feet or inches are specified\nh2 = Height()       # by default, it should set feet and inches to 0\nThe existance of the feet instance variable after instantiation.\nh1 = Height(1, 2)\nprint(h1.feet)      # no errors thrown\n\nh2 = Height()\nprint(h2.feet)      # no errors thrown\nThe existance of the inches instance variable after instantiation.\nh1 = Height(1, 2)\nprint(h1.inches)      # no errors\n\nh2 = Height()\nprint(h2.inches)      # no errors\nThe feet instance variable is correct after instantiation.\nh1 = Height(1, 2)\nprint(h1.feet)      # outputs a value of 1\n\nh2 = Height()\nprint(h2.feet)      # outputs a value of 0\nThe inches instance variable is correct after instantiation.\nh1 = Height(1, 2)\nprint(h1.inches)      # outputs a value of 2\n\nh2 = Height()\nprint(h2.inches)      # outputs a value of 0\nThe feet instance variable cannot be set to a negative value.\nh1 = Height()\nh1.feet = -10       # this should raise a ValueError\nThe inches instance variable cannot be set to a negative value.\nh1 = Height()\nh1.inches = -1000   # this should raise a ValueError\nThe inches setter overflows into the feet instance variable appropriately.\nh1 = Height()\nh1.inches = 27\nprint(h1.feet)      # outputs 2\nprint(h1.inches)    # outputs 3\nThe to_inch function does not throw any errors when run.\nThe to_inch function returns the correct value. An example of using the profit function follows:\nh1 = Height(2, 3)\nprint(h1.to_inches())   # outputs 27\nThe to_feet function does not throw any errors when run.\nThe to_feet returns the correct value. Accuracy will be checked within 4 decimal places. Do not apply rounding.\nh1 = Height(2, 3)\nprint(h1.to_feet())   # outputs 2.25\nThe to_centimeters function does not throw any errors when run.\nThe to_centimeters returns the correct value. Accuracy will be checked within 4 decimal places. Do not apply rounding.\nh1 = Height(2, 3)\nprint(h1.to_centimeters())   # outputs 68.58\nThe __str__ method returns the appropriate string (must be an exact match).\nh1 = Height(2, 3)\nprint(h1)       # outputs 2'3\"  \nIndividual tests for each of the following operators: +, - , &gt;, &gt;=, &lt;=, &lt;, ==, and !=. In the case of subtraction, if the subtraction would result in a negative value, catch the ValueError that you programmed by using a try...except... and return a Height object with a height of 0 feet and 0 inches.\nh1 = Height(1, 10)\nh2 = Height(1, 3)\nh3 = Height(1, 10)\n\n# Addition\nh4 = h1 + h2\nprint(h3)       # outputs 3'1\"\n\n# Subtraction\nh4 = h1 - h2\nprint(h3)       # outputs 0'7\"\n\nh4 = h2 - h1    # catch the value error in the __sub__ function\nprint(h3)       # outputs 0'0\"\n\n# Equal To\nprint(h1 == h2) # outputs False\nprint(h1 == h3) # outputs True\n\n# Not Equal To\nprint(h1 != h2) # outputs True\nprint(h1 != h3) # outputs False\n\n# Greater Than\nprint(h1 &gt; h2)  # outputs True\nprint(h2 &gt; h1)  # outputs False\nprint(h1 &gt; h3)  # outputs False\n\n# Greater Than or Equal To\nprint(h1 &gt;= h2)  # outputs True\nprint(h2 &gt;= h1)  # outputs False\nprint(h1 &gt;= h3)  # outputs True\n\n# Less Than\nprint(h1 &lt; h2)  # outputs False\nprint(h2 &lt; h1)  # outputs True\nprint(h1 &lt; h3)  # outputs False\n\n# Less Than or Equal To\nprint(h1 &lt;= h2) # outputs False\nprint(h2 &lt;= h1) # outputs True\nprint(h1 &lt;= h3) # outputs True"
  },
  {
    "objectID": "programs/07/instructions.html#additional-files",
    "href": "programs/07/instructions.html#additional-files",
    "title": "Program: Sale Item",
    "section": "Additional Files",
    "text": "Additional Files\nYou are provided with a template that you should use. Note that the template contains a main section with some code already inside of it. Use the main portion of the code and the examples above to test your solution before submitting to the auto-grader.\ntemplate.py"
  },
  {
    "objectID": "programs/07/instructions.html#submission",
    "href": "programs/07/instructions.html#submission",
    "title": "Program: Sale Item",
    "section": "Submission",
    "text": "Submission\nYou must submit your code to the course website as a single .py file."
  },
  {
    "objectID": "programs/05/instructions.html",
    "href": "programs/05/instructions.html",
    "title": "Class Diagram Example",
    "section": "",
    "text": "Your task in this assignment is to extend your submission for the SaleItem class to include some inheritance as shown in the diagram below.",
    "crumbs": [
      "Programs",
      "Program 5"
    ]
  },
  {
    "objectID": "programs/05/instructions.html#overview",
    "href": "programs/05/instructions.html#overview",
    "title": "Class Diagram Example",
    "section": "",
    "text": "Your task in this assignment is to extend your submission for the SaleItem class to include some inheritance as shown in the diagram below.",
    "crumbs": [
      "Programs",
      "Program 5"
    ]
  },
  {
    "objectID": "programs/05/instructions.html#class-diagram",
    "href": "programs/05/instructions.html#class-diagram",
    "title": "Class Diagram Example",
    "section": "Class Diagram",
    "text": "Class Diagram\n\n\n\n\n\n\nclassDiagram\n    class SaleItem {\n        + name: str\n        + cost: float\n        + price: float\n        + profit(): str\n        + apply_sale(value: float): None\n        + __str__(): str\n    }\n\n    class Clothing {\n        + brand: str\n        + size: str\n        + __str__(): str\n    }\n\n\n    class Food {\n        + shelf_life: int\n        + __str__(): str\n    }\n\n    class Shoe {\n\n    }\n\n    class Chip {\n\n    }\n\n    SaleItem &lt;|-- Clothing\n    SaleItem &lt;|-- Food\n    Clothing &lt;|-- Shoe\n    Food &lt;|-- Chip",
    "crumbs": [
      "Programs",
      "Program 5"
    ]
  },
  {
    "objectID": "programs/05/instructions.html#class-descriptions",
    "href": "programs/05/instructions.html#class-descriptions",
    "title": "Class Diagram Example",
    "section": "Class Descriptions",
    "text": "Class Descriptions\nA description of each class follows.\n\nSaleItem Recap\n\nThe SaleItem class has a name, cost, and price.\nAll three instance variables are provided as arguments to the constructor.\nThe class should have accessors and mutators for all instance variables which use the decorator method discussed in class. Additionally, the cost and price mutators should not allow for those variables to be set to negative values. If that is attempted, they are set to 0 instead.\nThe class should have a profit function that returns the amount of money that selling the item would provide (i.e. the difference between the price and the cost).\nThe class should have an apply_sale function that applies a percentage sale to the price of the item. It receives the percentage value as an argument and adjusts the price appropriately.\nAn extra function __str__() is included which returns f\"{self.name}\\t{self.cost:.2f}\\t{self.price:.2f}.\n\n\n\nThe Clothing Class\n\nThe Clothing class inherits from the SaleItem class. This class refers to a clothing item in the store.\nIt has a brand instance variable to denote the brand of the item (i.e. Nike, Adidas, etc.).\nIt has a size instance variable to denote the size of the item being sold.\nIt has a constructor that receives the name, brand, cost, price, and size as arguments (in that order).\nIt contains appropriate accessors and mutators for the brand and size variables. The mutator for size ensures that it is set to the python None type if a value outside of \"Small\" \"Medium\" or \"Large\" is attempted.\nIt contains a __str__ function that prints out the string representation of a SaleItem followed by the brand and size. An example of a complete returned value is\nShirt   29.99   49.99   Gymshark        Medium\nwhere the spacing is determined exclusively by a single tab between each instance variable.\n\n\n\nThe Food Class\n\nThe Food class inherits from the SaleItem class. This class refers to a Food item in the store.\nIt has a constructor that receives the name, cost, and price as arguments (in that order).\nIt has a shelf_life instance variable that represents the shelf life of a product in days. It is set to 7 by default.\nThe shelf_life instance variable should have an accessor and mutator. The mutator should prevent the shelf_life from being set to a negative value. In the case of a negative value being attempted, it should set the value to 0.\nIt has a __str__ function that returns the string representation of a SaleItem followed by the shelf life. An example of a complete returned value is\nSoup    0.50    1.50    7\nwhere the spacing is determined by a single tab character between each item.\n\n\n\nThe Shoe Class\n\nThe Shoe class inherits from the Clothing class. This class refers specifically to shoes that the store sells.\nIt has a constructor that receives cost, price, and size as arguments (in that order) and sets all Shoe items to have name of \"Crocs\" and a brand of \"Nike\".\n\n\n\nThe Chip Class\n\nThe Chip class inherits from the Food class. This class refers to the potato chips that the store sells.\nIt has a constructor that does not receive any arguments. The constructor sets the name of all Chip instances to \"Original\", the brand to \"Lays\", the cost to 2, the price to 3.50, and the shelf_life to 21.",
    "crumbs": [
      "Programs",
      "Program 5"
    ]
  },
  {
    "objectID": "programs/05/instructions.html#tests",
    "href": "programs/05/instructions.html#tests",
    "title": "Class Diagram Example",
    "section": "Tests",
    "text": "Tests\n\nThe SaleItem Class\nThe SaleItem class will be subject to the following tests. Some examples are provided for you to test your code locally.\n\nThe ability to instantiate a SaleItem object. That is, your constructor accepts the appropriate arguments and runs without error. Additionally, the instance variables that should exist will exist after instantiation.\norange = SaleItem(\"Orange\", 0.50, 1.50) # runs successfully\n\n# running the following three lines will not cause errors.\norange.name\norange.cost\norange.price\nThe existence of accessors/getters and mutators/setters for each instance variable of SaleItem.\n# Run the following lines in your main portion of the code.\n# If any of them throw errors, then you don't have an accessor/getter for the corresponding instance variable\nSaleItem.name.fget\nSaleItem.cost.fget\nSaleItem.price.fget\n\n# If any of these following lines throw errors, then you don't have a mutator/setter for the corresponding instance variable.\nSaleItem.name.fset\nSaleItem.cost.fset\nSaleItem.price.fset\nThe accuracy of instance variables assigned in the SaleItem constructor.\norange = SaleItem(\"Orange\", 0.50, 1.50) \n\nprint(orange.name)      # outputs \"Orange\"\nprint(orange.cost)      # outputs 0.5\nprint(orange.price)     # outputs 1.5\nThe accuracy of the cost and price instance variables along with whether or not the setters throw errors. That is, they cannot be set to a invalid values but can be set to valid values.\n# test for outside of constructor\norange = SaleItem(\"Orange\", 0.50, 1.50) \norange.cost = -10\norange.price = -100\nprint(orange.cost)      # outputs 0\nprint(orange.price)     # outputs 0\n\n# test for within constructor\napple = SaleItem(\"Apple\", -0.50, -1.50)\nprint(apple.cost)      # outputs 0\nprint(apple.price)     # outputs 0\nThe profit function returns the correct value.\norange = SaleItem(\"Orange\", 0.5, 1.5)\nprint(orange.profit())      # outputs 1.0\nThe apply_sale function returns the correct value.\norange = SaleItem(\"Orange\", 0.5, 100.00)\norange.apply_sale(10)   # a 10 percent discount is applied to the price\nprint(orange.price)     # outputs 90, not 100\nThe __str__ function returns the correctly formatted string.\norange = SaleItem(\"Orange\", 0.5555555555, 1.777777777)\nprint(orange)   # outputs the following line without the # symbol. The spacing is determined by tabs.\n#Orange  0.56    1.78\n\n\n\nThe Clothing Class\n\nThe Clothing class is a subclass of the SaleItem class.\nprint(issubclass(Clothing, SaleItem))  # outputs True\nThe constructor runs and does not cause any errors, the constructor calls on the constructor of the super class, and the constructor properly sets up instance variables for brand and size. Note that name, cost, and price are handled by the constructor of the super class.\n# no errors when running the following line\nshirt = Clothing(\"Shirt\", \"Gymshark\", 29.99, 49.99, \"Medium\")\n\n# none of the following should cause errors.\nprint(shirt.name)       # outputs \"Shirt\"\nprint(shirt.brand)      # outputs \"Gymshark\"\nprint(shirt.cost)       # outputs 29.99\nprint(shirt.price)      # outputs 49.99\nprint(shirt.size)       # outputs \"Medium\"\nThe existence of getters and setters for each instance variable (using the property decorator discussed in class).\n# Call each of the following. If one of them throws an error, then you don't have a getter for that one.\nClothing.brand.fget\nClothing.size.fget\n\n# Call each of the following. If one of them throws an error, then you don't have a setter for that one.\nClothing.brand.fset\nClothing.size.fset\nThe size instance variable only allows the values Small, Medium, and Large. In the case the size is not one of those, it should set the value to None.\n# no errors when running the following line\nshirt = Clothing(\"Shirt\", \"Gymshark\", 29.99, 49.99, \"Medium\")\n\nshirt.size = \"Large\"\nprint(shirt.size)   # outputs \"Large\"\n\nshirt.size = \"Small\"\nprint(shirt.size)   # outputs \"Small\"\n\nshirt.size = \"Krusty Krab\"\nprint(shirt.size)   # outputs None  (not a string, but the python None type)\nThe __str__ method of the Clothing class calls the __str__ method of its super class. Additionally, the string method should return the proper string.\n# this isn't ideal, but to check we will just be checking the contents of the source code\n# this will be done using the inspect module\nimport inspect\n\n# get the contents of the __str__ method\nsrc = inspect.getsource(Clothing.__str__)\n\n# one of the following two prints should print True\nprint(\"super().__str__\" in src)\nprint(\"SaleItem.__str__\" in src)\n\n# This isn't ideal since you can simply include either of those strings anywhere \n# in the source code of your function and it would pass this test. Our hope is you put one of them\n# in the appropriate place.\n\n# instantiate a shirt to test the output\nshirt = Clothing(\"Shirt\", \"Gymshark\", 29.99, 49.99, \"Medium\")\nprint(shirt) # outputs the following line without the # symbol. The spacing is determined by tabs.\n#Shirt   29.99   49.99   Gymshark        Medium\n\n\n\nThe Food Class\n\nThe Food class is a subclass of the SaleItem class.\nprint(issubclass(Food, SaleItem))  # outputs True\nThe constructor runs and does not cause any errors, the constructor calls on the constructor of the super class, and the constructor properly sets the instance variable for shelf_life. Note that name, cost, and price are handled by the constructor of the super class and should also be properly setup. Additionally, shelf_life should be 7 at this point.\n# no errors occur when the following line is executed.\nsoup = Food(\"Soup\", 0.5, 1.50)\n\n# none of the following should cause errors.\nprint(soup.name)            # outputs \"Soup\"\nprint(soup.cost)            # outputs 29.99\nprint(soup.price)           # outputs 49.99\nprint(soup.shelf_life)      # outputs 7\n\nprint(soup.shelf_life == 7) # outputs True\nThe ‘shelf_life’ instance variable has getters and setters.\n# Call each of the following. \nFood.shelf_life.fset    # if this line throws an error, you don't have a setter\nFood.shelf_life.fget    # if this line throws an error, you don't have a getter\nThe shelf_life mutator/setter prevents negative values by setting the variable to 0.\nsoup = Food(\"Soup\", 0.5, 1.50)\nsoup.shelf_life = -10\nprint(soup.shelf_life)  # outputs 0\nThe __str__ function calls the super class’s __str__ function and the __str__ method returns the correct string. Note that all spacing is determined by single tabs. Don’t count the spacing, just use \\t.\n# again, this isn't ideal, but to check we will just be checking the contents of the source code\n# this will be done using the inspect module\nimport inspect\n\n# get the contents of the __str__ method\nsrc = inspect.getsource(Food.__str__)\n\n# one of the following two calls to the print() function should print True\nprint(\"super().__str__\" in src)\nprint(\"SaleItem.__str__\" in src)\n\n# This isn't ideal since you can simply include either of those strings anywhere \n# in the source code of your function and it would pass this test. Our hope is you put one of them\n# in the appropriate place.\n\n\n# checking if it returns the correct string\nsoup = Food(\"Soup\", 0.5, 1.50)\nprint(soup)   # outputs the following line without the # symbol. The spacing is determined by tabs.\n#Soup    0.50    1.50    7\n\n\n\nThe Shoe Class\n\nThe Shoe class is a subclass of the Clothing class.\nprint(issubclass(Shoe, Clothing))  # outputs True\nThe constructor runs and does not cause any errors.\n# no errors occur when the following line is executed.\ncroc = Shoe(29.99, 229.99, \"Medium\")\n\n# the following lines don't cause errors\nprint(croc.name)    # outputs \"Crocs\"\nprint(croc.brand)   # outputs \"Nike\"\n\n\n\nThe Chip Class\n\nThe Chip class is a subclass of the Food class.\nprint(issubclass(Shoe, Food))  # outputs True\nThe constructor runs and does not cause any errors. Additionally, the values of the instance variables should be correct after running the constructor.\n# no errors occur when the following line is executed.\npotato = Chip()\n\n# no errors occur on the following\nprint(potato.name)          # outputs \"Original\"\nprint(potato.cost)          # outputs 2\nprint(potato.price)         # outputs 3.5\nprint(potato.shelf_life)    # outputs 21",
    "crumbs": [
      "Programs",
      "Program 5"
    ]
  },
  {
    "objectID": "programs/05/instructions.html#additional-files",
    "href": "programs/05/instructions.html#additional-files",
    "title": "Class Diagram Example",
    "section": "Additional Files",
    "text": "Additional Files\nYou are provided with a template that you should use. Note that the template contains a main section for you to use with the the examples above to test the various parts of your solution before submitting to the auto-grader.\ntemplate.py",
    "crumbs": [
      "Programs",
      "Program 5"
    ]
  },
  {
    "objectID": "programs/05/instructions.html#submission",
    "href": "programs/05/instructions.html#submission",
    "title": "Class Diagram Example",
    "section": "Submission",
    "text": "Submission\nYou must submit your code to the course website as a single .py file.",
    "crumbs": [
      "Programs",
      "Program 5"
    ]
  },
  {
    "objectID": "programs/03/instructions.html",
    "href": "programs/03/instructions.html",
    "title": "Program: Sale Item",
    "section": "",
    "text": "Your task in this assignment is to write python code that would implement a simple SaleItem class that could potentially be used as a small part of a much larger application. To allow for its use with other systems, the specifications for the SaleItem class are defined below.",
    "crumbs": [
      "Programs",
      "Program 3"
    ]
  },
  {
    "objectID": "programs/03/instructions.html#overview",
    "href": "programs/03/instructions.html#overview",
    "title": "Program: Sale Item",
    "section": "",
    "text": "Your task in this assignment is to write python code that would implement a simple SaleItem class that could potentially be used as a small part of a much larger application. To allow for its use with other systems, the specifications for the SaleItem class are defined below.",
    "crumbs": [
      "Programs",
      "Program 3"
    ]
  },
  {
    "objectID": "programs/03/instructions.html#the-saleitem-class-specifications",
    "href": "programs/03/instructions.html#the-saleitem-class-specifications",
    "title": "Program: Sale Item",
    "section": "The SaleItem Class Specifications",
    "text": "The SaleItem Class Specifications\n\nThe SaleItem class has a name, cost and price as instance variables. The name instance variable represents the name of the item, cost represents the cost for the store, and price is the price the customer pays.\nAll three instance variables are also provided as arguments to the constructor in the order indicated (name, then cost, then price).\nThe class should have accessors and mutators for all instance variables which use the decorator method discussed in class. Additionally, the cost and price mutators should not allow for those variables to be set to negative values. If that is attempted, they are set to 0 instead.\nThe class should have a profit function that returns the amount of money (as a float) that selling the item would provide (i.e. the difference between the price and the cost).\nThe class should have an apply_sale function that applies a percentage sale to the price of the item. It receives the percentage value as an argument and adjusts the price appropriately. Note that this function does not return anything.\nThe class should have a __str__ method that is responsible for return a string respresentation of a SaleItem object. The representation should contain the name, cost, and price in that order, each separated by 1 single tab character. Additionally, the cost and price should be represented with 2 digits after the decimal point.",
    "crumbs": [
      "Programs",
      "Program 3"
    ]
  },
  {
    "objectID": "programs/03/instructions.html#tests",
    "href": "programs/03/instructions.html#tests",
    "title": "Program: Sale Item",
    "section": "Tests",
    "text": "Tests\nThe SaleItem class will be subject to the following tests. Some examples are provided for you to test your code locally.\n\nThe ability to instantiate an instance of the SaleItem class. That is, your constructor accepts the appropriate arguments and runs without error and the appropriate instance variables exist and are valid.\n# instantiating a banana would not result in any errors\nbanana = SaleItem(\"banana\", 1, 2)\n\n# testing existence\nprint(banana.name)          # no error is thrown when trying to access banana.name\nprint(banana.cost)          # no error is thrown when accessing banana.price\nprint(banana.price)         # no error is thrown when accessing banana.cost\n\n# testing accuracy\nprint(banana.name == \"banana\")  # this should print True\nprint(banana.cost == 1)         # this should print True\nprint(banana.price == 2)        # this should print True\n\nprint(banana.name == \"apple\")   # this should print False\nprint(banana.cost == 20)        # this should print False\nprint(banana.price == 40)       # this should print False\nThree tests for the existence of the accessors/getters and mutators/setters for each instance variable. You shouldn’t need to run any of the following as you should already know whether or not you’re implementing the decorators correctly for your getters and setters, however, if you’re curious, check out the following block.\n# Run the following lines in your __main__ portion of the code.\n# If any of them throw errors, then you don't have an accessor/getter for the corresponding instance variable\nSaleItem.name.fget\nSaleItem.cost.fget\nSaleItem.price.fget\n\n# If any of these following lines throw errors, then you don't have a mutator/setter for the corresponding instance variable.\nSaleItem.name.fset\nSaleItem.cost.fset\nSaleItem.price.fset\nThis test checks that your instance variables can be set to valid values outside of the class, checks the accuracy of those valid values, attempt to set invalid values to the price and cost variables outside of the class, checks that invalid values are handled properly (by being set to 0), then checks if the constructor is also preventing invalid values from being set (whether through a call to the setter or through logic within the constructor). Some example code to run to check if your code is functioning properly concerning a Bluth Banana is included below.\n# instantiation of the banana\nbanana = SaleItem(\"banana\", 1, 2)\n\n# can set name, price, and cost to valid values without error\nbanana.name = \"Bluth Banana\"\nbanana.price = 10.00  # set price to 10.00\nbanana.cost = 0.50  # set cost to 0.5\n\n# testing to see the values\nprint(banana.name == \"Bluth Banana\")    # True\nprint(banana.price == 10.00)              # True\nprint(banana.cost == 0.50)              # True\n\n\n# Try setting some invalid values for cost and price\nbanana.price = -10000   # set price to a negative value\nbanana.cost = -20000    # set cost to a negative value\n\n# check the values\nprint(banana.price == 0) # True\nprint(banana.cost == 0)  # True\n\n\n# instantiation a sale item with invalid price and cost\nbanana = SaleItem(\"banana\", -100, -200)\n\n# check the values\nprint(banana.price == 0) # True\nprint(banana.cost == 0)  # True\nThe profit function does not throw any errors when run and returns the correct value. Note that the value will be checked to an accuracy of 2 decimal places, but you do not need to round.\n# instantiation of the banana\nbanana = SaleItem(\"banana\", 1, 100)\n\n# applying the sale\nprint(banana.profit())  # outputs 99.\nThe apply_sale function does not throw any errors when run and the consumer price is modified appropriately.\n# instantiation of the banana\nbanana = SaleItem(\"banana\", 1, 100)\n\n# applying the sale\nbanana.apply_sale(10)   # a 10 percent discount is applied to the price\n\n# checking the value of the price\nprint(banana.price)     # outputs 90, not 100",
    "crumbs": [
      "Programs",
      "Program 3"
    ]
  },
  {
    "objectID": "programs/03/instructions.html#additional-files",
    "href": "programs/03/instructions.html#additional-files",
    "title": "Program: Sale Item",
    "section": "Additional Files",
    "text": "Additional Files\nYou are provided with a template that you should use. Note that the template contains a __main__ section with some code already inside of it. Use the main portion of the code and the examples above to test your solution before submitting to the auto-grader.\ntemplate.py",
    "crumbs": [
      "Programs",
      "Program 3"
    ]
  },
  {
    "objectID": "programs/03/instructions.html#submission",
    "href": "programs/03/instructions.html#submission",
    "title": "Program: Sale Item",
    "section": "Submission",
    "text": "Submission\nYou must submit your code to the course website as a single .py file.",
    "crumbs": [
      "Programs",
      "Program 3"
    ]
  },
  {
    "objectID": "programs/04/instructions.html",
    "href": "programs/04/instructions.html",
    "title": "Program #4: Height",
    "section": "",
    "text": "Your task in this assignment is to write python code that would implement a simple Height class that could potentially be used as a small part of a much larger program. To allow for its use with other systems, the specifications for the Height class are defined below",
    "crumbs": [
      "Programs",
      "Program 4"
    ]
  },
  {
    "objectID": "programs/04/instructions.html#overview",
    "href": "programs/04/instructions.html#overview",
    "title": "Program #4: Height",
    "section": "",
    "text": "Your task in this assignment is to write python code that would implement a simple Height class that could potentially be used as a small part of a much larger program. To allow for its use with other systems, the specifications for the Height class are defined below",
    "crumbs": [
      "Programs",
      "Program 4"
    ]
  },
  {
    "objectID": "programs/04/instructions.html#class-details",
    "href": "programs/04/instructions.html#class-details",
    "title": "Program #4: Height",
    "section": "Class details",
    "text": "Class details\nThe class should be called Height.\n\nConstructor\nThe constructor takes two arguments for the ft and inch elements of any Height object. The constructor also uses default values of 0 for both ft and inch elements if they are not provided.\n\n\nAccessors and Mutators\nThe class should have accessors and mutators for all instance variables which use the decorator method discussed in class. Additionally\n\nthe ft and inch mutators should not allow for those variables to be set to negative values. If that is attempted, they are set to 0 instead.\nThe inch mutator should not allow for values larger than or equal to 12. If that is attempted, the ft value is updated accordingly. For example, creating a Height object with 1ft and 26 inches should result in a Height object with 3 ft and 2 inches.\n\n\n\nExtra functions\n\nThe class should have an inches function that returns the total number of inches that the Height object is worth.\nThe class should also contain a __str__ function that determines how Height objects are represented when printed i.e. 3’ 2” for an object with 3 ft and 2 inch.\nThe class should also overload some mathematical and comparison operators i.e. defines what those operators mean in the context of Height objects.\n\nThe operators in question include +, -, &gt;, &gt;=, &lt;=, &lt;, ==, and !=.\nNote that the mathematical operators above should return Height objects with the appropriate state.\n\nFeel free to add any other functions that you feel will help to make your class more efficient and/ or neater.\n\n\n\nmain function\nThe template provided contains an existing main function that will test the functionality defined above that your class should have. The tests include, but are not limited to, Object creation, mathematical and comparison operators, and the functionality of the other functions.\nYou should not change the main function in any way. Note that if you experience any errors during your class creation, those errors can be resolved by making adjustments to your Height class instead.\nSuccessful running of your code will produce the expected output shown below.\nh1 = 6' 5\"\nh2 = 2' 11\"\nh3 = 0' 0\"\nh4 = 4' 0\"\nh5 = 6' 5\"\nh6 = 0' 0\"\n========================================\n6' 5\" is in fact 77 inches\n0' 0\" is in fact 0 inches\n6' 5\" is in fact 77 inches\n========================================\n6' 5\" + 2' 11\" = 9' 4\"\n6' 5\" - 4' 10\" = 1' 7\"\n4' 0\" - 6' 5\" = 0' 0\"\n6' 5\" + 0' 1\" = 6' 6\"\n========================================\n6' 5\" &gt; 2' 11\": True\n6' 5\" &lt; 6' 5\": False\n6' 5\" &gt;= 6' 5\": True\n2' 11\" &lt;= 6' 5\": True\n9' 4\" == 9' 4\": True\n6' 5\" == 6' 6\": False\n6' 5\" &gt;= 6' 6\": False\n6' 5\" == 6' 5\": True\n2' 10\" != 2' 11\": True\n========================================\n\nNote that creating a program that produces the output shown above does not mean that your program has met all the requirements for the assignment.",
    "crumbs": [
      "Programs",
      "Program 4"
    ]
  },
  {
    "objectID": "programs/04/instructions.html#helper-files",
    "href": "programs/04/instructions.html#helper-files",
    "title": "Program #4: Height",
    "section": "Helper Files",
    "text": "Helper Files\ntemplate.py",
    "crumbs": [
      "Programs",
      "Program 4"
    ]
  },
  {
    "objectID": "programs/02/instructions.html",
    "href": "programs/02/instructions.html",
    "title": "Program 2: Population",
    "section": "",
    "text": "Your task in this assignment is to write a program that calculates the frequency of population ranges in the given city population file. You are provided with a text file that contains the documented populations of all the cities in the world (i.e. over 42,000 cities). Your code should prompt the user for the file name, the minimum, maximum and step sizes to use in the population table, and then create a table that contains how many cities have populations in those ranges.",
    "crumbs": [
      "Programs",
      "Program 2"
    ]
  },
  {
    "objectID": "programs/02/instructions.html#overview",
    "href": "programs/02/instructions.html#overview",
    "title": "Program 2: Population",
    "section": "",
    "text": "Your task in this assignment is to write a program that calculates the frequency of population ranges in the given city population file. You are provided with a text file that contains the documented populations of all the cities in the world (i.e. over 42,000 cities). Your code should prompt the user for the file name, the minimum, maximum and step sizes to use in the population table, and then create a table that contains how many cities have populations in those ranges.",
    "crumbs": [
      "Programs",
      "Program 2"
    ]
  },
  {
    "objectID": "programs/02/instructions.html#sample-outputs",
    "href": "programs/02/instructions.html#sample-outputs",
    "title": "Program 2: Population",
    "section": "Sample Outputs",
    "text": "Sample Outputs\n\nSample 1\nBelow is a successful sample run where generated inputs when tested are highlighted in red\nWhat is the name of the file with the population information? popn.txt.\nThis file has 42175 cities in it.\nWhat population do you want as the minimum? 0\nWhat population do you want as the maximum? 100000\nHow many rows do you want in the table? 10\n----------------------------------------\nPopulation              Frequencies\n----------------------------------------\n0 - 9999                13905\n10000 - 19999           10348\n20000 - 29999           4780\n30000 - 39999           2698\n40000 - 49999           1715\n50000 - 59999           1213\n60000 - 69999           891\n70000 - 79999           734\n80000 - 89999           535\n90000 - 99999           411\n----------------------------------------\n\n\n\n\nSample 2\nSimilar to a previous assignment, your code should recognize when the file name provided does not exist and reprompt the user until the an existing filename is given. Below is a sample run with that functionality demonstrated.\nWhat is the name of the file with the population information? input\nThe file name you specified does not exist.\nEnter file name again: output\nThe file name you specified does not exist.\nEnter file name again: Test\nThe file name you specified does not exist.\nEnter file name again: popn.txt\nThis file has 42175 cities in it.\nWhat population do you want as the minimum? 0\nWhat population do you want as the maximum? 100000\nHow many rows do you want in the table? 10\n----------------------------------------\nPopulation              Frequencies\n----------------------------------------\n0 - 9999                13905\n10000 - 19999           10348\n20000 - 29999           4780\n30000 - 39999           2698\n40000 - 49999           1715\n50000 - 59999           1213\n60000 - 69999           891\n70000 - 79999           734\n80000 - 89999           535\n90000 - 99999           411\n----------------------------------------\n\nIt may be helpful to know that there are 40 dashes running across the table and the columns were separated by two tab characters.",
    "crumbs": [
      "Programs",
      "Program 2"
    ]
  },
  {
    "objectID": "programs/02/instructions.html#required-functions",
    "href": "programs/02/instructions.html#required-functions",
    "title": "Program 2: Population",
    "section": "Required Functions",
    "text": "Required Functions\n\nLoad File\nA function named load_file that reads the contents of a file. The function takes a single argument, the filename, and returns a list of all the numbers found in the file. It ensures that the provided filename exists and, if not, prompts the user to enter the correct filename. This is an excellent opportunity to use a try-except construct, which you may have encountered in previous lessons or assignments.\n\n\nPopulation Ranges\nA function named create_ranges that is in charge of generating the strings found in the Population column. This function should take in three arguments: a minimum value, a maximum value, and the number of rows in the table (in that order) and then creates a list that contains the appropriate ranges of populations.\nAs an example, if this function receives 0, 100, 5 as arguments, then the list it generates would be:\n[\"0 - 19\", \"20 - 39\", \"40 - 59\", \"60 - 79\", \"80 - 99\"]\nNotice how the arguments passed to the function affected the output. The first interval starts at 0, the last interval does not include the value 100, and there are 5 intervals generated (i.e. number of rows).\n\n\nCount Cities\nA function named count_cities that is in charge of counting the number of cities in each given population range, it receives the list containing the ranges produced from the previous function, and the list containing all population values generated from the load_file function.\nThis function should return a list that contains the number of times a population appears for each corresponding range.\nFor example, assume our population ranges are as follows:\npopulation_ranges = [\"0 - 19\", \"20 - 39\", \"40 - 59\", \"60 - 79\", \"80 - 99\"]\nAlso assume there are 5 cities with a population between 0 and 19, 12 cities with a population between 40 and 59, and 3 cities with a population of between 60 and 79. Then this function would create the following list:\nfrequencies = [5, 0, 12, 3, 0]\nIt then returns this list to the calling statement.\n\n\nGenerate Table\nThe generate_table function will generate the table and return it as a string to the calling statement. This function will take in two arguments, the first represents the population ranges and the second represents the frequencies. Note that this function is not responsible for printing anything, it simply returns a string to the calling statement that represents the entire table.\n\n\nMain\nThis program will have a function called main that is in charge of calling on the functions mentioned above and creating the outputs as shown in the sample runs.",
    "crumbs": [
      "Programs",
      "Program 2"
    ]
  },
  {
    "objectID": "programs/02/instructions.html#additional-files",
    "href": "programs/02/instructions.html#additional-files",
    "title": "Program 2: Population",
    "section": "Additional Files",
    "text": "Additional Files\npopn.txt\ntemplate.py",
    "crumbs": [
      "Programs",
      "Program 2"
    ]
  },
  {
    "objectID": "programs/02/instructions.html#additional-information",
    "href": "programs/02/instructions.html#additional-information",
    "title": "Program 2: Population",
    "section": "Additional Information",
    "text": "Additional Information\nTo help clarify, here are some specifics and/or constraints:\n\nYou are provided with an input file called popn.txt that contains the populations of over 42,000 cities that you will be parsing. Note that your code should be able to parse any filename that the user provides and not just files named popn.txt. Use this file to test your code locally.\nYour code will require the functions listed above. Feel free to add any extra functions you think are necessary.\nYou might consider including the following conditional in your code when running it locally so that when you upload it to the autograder the autograder ignores the main portion of your code (note that the main portion of your code is not the function called main).\nif __name__ == \"__main__\":\nNote that the autograder would ignore this since the autograder will import your code into another file. Any code inside of that conditional is ignored when a file is imported.\nYour output should be exactly like the sample runs shown above (of course, actual results will vary depending on the min, max, and interval values chosen by the autograder);\nYou must include a meaningful header, use good coding style, use meaningful variable names, and comment your source code where appropriate;\nYou must use the provided source code template (it contains helpful comments that can help you structure your code); and\nYou must submit your source code as a single .py file.",
    "crumbs": [
      "Programs",
      "Program 2"
    ]
  },
  {
    "objectID": "programs/01/instructions.html",
    "href": "programs/01/instructions.html",
    "title": "Program: Squad Names",
    "section": "",
    "text": "Your task in this assignment is to write a program that calculates the frequency of names (or substrings) in a provided squad list file. You are provided with a text file that contains the names of all the squad players in the 2022 Fifa World Cup tournament for you to be able to test your code. Each name is on a different line in this file. Your code should prompt the user for a name (or substring), and then print out some statistics that include how many names contain that substring. Below is a sample run with user input in red.\nWhat file do you want to open? input.txt\nthe file has 892 names in it\nWhat name (or substring) are you interested in searching for? ad.\n--------------------------------------------------\n2 names start with this string\n3 names end with this string\n39 names contain this string\n--------------------------------------------------\n\nIt is worth mentioning that your code should recognize when the file name provided does not exist and provide the user with an opportunity to type in the correct file name. Below is a sample run with that functionality demonstrated.\nWhat file do you want to open? intput.txt\nThe file name you specified does not exist.\nEnter file name again: tinput.text\nThe file name you specified does not exist.\nEnter file name again: someotherfile.text\nThe file name you specified does not exist.\nEnter file name again: input.text\nthe file has 892 names in it\nWhat name (or substring) are you interested in searching for? pulisic.\n--------------------------------------------------\n0 names start with this string\n1 names end with this string\n1 names contain this string\n--------------------------------------------------",
    "crumbs": [
      "Programs",
      "Program 1"
    ]
  },
  {
    "objectID": "programs/01/instructions.html#overview",
    "href": "programs/01/instructions.html#overview",
    "title": "Program: Squad Names",
    "section": "",
    "text": "Your task in this assignment is to write a program that calculates the frequency of names (or substrings) in a provided squad list file. You are provided with a text file that contains the names of all the squad players in the 2022 Fifa World Cup tournament for you to be able to test your code. Each name is on a different line in this file. Your code should prompt the user for a name (or substring), and then print out some statistics that include how many names contain that substring. Below is a sample run with user input in red.\nWhat file do you want to open? input.txt\nthe file has 892 names in it\nWhat name (or substring) are you interested in searching for? ad.\n--------------------------------------------------\n2 names start with this string\n3 names end with this string\n39 names contain this string\n--------------------------------------------------\n\nIt is worth mentioning that your code should recognize when the file name provided does not exist and provide the user with an opportunity to type in the correct file name. Below is a sample run with that functionality demonstrated.\nWhat file do you want to open? intput.txt\nThe file name you specified does not exist.\nEnter file name again: tinput.text\nThe file name you specified does not exist.\nEnter file name again: someotherfile.text\nThe file name you specified does not exist.\nEnter file name again: input.text\nthe file has 892 names in it\nWhat name (or substring) are you interested in searching for? pulisic.\n--------------------------------------------------\n0 names start with this string\n1 names end with this string\n1 names contain this string\n--------------------------------------------------",
    "crumbs": [
      "Programs",
      "Program 1"
    ]
  },
  {
    "objectID": "programs/01/instructions.html#expected-functions",
    "href": "programs/01/instructions.html#expected-functions",
    "title": "Program: Squad Names",
    "section": "Expected Functions",
    "text": "Expected Functions\nIn order to accomplish this, you will write functions that will read the file and then search for that string. The functions you should write are as follows:\n\nRead File\nThe purpose of this function is to load a file and return each line of that file as a separate value in a list. Note that when reading lines, you might end up with newline characters or blank characters at the end of each line. You will need to remove those characters for the tests to run properly.\nThis function should be named readFile.\nIt should have 1 parameter that represents the name of the file as a string.\nIt should return a list where each value in the list is a line from the file that was loaded.\n\n\nBegins With\nThis function receives two string arguments and returns a boolean that represents whether the first string begins with the second string. This function should be named beginswith.\n\n\nEnds With\nThe endswith function receives two string arguments and returns a boolean that represents whether the first string ends with the second string.\nBe sure the function is named endswith.\n\n\nContains\nThe contains receives two string arguments and returns a boolean that represents whether the first string contains the second string.\nBe sure the function is named contains.\n\n\nGet Stats\nThe getStats function receives two arguments: a list of names, and a substring (in that order). It then creates a short 3 element list that contains the number of times that the substring appears in the list. The first element is the number of names in which the substring appears at the beginning. The second element in the number of names in which the substring appears at the end. The third element in the number of names that contain the substring. The function should return the 3 element list with the correct stats. In all three cases, case should be ignored in order to calculate the stats.\nBe sure the function is named getStats\n\n\nMain\nThis function will be responsible for calling on each of the functions above so that the program produces the desired output. It should first prompt the user for a file name, then read the file, and then produce the appropriate output as shown int he samples above.\nThis function should be called main and will have no parameters.",
    "crumbs": [
      "Programs",
      "Program 1"
    ]
  },
  {
    "objectID": "programs/01/instructions.html#helper-files",
    "href": "programs/01/instructions.html#helper-files",
    "title": "Program: Squad Names",
    "section": "Helper Files",
    "text": "Helper Files\ninput.txt\ntemplate.py",
    "crumbs": [
      "Programs",
      "Program 1"
    ]
  },
  {
    "objectID": "programs/01/instructions.html#additional-info",
    "href": "programs/01/instructions.html#additional-info",
    "title": "Program: Squad Names",
    "section": "Additional Info",
    "text": "Additional Info\n\nYou are provided with an input file called input.txt that contains the names you will be parsing. Note that your code should be able to parse any filename that the user provides and not just files named input.txt\nYour program will require at least the functions mentioned above. Feel free to add any extra functions you think are necessary.\nFeel free to include in a section of your file the conditional as follows so that you can test your file locally and not need to modify anything when you upload it to the autograder.\nif __name__ == \"__main__\":\n    # code you want to test\nRecall that this conditional will allow code to run when you directly run a file, however, when a file is imported into another file, the code inside the conditional will not run. The autograder works by importing your file into another file, so the code inside this conditional will not run on the autograder.\nA lot of the functionality that is required in this assignment can easily be implemented by taking advantage of some of python’s inbuilt string functions. You are encouraged to look up python string functions to get an understanding of what functionality you have available to you when dealing with strings.\nYour output should be exactly like the sample runs shown above (of course, actual results will vary depending on the provided input text file and substrings/names);\nYou must include a meaningful header, use good coding style, use meaningful variable names, and comment your source code where appropriate;\nYou must use the provided source code template (it contains helpful comments that can help you structure your code); and\nYou must submit your source code as a single .py file. The name of the file does not matter.",
    "crumbs": [
      "Programs",
      "Program 1"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/04 Instance and Class Variables.html",
    "href": "lessons/02 Object Oriented Programming/04 Instance and Class Variables.html",
    "title": "CSC 131",
    "section": "",
    "text": "Suppose that an expert in the field decided to change the scientific name for dogs from canine to something like “caten”. You know, to account for inflation. Changing class variables separately for each instance of the dog class doesn’t make sense. The purpose of a class variable is that its value is shared simultaneously among all of the instances of the class. The proper method of changing a class variable so that it appropriately affects all of the instances is to use the class name as follows:\nDog.kind = \"caten\"\nThis statement simultaneously changes the class variable kind (to caten) for all instances of the dog class. To illustrate this, here is some source code for a dog class that illustrates the behavior and differences of class and instance variables, and its output:\nclass Dog:\n    kind = \"canine\"\n    def __init__(self, dog_name):\n        self.name = dog_name\n\nd1 = Dog(\"Maya\")\nd2 = Dog(\"Biff\")\n\nprint(\"I have a dog named {} that is a {} and another named {} \\\nthat is also a {}.\".format(d1.name, d1.kind, d2.name,d2.kind))\n\nd1.name = \"Bosco\"\n\nprint(\"I have a dog named {} that is a {} and another named {} \\\nthat is also a {}.\".format(d1.name, d1.kind, d2.name,\\\nd2.kind))\n\nDog.kind = \"caten\"\n\nprint(\"I have a dog named {} that is a {} and another named {} \\\nthat is also a {}.\".format(d1.name, d1.kind, d2.name,\\\nd2.kind))\n\nd1.breed = \"German Shepherd\"\nd2.breed = \"mutt\"\n\nprint(\"I have a dog named {} that is a {} and another named {} \\\nthat is a {}.\".format(d1.name, d1.breed, d2.name,\\\nd2.breed))\n\n\n\n\n\n\n\nDid you know\n\n\n\nYou may have noticed above that some statements seem to be spread across multiple lines. Each of the lines that make up these statements end with a backslash (), except for the last line of the statement. Python allows the use of a backslash to note that the remainder of a statement is provided on the next line. For example, take a look at the following statement:\na = 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 –\n1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1\nThis statement can be spread across multiple lines as follows:\na = 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1\\\n – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1\n\nNote a few things: (1) the class variable kind is applied to both instances, d1 and d2; and (2) the instance variable breed is dynamically created and applied (separately) to each instance.\n\n\n\n\n\n\n\nDid you know\n\n\n\nFor readability, Python source code is presented as it is formatted in IDLE throughout this lesson. the main reason for this is that presenting source code this way provides syntax highlighting. Syntax highlighting is the feature of highlighting (or coloring) certain portions of source code so that it helps to categorize constructs, keywords, variables, and so on. It essentially helps to make the source code more readable. For example, Python keywords are colored orange and strings are colored green.\n\nIt is important to understand the difference between instance variables and class variables. Although they seem similar, they are actually quite different. Perhaps this is best illustrated with an example. Consider the following modified dog class and output:\nclass Dog:\n    kind = \"canine\"\n    tricks = []\n\n    def __init__(self, dog_name):\n        self.name = dog_name\n    \n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\nd1 = Dog(\"Maya\")\nd2 = Dog(\"Biff\")\n\nd1.add_trick(\"roll over\")\nd2.add_trick(\"play dead\")\n\nprint(\"I have a dog named {} that can {}.\".format(d1.name,\\\n d1.tricks))\nprint(\"I have a dog named {} that can {}.\".format(d2.name,\\\n d2.tricks))\nThe only difference in the class is the addition of the list tricks and the function add_trick. After all, a dog can do tricks! Adding a trick to an instance of the dog class can be done by accessing the add_trick function (using the dot operator) on an object reference of a dog instance and providing the trick to add (as a string). As shown before, the dog instance is automatically passed in and mapped to the formal parameter self in the function. The string that represents the trick to add is passed in and mapped to the formal parameter trick. The function appends a new trick to the end of the list.\nThe expected behavior of the source code above may be that each instance of the dog class (i.e., d1 and d2) can define their own set (or list) of tricks. In fact, we expect that Maya can “roll over” and that Biff can “play dead”, but review the output.\nThe fact that both dog objects can do the same tricks can be explained by noting that the list tricks is defined at the class level and is therefore considered a class variable. As such, all instances of the dog class share the list. A change to it (even through the function add_trick) affects all instances of the dog class! To fix this and make the list of tricks an instance variable, we can define it in the __init__ method as follows:\nclass Dog:\n    kind = \"canine\"\n\n    def __init__(self, dog_name):\n        self.name = dog_name\n        self.tricks = []\n    \n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\nd1 = Dog(\"Maya\")\nd2 = Dog(\"Biff\")\n\nd1.add_trick(\"roll over\")\nd2.add_trick(\"play dead\")\n\nprint(\"I have a dog named {} that can {}.\".format(d1.name,\\\n d1.tricks))\nprint(\"I have a dog named {} that can {}.\".format(d2.name,\\\n d2.tricks))\nSince it is no longer at the class level, it is considered an instance variable and thus allows unique values to be stored for each instance of the dog class.\nNow, take a look at this more complete dog class:\nclass Dog:\n    kind = \"canine\"\n\n    def __init__(self, name, breed):\n        self.name = name\n        self.breed = breed\n        self.tricks = []\n        self.friends = []\n    \n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\nd1 = Dog(\"Maya\", \"mutt\")\nd2 = Dog(\"Biff\", \"Black Lab\")\nd1.add_trick(\"roll over\")\nd2.add_trick(\"play dead\")\n\nprint(\"I have a dog named {} that can {}.\".format(d1.name,\\\n d1.tricks))\nprint(\"I have a dog named {} that can {}.\".format(d2.name,\\\n d2.tricks))\n\nd1.friends = [ \"Finca\", \"Shane\" ]\nd2.friends = [ \"Sadie\", \"Bosco\" ]\nprint(\"{}'s friends are {}.\".format(d1.name, d1.friends))\nprint(\"{}'s friends are {}.\".format(d2.name, d2.friends))\nNote the addition of several new instance variables: breed and friends. This class defines all dogs to have a name, a breed, a list of tricks, and a list of friends.\nAt this point, it may be worthwhile to summarize the difference between class variables, instance variables, and function parameters. Class variables are relevant to an entire class. The values of class variables are shared among all of the instances of a class. Think of a class variable as being stored in a single memory location that all the instances of a class can refer to. Instance variables are also relevant to an entire class. However, the values of instance variables are unique for each instance of a class. That is, an instance variable is stored in a different memory location for each instance of a class. Function parameters are relevant to a function and are only accessible inside the function. They are short-lived and last until the function has finished its execution.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Instance and Class Variables"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/04 Instance and Class Variables.html#instance-variables-vs.-class-variables",
    "href": "lessons/02 Object Oriented Programming/04 Instance and Class Variables.html#instance-variables-vs.-class-variables",
    "title": "CSC 131",
    "section": "",
    "text": "Suppose that an expert in the field decided to change the scientific name for dogs from canine to something like “caten”. You know, to account for inflation. Changing class variables separately for each instance of the dog class doesn’t make sense. The purpose of a class variable is that its value is shared simultaneously among all of the instances of the class. The proper method of changing a class variable so that it appropriately affects all of the instances is to use the class name as follows:\nDog.kind = \"caten\"\nThis statement simultaneously changes the class variable kind (to caten) for all instances of the dog class. To illustrate this, here is some source code for a dog class that illustrates the behavior and differences of class and instance variables, and its output:\nclass Dog:\n    kind = \"canine\"\n    def __init__(self, dog_name):\n        self.name = dog_name\n\nd1 = Dog(\"Maya\")\nd2 = Dog(\"Biff\")\n\nprint(\"I have a dog named {} that is a {} and another named {} \\\nthat is also a {}.\".format(d1.name, d1.kind, d2.name,d2.kind))\n\nd1.name = \"Bosco\"\n\nprint(\"I have a dog named {} that is a {} and another named {} \\\nthat is also a {}.\".format(d1.name, d1.kind, d2.name,\\\nd2.kind))\n\nDog.kind = \"caten\"\n\nprint(\"I have a dog named {} that is a {} and another named {} \\\nthat is also a {}.\".format(d1.name, d1.kind, d2.name,\\\nd2.kind))\n\nd1.breed = \"German Shepherd\"\nd2.breed = \"mutt\"\n\nprint(\"I have a dog named {} that is a {} and another named {} \\\nthat is a {}.\".format(d1.name, d1.breed, d2.name,\\\nd2.breed))\n\n\n\n\n\n\n\nDid you know\n\n\n\nYou may have noticed above that some statements seem to be spread across multiple lines. Each of the lines that make up these statements end with a backslash (), except for the last line of the statement. Python allows the use of a backslash to note that the remainder of a statement is provided on the next line. For example, take a look at the following statement:\na = 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 –\n1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1\nThis statement can be spread across multiple lines as follows:\na = 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1\\\n – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1 – 1 + 1\n\nNote a few things: (1) the class variable kind is applied to both instances, d1 and d2; and (2) the instance variable breed is dynamically created and applied (separately) to each instance.\n\n\n\n\n\n\n\nDid you know\n\n\n\nFor readability, Python source code is presented as it is formatted in IDLE throughout this lesson. the main reason for this is that presenting source code this way provides syntax highlighting. Syntax highlighting is the feature of highlighting (or coloring) certain portions of source code so that it helps to categorize constructs, keywords, variables, and so on. It essentially helps to make the source code more readable. For example, Python keywords are colored orange and strings are colored green.\n\nIt is important to understand the difference between instance variables and class variables. Although they seem similar, they are actually quite different. Perhaps this is best illustrated with an example. Consider the following modified dog class and output:\nclass Dog:\n    kind = \"canine\"\n    tricks = []\n\n    def __init__(self, dog_name):\n        self.name = dog_name\n    \n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\nd1 = Dog(\"Maya\")\nd2 = Dog(\"Biff\")\n\nd1.add_trick(\"roll over\")\nd2.add_trick(\"play dead\")\n\nprint(\"I have a dog named {} that can {}.\".format(d1.name,\\\n d1.tricks))\nprint(\"I have a dog named {} that can {}.\".format(d2.name,\\\n d2.tricks))\nThe only difference in the class is the addition of the list tricks and the function add_trick. After all, a dog can do tricks! Adding a trick to an instance of the dog class can be done by accessing the add_trick function (using the dot operator) on an object reference of a dog instance and providing the trick to add (as a string). As shown before, the dog instance is automatically passed in and mapped to the formal parameter self in the function. The string that represents the trick to add is passed in and mapped to the formal parameter trick. The function appends a new trick to the end of the list.\nThe expected behavior of the source code above may be that each instance of the dog class (i.e., d1 and d2) can define their own set (or list) of tricks. In fact, we expect that Maya can “roll over” and that Biff can “play dead”, but review the output.\nThe fact that both dog objects can do the same tricks can be explained by noting that the list tricks is defined at the class level and is therefore considered a class variable. As such, all instances of the dog class share the list. A change to it (even through the function add_trick) affects all instances of the dog class! To fix this and make the list of tricks an instance variable, we can define it in the __init__ method as follows:\nclass Dog:\n    kind = \"canine\"\n\n    def __init__(self, dog_name):\n        self.name = dog_name\n        self.tricks = []\n    \n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\nd1 = Dog(\"Maya\")\nd2 = Dog(\"Biff\")\n\nd1.add_trick(\"roll over\")\nd2.add_trick(\"play dead\")\n\nprint(\"I have a dog named {} that can {}.\".format(d1.name,\\\n d1.tricks))\nprint(\"I have a dog named {} that can {}.\".format(d2.name,\\\n d2.tricks))\nSince it is no longer at the class level, it is considered an instance variable and thus allows unique values to be stored for each instance of the dog class.\nNow, take a look at this more complete dog class:\nclass Dog:\n    kind = \"canine\"\n\n    def __init__(self, name, breed):\n        self.name = name\n        self.breed = breed\n        self.tricks = []\n        self.friends = []\n    \n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\nd1 = Dog(\"Maya\", \"mutt\")\nd2 = Dog(\"Biff\", \"Black Lab\")\nd1.add_trick(\"roll over\")\nd2.add_trick(\"play dead\")\n\nprint(\"I have a dog named {} that can {}.\".format(d1.name,\\\n d1.tricks))\nprint(\"I have a dog named {} that can {}.\".format(d2.name,\\\n d2.tricks))\n\nd1.friends = [ \"Finca\", \"Shane\" ]\nd2.friends = [ \"Sadie\", \"Bosco\" ]\nprint(\"{}'s friends are {}.\".format(d1.name, d1.friends))\nprint(\"{}'s friends are {}.\".format(d2.name, d2.friends))\nNote the addition of several new instance variables: breed and friends. This class defines all dogs to have a name, a breed, a list of tricks, and a list of friends.\nAt this point, it may be worthwhile to summarize the difference between class variables, instance variables, and function parameters. Class variables are relevant to an entire class. The values of class variables are shared among all of the instances of a class. Think of a class variable as being stored in a single memory location that all the instances of a class can refer to. Instance variables are also relevant to an entire class. However, the values of instance variables are unique for each instance of a class. That is, an instance variable is stored in a different memory location for each instance of a class. Function parameters are relevant to a function and are only accessible inside the function. They are short-lived and last until the function has finished its execution.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Instance and Class Variables"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/07 Class Diagrams.html",
    "href": "lessons/02 Object Oriented Programming/07 Class Diagrams.html",
    "title": "CSC 131",
    "section": "",
    "text": "In computer science courses, you are often asked to design simple programs. The ability to understand and hold everything in one’s head when solving a simple problem is relatively straightforward and, well, usually pretty simple. However, when solving complicated problems and developing solutions to these problems as large and tedious applications, it becomes quite difficult to manage all of the parts and pieces. Often, we require the use of tools and techniques that incorporate visual aids and diagrams to assist us in managing the structure and components of these applications.\n\n\n\n\n\n\nDefinition\n\n\n\nA class diagram is a type of diagram that describes the structure of a program by visualizing its classes, their state and behavior, and their relationships.\n\n\nThe most simple class diagram only shows the classes of a program, which are represented as rectangles.\nTo illustrate how a class diagram could be used to model an application’s structure, let’s consider one that models vehicle traffic in a large city for the purpose of analyzing how it manages traffic during rush hour. This kind of application would be useful in learning about traffic patterns, congestion, and so on. In fact, it could help to redesign roads, entrances to and exits from highways and interstates, the placement and timing of traffic signals, etc. Such an application may include classes for cars, pickup trucks, buses, tractor trailers, motorcycles, and so on, since all of these things contribute to the traffic in a city. In fact, the application could be modeled with a class diagram as follows:\n\n\n\n\n\nThe classes of an application are always singular nouns. Since a class is a blueprint for objects, then a class is essentially like a rubber stamp. For example, we can define a class that describes the blueprint for a car. This class would be considered the car class and be formally called Car. As mentioned earlier, the names of classes are typically capitalized. Since they are identifiers, they also must not contain spaces and abide by all of the rules for naming identifiers in the programming language. To summarize the rules of naming a class:\n\nAlways use singular nouns\nNames of classes start with an initial capital letter (and usually follow CamelCasingLikeThis)\nNames must not contain spaces or other invalid characters as per the naming identifier rules\n\nIn Python, the car class could be defined as follows:\nclass Car:\n    ...\nInstances of the car class would collectively be called cars (and there could be many of them). Similarly, the class for a pickup truck could be called PickupTruck, and would be defined in Python as follows:\nclass PickupTruck:\n    ...\nThe beauty of a class diagram is that it allows us to very easily see the components of a system or application. In the class diagram above, there is no indication of the state and behavior of classes, nor is there any indication of any relationships between classes. We will get to this later.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Class Diagrams"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/07 Class Diagrams.html#class-diagrams",
    "href": "lessons/02 Object Oriented Programming/07 Class Diagrams.html#class-diagrams",
    "title": "CSC 131",
    "section": "",
    "text": "In computer science courses, you are often asked to design simple programs. The ability to understand and hold everything in one’s head when solving a simple problem is relatively straightforward and, well, usually pretty simple. However, when solving complicated problems and developing solutions to these problems as large and tedious applications, it becomes quite difficult to manage all of the parts and pieces. Often, we require the use of tools and techniques that incorporate visual aids and diagrams to assist us in managing the structure and components of these applications.\n\n\n\n\n\n\nDefinition\n\n\n\nA class diagram is a type of diagram that describes the structure of a program by visualizing its classes, their state and behavior, and their relationships.\n\n\nThe most simple class diagram only shows the classes of a program, which are represented as rectangles.\nTo illustrate how a class diagram could be used to model an application’s structure, let’s consider one that models vehicle traffic in a large city for the purpose of analyzing how it manages traffic during rush hour. This kind of application would be useful in learning about traffic patterns, congestion, and so on. In fact, it could help to redesign roads, entrances to and exits from highways and interstates, the placement and timing of traffic signals, etc. Such an application may include classes for cars, pickup trucks, buses, tractor trailers, motorcycles, and so on, since all of these things contribute to the traffic in a city. In fact, the application could be modeled with a class diagram as follows:\n\n\n\n\n\nThe classes of an application are always singular nouns. Since a class is a blueprint for objects, then a class is essentially like a rubber stamp. For example, we can define a class that describes the blueprint for a car. This class would be considered the car class and be formally called Car. As mentioned earlier, the names of classes are typically capitalized. Since they are identifiers, they also must not contain spaces and abide by all of the rules for naming identifiers in the programming language. To summarize the rules of naming a class:\n\nAlways use singular nouns\nNames of classes start with an initial capital letter (and usually follow CamelCasingLikeThis)\nNames must not contain spaces or other invalid characters as per the naming identifier rules\n\nIn Python, the car class could be defined as follows:\nclass Car:\n    ...\nInstances of the car class would collectively be called cars (and there could be many of them). Similarly, the class for a pickup truck could be called PickupTruck, and would be defined in Python as follows:\nclass PickupTruck:\n    ...\nThe beauty of a class diagram is that it allows us to very easily see the components of a system or application. In the class diagram above, there is no indication of the state and behavior of classes, nor is there any indication of any relationships between classes. We will get to this later.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Class Diagrams"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/10 Quick Reference.html",
    "href": "lessons/02 Object Oriented Programming/10 Quick Reference.html",
    "title": "CSC 131",
    "section": "",
    "text": "We have covered a lot of new terms in this lesson. This final section merely aggregates them all, along with their definition, so that you can easily and quickly refer to the terms should you need to.\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\naccessor\nA special method in a class that wraps an instance variable for the purpose of providing read access.\n\n\nbehavior\nAll of the things that an object can do; implemented using functions in the class.\n\n\nclass\nA blueprint for a thing; the definition of state and behavior for an entire class of things.\n\n\nclass diagram\nA diagram that models the classes of a system or application, their relationships, and their members.\n\n\nclass variable\nA variable that is defined at the class level; its value is shared among all instances of the class.\n\n\nconstructor\nA special method in a class that is automatically invoked when a new instance of the class is instantiated; usually performs initialization tasks (e.g., assigning default or specified values to the instance variables).\n\n\ndecorator\nA wrapper; in Python, accessors and mutators are wrapped using a decorator\n\n\ndot operator\nWhen used on an object reference, accessed the specified member of the class.\n\n\nhas-a\nA relationship among classes that implies one class making use of another; also means the ability of an object to create other objects.\n\n\ninheritance\nA relationship among classes that permits a class to inherit the state and behavior of another class; see is-a.\n\n\ninput validation\nThe process of validating a provided input to ensure that it conforms to some expected range or type.\n\n\ninstance\nAn object that represents the instantiation of a class.\n\n\ninstance variable\nA variable defined in a method of a class (usually the constructor) that allows individual instances of the class to uniquely set values to.\n\n\ninstantiate\nThe process of constructing a new instance of a class\n\n\nis-a\nA relationship among classes that permits a class to inherit the state and behavior of another class; see inheritance\n\n\nmagic function\nA special function in Python whose name begins and ends with two underscores (e.g., __init__, __str__, __add__).\n\n\nmember\nHow we collectively reference the state and behavior of a class\n\n\nmethod\nHow behavior is implemented in a class; they are functions that describe what an object can do\n\n\nmultiple inheritance\nThe ability of a class to inherit the state and behavior of multiple classes simultaneously\n\n\nmutator\nA special method in a class that wraps an instance variable for the purpose of providing write access; usually implements input validation.\n\n\nobject\nAn instance of a class, with specific values assigned to instance variables.\n\n\nobject class\nThe base class for all user-defined objects; the top-most superclass.\n\n\nobject reference\nA variable name that refers to an object.\n\n\noperator overloading\nThe redefining of an operator (e.g., the addition operator) on user-defined objects.\n\n\nsingle inheritance\nThe ability of a class to inherit the state and behavior of a single class.\n\n\nstate\nAll of the things that an object can be; implemented using instance variables in the class.\n\n\nsubclass\nA class that inherits state and behavior from another class.\n\n\nsuperclass\nA class that another class inherits state and behavior from.\n\n\ntypecast\nThe process of converting a value from one type to another (e.g., converting an integer to a floating point number).",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Quick Reference"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/10 Quick Reference.html#oo-quick-reference",
    "href": "lessons/02 Object Oriented Programming/10 Quick Reference.html#oo-quick-reference",
    "title": "CSC 131",
    "section": "",
    "text": "We have covered a lot of new terms in this lesson. This final section merely aggregates them all, along with their definition, so that you can easily and quickly refer to the terms should you need to.\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\naccessor\nA special method in a class that wraps an instance variable for the purpose of providing read access.\n\n\nbehavior\nAll of the things that an object can do; implemented using functions in the class.\n\n\nclass\nA blueprint for a thing; the definition of state and behavior for an entire class of things.\n\n\nclass diagram\nA diagram that models the classes of a system or application, their relationships, and their members.\n\n\nclass variable\nA variable that is defined at the class level; its value is shared among all instances of the class.\n\n\nconstructor\nA special method in a class that is automatically invoked when a new instance of the class is instantiated; usually performs initialization tasks (e.g., assigning default or specified values to the instance variables).\n\n\ndecorator\nA wrapper; in Python, accessors and mutators are wrapped using a decorator\n\n\ndot operator\nWhen used on an object reference, accessed the specified member of the class.\n\n\nhas-a\nA relationship among classes that implies one class making use of another; also means the ability of an object to create other objects.\n\n\ninheritance\nA relationship among classes that permits a class to inherit the state and behavior of another class; see is-a.\n\n\ninput validation\nThe process of validating a provided input to ensure that it conforms to some expected range or type.\n\n\ninstance\nAn object that represents the instantiation of a class.\n\n\ninstance variable\nA variable defined in a method of a class (usually the constructor) that allows individual instances of the class to uniquely set values to.\n\n\ninstantiate\nThe process of constructing a new instance of a class\n\n\nis-a\nA relationship among classes that permits a class to inherit the state and behavior of another class; see inheritance\n\n\nmagic function\nA special function in Python whose name begins and ends with two underscores (e.g., __init__, __str__, __add__).\n\n\nmember\nHow we collectively reference the state and behavior of a class\n\n\nmethod\nHow behavior is implemented in a class; they are functions that describe what an object can do\n\n\nmultiple inheritance\nThe ability of a class to inherit the state and behavior of multiple classes simultaneously\n\n\nmutator\nA special method in a class that wraps an instance variable for the purpose of providing write access; usually implements input validation.\n\n\nobject\nAn instance of a class, with specific values assigned to instance variables.\n\n\nobject class\nThe base class for all user-defined objects; the top-most superclass.\n\n\nobject reference\nA variable name that refers to an object.\n\n\noperator overloading\nThe redefining of an operator (e.g., the addition operator) on user-defined objects.\n\n\nsingle inheritance\nThe ability of a class to inherit the state and behavior of a single class.\n\n\nstate\nAll of the things that an object can be; implemented using instance variables in the class.\n\n\nsubclass\nA class that inherits state and behavior from another class.\n\n\nsuperclass\nA class that another class inherits state and behavior from.\n\n\ntypecast\nThe process of converting a value from one type to another (e.g., converting an integer to a floating point number).",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Quick Reference"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/06 Operator Overloading.html",
    "href": "lessons/02 Object Oriented Programming/06 Operator Overloading.html",
    "title": "CSC 131",
    "section": "",
    "text": "In the last example above, we defined a function in the fraction class that adds two fractions and returns the sum. We used this function similar to the following snippet of Python code:\nf1 = Fraction(1, 2)\nf2 = Fraction(3, 4)\nprint(f1.add(f2))\nAs expected, the output of these statements is: 5/4 (1.25)\nThe way in which we call the addition function seems a bit tedious. Why can’t we just use the addition operator? For example, why can’t we just add two fractions, f1 and f2, by merely using the expression f1 + f2? This would mean that the following modification of the example above would work as expected:\nf1 = Fraction(1, 2)\nf2 = Fraction(3, 4)\nprint(f1 + f2)\nIt turns out that such a thing is possible through a concept called operator overloading.\n\n\n\n\n\n\nDefinition\n\n\n\nOperator overloading is the act of redefining the behavior of operators (such as addition and subtraction) using their known symbols (+ for addition, – for subtraction, and so on) in order to support these operations on user-defined data types.\n\n\nFor example, redefining the addition operator for the fraction class could mean implementing the common denominator method described earlier\nPython has various internal magic functions that support the redefinition of common operators. The main idea is to encapsulate the new, redefined behavior in a function that is automatically called (using syntactic sugar) when two objects of the class are used as operands with the specified operator. For the purpose of the fraction class, we will only consider the four arithmetic operators.\nThe addition operator (+) can be redefined in a function called __add__ as follows:\ndef __add__(self, other):\n    num = (self.num * other.den) + (other.num * self.den)\n    den = self.den * other.den\n    sum = Fraction(num, den)\n    sum.reduce()\n    return sum\nNote that the source code in the new overloaded __add__ function is exactly the same as it was in the original add function shown earlier.\nThe subtraction operator (–) can be redefined in a function called __sub__ as follows:\ndef __sub__(self, other):\n    ...\nNote that for this and the remaining operators, the source code is not provided. Instead, appropriate code is replaced with an ellipsis (…).\nThe multiplication operator (*) can be redefined in a function called __mul__ as follows:\ndef __mul__(self, other):\n    ...\nLastly, The division operator (/) can be redefined in a function called __truediv__ as follows:\ndef __truediv__(self, other):\n    ...\nThe fraction class has now grown! Take a look:\n# defines a fraction\nclass Fraction:\n    # by default, a fraction is 0/1\n    def __init__(self, num=0, den=1):\n        self.num = num\n        # make sure not to set the denominator to 0 if specified\n        if (den == 0):\n        den = 1\n        self.den = den\n        self.reduce()\n    ...\n    # calculates and returns the sum of two fractions\n    def __add__(self, other):\n        num = (self.num * other.den) + (other.num * self.den)\n        den = self.den * other.den\n        sum = Fraction(num, den)\n        sum.reduce()\n        return sum\n    # calculates and returns the difference of two fractions\n    def __sub__(self, other):\n        # replace this with the function's actual implementation\n        return None\n    # calculates and returns the product of two fractions\n    def __mul__(self, other):\n        # replace this with the function's actual implementation\n        return None\n    # calculates and returns the division of two fractions\n    def __truediv__(self, other):\n        # replace this with the function's actual implementation\n        return None\n ...\nIn fact, we can now perform all of the implemented arithmetic operations on fractions. Here’s a snippet of Python code that tests the fraction class and assumes that the operator overload functions have been fully implemented:\n# main program\nf1 = Fraction(1, 2)\nf2 = Fraction(1, 4)\nprint(f1)\nprint(f2)\nprint(f1 + f2)\nprint(f1 - f2)\nprint(f1 * f2)\nprint(f1 / f2)\nAnd here is the output:\n1/2 (0.5)\n1/4 (0.25)\n3/4 (0.75)\n1/4 (0.25)\n1/8 (0.125)\n2/1 (2.0)",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Operator Overloading"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/06 Operator Overloading.html#operator-overloading",
    "href": "lessons/02 Object Oriented Programming/06 Operator Overloading.html#operator-overloading",
    "title": "CSC 131",
    "section": "",
    "text": "In the last example above, we defined a function in the fraction class that adds two fractions and returns the sum. We used this function similar to the following snippet of Python code:\nf1 = Fraction(1, 2)\nf2 = Fraction(3, 4)\nprint(f1.add(f2))\nAs expected, the output of these statements is: 5/4 (1.25)\nThe way in which we call the addition function seems a bit tedious. Why can’t we just use the addition operator? For example, why can’t we just add two fractions, f1 and f2, by merely using the expression f1 + f2? This would mean that the following modification of the example above would work as expected:\nf1 = Fraction(1, 2)\nf2 = Fraction(3, 4)\nprint(f1 + f2)\nIt turns out that such a thing is possible through a concept called operator overloading.\n\n\n\n\n\n\nDefinition\n\n\n\nOperator overloading is the act of redefining the behavior of operators (such as addition and subtraction) using their known symbols (+ for addition, – for subtraction, and so on) in order to support these operations on user-defined data types.\n\n\nFor example, redefining the addition operator for the fraction class could mean implementing the common denominator method described earlier\nPython has various internal magic functions that support the redefinition of common operators. The main idea is to encapsulate the new, redefined behavior in a function that is automatically called (using syntactic sugar) when two objects of the class are used as operands with the specified operator. For the purpose of the fraction class, we will only consider the four arithmetic operators.\nThe addition operator (+) can be redefined in a function called __add__ as follows:\ndef __add__(self, other):\n    num = (self.num * other.den) + (other.num * self.den)\n    den = self.den * other.den\n    sum = Fraction(num, den)\n    sum.reduce()\n    return sum\nNote that the source code in the new overloaded __add__ function is exactly the same as it was in the original add function shown earlier.\nThe subtraction operator (–) can be redefined in a function called __sub__ as follows:\ndef __sub__(self, other):\n    ...\nNote that for this and the remaining operators, the source code is not provided. Instead, appropriate code is replaced with an ellipsis (…).\nThe multiplication operator (*) can be redefined in a function called __mul__ as follows:\ndef __mul__(self, other):\n    ...\nLastly, The division operator (/) can be redefined in a function called __truediv__ as follows:\ndef __truediv__(self, other):\n    ...\nThe fraction class has now grown! Take a look:\n# defines a fraction\nclass Fraction:\n    # by default, a fraction is 0/1\n    def __init__(self, num=0, den=1):\n        self.num = num\n        # make sure not to set the denominator to 0 if specified\n        if (den == 0):\n        den = 1\n        self.den = den\n        self.reduce()\n    ...\n    # calculates and returns the sum of two fractions\n    def __add__(self, other):\n        num = (self.num * other.den) + (other.num * self.den)\n        den = self.den * other.den\n        sum = Fraction(num, den)\n        sum.reduce()\n        return sum\n    # calculates and returns the difference of two fractions\n    def __sub__(self, other):\n        # replace this with the function's actual implementation\n        return None\n    # calculates and returns the product of two fractions\n    def __mul__(self, other):\n        # replace this with the function's actual implementation\n        return None\n    # calculates and returns the division of two fractions\n    def __truediv__(self, other):\n        # replace this with the function's actual implementation\n        return None\n ...\nIn fact, we can now perform all of the implemented arithmetic operations on fractions. Here’s a snippet of Python code that tests the fraction class and assumes that the operator overload functions have been fully implemented:\n# main program\nf1 = Fraction(1, 2)\nf2 = Fraction(1, 4)\nprint(f1)\nprint(f2)\nprint(f1 + f2)\nprint(f1 - f2)\nprint(f1 * f2)\nprint(f1 / f2)\nAnd here is the output:\n1/2 (0.5)\n1/4 (0.25)\n3/4 (0.75)\n1/4 (0.25)\n1/8 (0.125)\n2/1 (2.0)",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Operator Overloading"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/08 Inheritance.html",
    "href": "lessons/02 Object Oriented Programming/08 Inheritance.html",
    "title": "CSC 131",
    "section": "",
    "text": "As you know, the object-oriented paradigm attempts to mimic the real world, particularly in how it is made up of objects that interact with each other. In the real world, objects also have relationships, and this is useful! For example, a person inherits traits from parents. Specifically, a person inherits physical traits (e.g., height, hair color, etc) and behavioral traits (e.g., manner of speaking). This behavior is represented in the object-oriented paradigm as well.\nTo illustrate how this is done, let’s consider the application that models vehicle traffic described earlier. Let’s begin with the car class that serves as the blueprint for a car in the traffic simulation. What might its state and behavior look like? That is, what are cars made up of? What can they be, and what can they do? Very quickly, we can think of attributes such as year, make, model, mileage, and so on. This represents the state of a car. We can also think of behaviors such as start, move, turn, park, and so on. In fact, we could quickly design a car class now that we know how to do so in Python!\nNow let’s consider a pickup truck class that serves as the blueprint for a pickup truck in the traffic simulation. Its state would most likely be very similar to that of the car class. And so would its behavior. In fact, not much differentiates a car from a pickup truck. They both generally have the same attributes and do the same thing. Imagine designing the classes for a car and a pickup truck. You may think that the classes would share many similarities in both state and behavior (and you would be right).\nNow imagine maintaining such an application. Suppose that the implementation of some behavior that is similar across cars and pickup trucks needs to be modified. This would require changing both the car and pickup truck classes because code is duplicated across the two classes. Dealing with this type of thing increases the likelihood of bugs. The beauty of the object-oriented paradigm is that it allows the inheritance of state and behavior from class-to-class, just like we inherit traits from our ancestors!\nThe state and behavior that is shared among the car and pickup truck classes in the traffic simulation application could be captured in a more general class. Such a class could, for example, be called a Vehicle. All of the state and behavior that is shared among any type of vehicle would be defined in this class. Specific kinds of vehicles (like cars and pickup trucks) would then inherit these traits. Any modifications to the state and behavior of vehicles of all types could be made in the vehicle class and be automatically applied to all types of vehicles!\nIn fact, let’s amend the class diagram shown earlier by including a vehicle class that defines the overall state and behavior that all types of vehicles (cars, pickup trucks, buses, tractor trailers, and motorcycles) share: \nNote how all of the classes that inherit state and behavior from the vehicle class now have solid arrows pointing toward the vehicle class. In a class diagram, this indicates an inheritance relationship. Specifically, the car, pickup truck, and other classes shown at the bottom of the class diagram inherit state and behavior from the vehicle class.\n\n\n\n\n\n\nDefinition\n\n\n\nA class that defines state and behavior that is inherited by other classes is called a superclass. The classes that inherit from it are called subclasses.\n\n\nIn the class diagram above, the class Vehicle is a superclass of the class Car, and the class Car is a subclass of the class Vehicle.\nThe inheritance relationship is often called the is-a relationship. This is actually quite clear from the class diagram: a Car is a Vehicle, a Bus is a Vehicle, and so on. There is also the has-a relationship. This represents a composition relationship and refers to the state of an object. Specifically, we often note the has-a relationship in class diagrams for classes that contain other classes.\nIn terms of how this is accomplished in Python source code, we merely need to specify the superclass in a subclass’ class definition. For example, consider the class Car (which is a subclass of the superclass Vehicle). To note this relationship in Python, we merely need to define the Car class as follows:\nclass Car(Vehicle):\n    ...\nThis establishes the relationship that the class Car is a subclass of the class Vehicle, and that the class Vehicle is a superclass of the class Car.\nNext, consider an engine class that defines everything that an engine can be and do. Clearly, a car has an engine. So does a pickup truck, a bus, a motorcycle, and so on. In general, all of these vehicles have an engine. Since all vehicles have an engine, in the design of the application we may include the engine class as part of the state of the vehicle class. Specifically, we would include an instance of the engine class in the vehicle class. All subclasses of the vehicle class would then inherit this attribute. We note the has-a relationship in a class diagram with a dashed arrow that point toward the composed class. Here is an amended class diagram that now includes the engine class:\n\n\n\n\n\nThis important relationship illustrates that objects can, in fact, create other objects! In the example above, a vehicle can create an instance of an engine. Although the state and behavior of all vehicles is defined in the vehicle class, nothing stops any of its subclasses from redefining or specializing these attributes or behaviors. That is, although a car and a motorcycle both have an engine, they are quite different. Simply because the engine class is included in the vehicle class does not prevent a car or a motorcycle from specializing the engine and uniquely setting its state.\nLet’s further illustrate the concept of inheritance by expanding the world of vehicles. In this expanded world, there are two types of vehicles: land vehicles (that move on land) and air vehicles (that fly in the air). The types of land vehicles that exist include all of the vehicles described earlier (e.g., cars, pickup trucks, etc), and the types of air vehicles that exist include airplanes, helicopters, and ultralights. While we’re at it, let’s define multiple types of engines for land vehicles (e.g., V-6, V-8, and I-6), and multiple types of engines for air vehicles (e.g., turbo prop and jet engine).\nTry to represent this expanded world with a class diagram.\nOften, we include the state and behavior of classes in the class diagram. Suppose that the class LandVehicle has the instance variables year, make, and model, and the functions start, stop.\n\n\n\n\n\nTypically, we include the types of instance variables and adhere to the following format:\nvariable_name : variable_type\nFor functions, we include the names and types of any parameters and adhere to the following format:\nfunction_name(parameter1_name : parameter1_type, ...)\nYou have probably noticed that this extension of class diagrams makes it quite easy to implement the source code for the class!",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Inheritance"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/08 Inheritance.html#inheritance",
    "href": "lessons/02 Object Oriented Programming/08 Inheritance.html#inheritance",
    "title": "CSC 131",
    "section": "",
    "text": "As you know, the object-oriented paradigm attempts to mimic the real world, particularly in how it is made up of objects that interact with each other. In the real world, objects also have relationships, and this is useful! For example, a person inherits traits from parents. Specifically, a person inherits physical traits (e.g., height, hair color, etc) and behavioral traits (e.g., manner of speaking). This behavior is represented in the object-oriented paradigm as well.\nTo illustrate how this is done, let’s consider the application that models vehicle traffic described earlier. Let’s begin with the car class that serves as the blueprint for a car in the traffic simulation. What might its state and behavior look like? That is, what are cars made up of? What can they be, and what can they do? Very quickly, we can think of attributes such as year, make, model, mileage, and so on. This represents the state of a car. We can also think of behaviors such as start, move, turn, park, and so on. In fact, we could quickly design a car class now that we know how to do so in Python!\nNow let’s consider a pickup truck class that serves as the blueprint for a pickup truck in the traffic simulation. Its state would most likely be very similar to that of the car class. And so would its behavior. In fact, not much differentiates a car from a pickup truck. They both generally have the same attributes and do the same thing. Imagine designing the classes for a car and a pickup truck. You may think that the classes would share many similarities in both state and behavior (and you would be right).\nNow imagine maintaining such an application. Suppose that the implementation of some behavior that is similar across cars and pickup trucks needs to be modified. This would require changing both the car and pickup truck classes because code is duplicated across the two classes. Dealing with this type of thing increases the likelihood of bugs. The beauty of the object-oriented paradigm is that it allows the inheritance of state and behavior from class-to-class, just like we inherit traits from our ancestors!\nThe state and behavior that is shared among the car and pickup truck classes in the traffic simulation application could be captured in a more general class. Such a class could, for example, be called a Vehicle. All of the state and behavior that is shared among any type of vehicle would be defined in this class. Specific kinds of vehicles (like cars and pickup trucks) would then inherit these traits. Any modifications to the state and behavior of vehicles of all types could be made in the vehicle class and be automatically applied to all types of vehicles!\nIn fact, let’s amend the class diagram shown earlier by including a vehicle class that defines the overall state and behavior that all types of vehicles (cars, pickup trucks, buses, tractor trailers, and motorcycles) share: \nNote how all of the classes that inherit state and behavior from the vehicle class now have solid arrows pointing toward the vehicle class. In a class diagram, this indicates an inheritance relationship. Specifically, the car, pickup truck, and other classes shown at the bottom of the class diagram inherit state and behavior from the vehicle class.\n\n\n\n\n\n\nDefinition\n\n\n\nA class that defines state and behavior that is inherited by other classes is called a superclass. The classes that inherit from it are called subclasses.\n\n\nIn the class diagram above, the class Vehicle is a superclass of the class Car, and the class Car is a subclass of the class Vehicle.\nThe inheritance relationship is often called the is-a relationship. This is actually quite clear from the class diagram: a Car is a Vehicle, a Bus is a Vehicle, and so on. There is also the has-a relationship. This represents a composition relationship and refers to the state of an object. Specifically, we often note the has-a relationship in class diagrams for classes that contain other classes.\nIn terms of how this is accomplished in Python source code, we merely need to specify the superclass in a subclass’ class definition. For example, consider the class Car (which is a subclass of the superclass Vehicle). To note this relationship in Python, we merely need to define the Car class as follows:\nclass Car(Vehicle):\n    ...\nThis establishes the relationship that the class Car is a subclass of the class Vehicle, and that the class Vehicle is a superclass of the class Car.\nNext, consider an engine class that defines everything that an engine can be and do. Clearly, a car has an engine. So does a pickup truck, a bus, a motorcycle, and so on. In general, all of these vehicles have an engine. Since all vehicles have an engine, in the design of the application we may include the engine class as part of the state of the vehicle class. Specifically, we would include an instance of the engine class in the vehicle class. All subclasses of the vehicle class would then inherit this attribute. We note the has-a relationship in a class diagram with a dashed arrow that point toward the composed class. Here is an amended class diagram that now includes the engine class:\n\n\n\n\n\nThis important relationship illustrates that objects can, in fact, create other objects! In the example above, a vehicle can create an instance of an engine. Although the state and behavior of all vehicles is defined in the vehicle class, nothing stops any of its subclasses from redefining or specializing these attributes or behaviors. That is, although a car and a motorcycle both have an engine, they are quite different. Simply because the engine class is included in the vehicle class does not prevent a car or a motorcycle from specializing the engine and uniquely setting its state.\nLet’s further illustrate the concept of inheritance by expanding the world of vehicles. In this expanded world, there are two types of vehicles: land vehicles (that move on land) and air vehicles (that fly in the air). The types of land vehicles that exist include all of the vehicles described earlier (e.g., cars, pickup trucks, etc), and the types of air vehicles that exist include airplanes, helicopters, and ultralights. While we’re at it, let’s define multiple types of engines for land vehicles (e.g., V-6, V-8, and I-6), and multiple types of engines for air vehicles (e.g., turbo prop and jet engine).\nTry to represent this expanded world with a class diagram.\nOften, we include the state and behavior of classes in the class diagram. Suppose that the class LandVehicle has the instance variables year, make, and model, and the functions start, stop.\n\n\n\n\n\nTypically, we include the types of instance variables and adhere to the following format:\nvariable_name : variable_type\nFor functions, we include the names and types of any parameters and adhere to the following format:\nfunction_name(parameter1_name : parameter1_type, ...)\nYou have probably noticed that this extension of class diagrams makes it quite easy to implement the source code for the class!",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Inheritance"
    ]
  },
  {
    "objectID": "lessons/02 Object Oriented Programming/03 Representing State and Behavior.html",
    "href": "lessons/02 Object Oriented Programming/03 Representing State and Behavior.html",
    "title": "Representing State and Behavior",
    "section": "",
    "text": "Objects store their state in instance variables.\n\n\n\n\n\n\nDefinition\n\n\n\nAn instance variable is a variable defined within a class. Each object can have a different value for their copy of the instance variable.\n\n\nFor example, a truck class could define the variable year to represent the year a truck was manufactured. A specific truck object (or instance) would set this variable to the year of its manufacture. In Python, this would be done with a simple assignment statement. If, for example, the truck object were manufactured in 2016, then the statement year = 2016 would appropriately set the truck’s year of manufacture. Another truck object could have a different year of manufacture. Ultimately, the class defines instance variables; however, each object stores its own unique set of values. There are certain attributes that all instances of a class may want to share. Consider a class that defines a person. Although each instance/object of the person class can be different and thus have unique values stored in its instance variables (e.g., different sex, name, age, etc), all persons are Homo sapiens. All persons share this scientific name. In fact, if an expert in the field were to rename (or perhaps refine) the term Homo sapiens to something else, this would change for all persons, effectively at the same time. This kind of behavior can also be replicated in the object-oriented paradigm.\n\n\n\n\n\n\nDefinition\n\n\n\nA class variable defines a value that is shared among all the instances of a class.\n\n\nUnlike instance variables that, when changed, only affect a single object, a change in a class variable affects all instances of a class simultaneously. Essentially, a class variable is stored in memory that is shared among all the instances of a class.\nThe behavior of objects is defined in methods (or functions) that can be invoked. For example, the turn behavior of a truck could be defined in a function called turn. If necessary, this function could take parameters as input and return some sort of output.\nUltimately, a class has source code that specifies its state (through instance variables) and behavior (through methods).\n\n\n\n\n\n\nDefinition\n\n\n\nCollectively, state and behavior are referred to as the members of a class.\n\n\nLet’s take a look at a simple example of a dog class in Python. For this example, a dog only has a name, and all dogs are canines.\n1:  class Dog:\n2:      kind = \"canine\"\n3:      def __init__(self, dog_name):\n4:          self.name = dog_name\nLine 1 represents the class header, which includes the Python keyword class and the name of the class (in this case, Dog). Class headers are terminated with a colon, much like function headers. It is typical to capitalize the names of classes. Moreover, class names should always be singular nouns since they define the blueprint for a single thing\nLine 2 defines a class variable named kind that is initialized with the string “canine”. This value is shared among all dogs. The reason that we consider kind to be a class variable is that it is defined inside the class but outside any methods that are in the class. That is, class variables are defined at the class level.\nLines 3 and 4 represent a function called __init__. In Python, functions that begin and end with two underscores have special meaning. In fact, they are called magic functions.\n\n\n\n\n\n\n\nDid you know\n\n\n\nSome people refer to these are “dunder” methods due to the double underscores used to denote them\n\n\n\n\n\n\n\nDefinition\n\n\n\nMagic functions are functions in Python that have special meaning. They are normally called automatically by Python in the right situations (sometimes we call them explicitly). They have two underscores before and two underscores after the name of the function. There are several magic functions in Python that we can use and declare.\n\n\nThe __init__ function provides an initialization procedure for each instance of the class. That is, the source code contained within this method effectively defines what it means to initialize a new instance of the class. When we want new instances of the dog class, this function is automatically invoked (since it is a magic function). Formally, this type of function is called a constructor.\n\n\n\n\n\n\nDefinition\n\n\n\nA constructor contains the source code required to construct a new instance of a class. A constructor is automatically invoked each time we create an instance of a class. Its purpose is to initialize the object, which typically means to set default values for one or more of the instance variables (e.g. we don’t have to initialize them all). These initial values may come from parameters of the constructor or we can give the instance variable a value ourselves (such as initializing a variable to 0 or 1).\n\n\nIn the dog class above, the constructor takes two parameters: self and dog_name. The first parameter represents the instance that is about to be instantiated. This parameter is always required! The second parameter represents the name of this new dog (e.g., Bosco). The function header indicates that, to create a new instance of the dog class, a dog name must be provided. Line 4 then sets the instance variable name for the object to be created. Note that self.name (on the left side of the assignment statement) represents the instance variable (called name) for the dog class, and specifically targets this dog instance’s name (via self.name). The dot in between self and name is called the dot operator and will be covered shortly. The variable dog_name (on the right side of the assignment statement) is passed in to the function when a new instance of a dog is desired.\nInstances of the dog class can be created as we need them. This typically occurs outside of the dog class (for example, in a program that requires dog objects to interact with each other). Objects that are instances of the dog class can be easily instantiated as follows:\n5:  d1 = Dog(\"Maya\")\n6:  d2 = Dog(\"Biff\")\nLine 5 declares a variable, d1, that represents an instance of the dog class. Specifically, d1 is a dog whose name is “Maya”. Line 6 defines a variable, d2, that represents another instance of the dog class. Specifically, d2 is a dog whose name is “Biff”\nWhen line 5 is executed, the variable d1 is mapped to the variable self in the __init__ function (constructor) of the dog class. The variable self is a formal parameter. The variable d1 is the actual parameter that is mapped to the formal parameter. Similarly, the string “Maya” (actual parameter) is mapped to the variable dog_name (formal parameter). The statement self.name = dog_name ultimately sets the instance variable name for this instance of the dog class to whatever was passed in as the variable dog_name (i.e., Maya in this case).\nFormally, the variable d1 is called an object reference. That is, it refers to an object (or instance) of the dog class. The variable d2 is also an object reference of the dog class. We can access the members of a class by using the dot operator. For example, we could change the name of d1 to Bosco as follows:\nd1.name = \"Bosco\"\nThe above example shows how to modify an instance variable. Note that it only changes the name of d1 and not d2 because the specified object reference is d1. Simply accessing (without changing) a member of a class is just as easy; for example:\nprint(d2.name)\nThis statement would produce the output Biff (because d2’s name is Biff). In fact, let’s list the state of each instance of the class dog, d1 and d2 (note that this is not Python source code; rather, it is an enumeration of the instance variables and their associated values for the objects d1 and d2):\nd1.name → Bosco\nd2.name → Biff\nd1.kind → canine\nd2.kind → canine\nYou have actually seen (and used) the dot operator before. Consider the following statements:\nname = \"Joe\"\nwelcome_string = \"Hello, {}\"\nprint(welcome_string.format(name))\nFrom these statements, we can infer that strings (specifically the string welcome_string in the example above) are objects! In addition, the function format must be a member of the string class since it can be accessed using the dot operator! In fact, the function format is part of the behavior of the string class. This function takes one or more parameters that replace the empty braces in the string.\n\n\n\n\n\n\n\n\n\n\nDid you know\n\n\n\nIn Python, instance variables don’t need to be formally declared in the class. That is, they can be defined as needed, dynamically. For example, although the dog class doesn’t yet specify an instance variable that defines a dog’s breed, the following statement in the main part of the program effectively adds the instance variable breed. It only adds it to the specific instance, though, as other instances will not have breed added to them. Specifically, it sets d1’s breed to German Shepherd:\nd1.breed = \"German Shepherd\"\nIt is standard practice, however, to formally define all instance variables in the class. This will be further discussed later.",
    "crumbs": [
      "Lessons",
      "02 Object Oriented Programming",
      "Representing State and Behavior"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/index.html",
    "href": "lessons/03 Number Systems and Binary Arithmetic/index.html",
    "title": "03 Number Systems and Binary Arithmetic",
    "section": "",
    "text": "In this lesson, we will cover a variety of topics concerning Object Oriented Programming and implement object oriented programs in Python.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/index.html#overview",
    "href": "lessons/03 Number Systems and Binary Arithmetic/index.html#overview",
    "title": "03 Number Systems and Binary Arithmetic",
    "section": "",
    "text": "In this lesson, we will cover a variety of topics concerning Object Oriented Programming and implement object oriented programs in Python.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/index.html#contents",
    "href": "lessons/03 Number Systems and Binary Arithmetic/index.html#contents",
    "title": "03 Number Systems and Binary Arithmetic",
    "section": "Contents",
    "text": "Contents\n\nIntroduction\nBinary\nHexadecimal\nConversions\nBinary Arithmetic\nBinary Adder\nBitwise Operators",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/04 Conversions.html",
    "href": "lessons/03 Number Systems and Binary Arithmetic/04 Conversions.html",
    "title": "CSC 131",
    "section": "",
    "text": "Now that we have reviewed the concept of number systems and the idea of counting in a variety of bases, let’s look more carefully at what exactly a numeric “base” is. As you learned long ago in grade school, 123 is the way we normally write the number one hundred twenty-three. This is because the “1” is in the hundreds place, the “2” is in the tens place, and the “3” is in the ones place. That is, the digits are positional. Each digit is multiplied by the value of its position (think of this as a weight for each digit position), and the results are then added together. Consider the following way of breaking down the number 123:\n\nThe system we normally use for representing numbers is called the decimal number system. In this system, the rightmost digit is referred to as being in the one’s or “units” position. Immediately to the left of the units position is the ten’s position. To the left of the ten’s position is the hundred’s position, then the thousand’s, then the ten thousand’s, and so on. The decimal number system is a “base ten” positional number system, because the value of each position can be expressed as a power of the number ten.\nThe exponent that the base is raised to is given by the position minus one. The right-most position (i.e., position 1), or units position, is 100. Note that anything to the power of zero is equal to 1. This right-most position is also known as the least significant position or digit (since it is represented by the lowest power of 10). The tens position is 101, the hundreds is 102, the thousands is 103, and so on. The value of each position is exactly ten times the value of the position immediately to its right.\nThe other bases work similarly. In the binary number system, the base is two; therefore, the values of the positions (given from right to left) are one (20), two (21), four (22), eight (23), sixteen (24), thirty-two (25), and so on. The value of each position in a base two system is two times the value of the position immediately to its right. For example, the number five is represented in base two as 1012 (since there is a one in the four’s position and a one in the units position). This is illustrated below:\n\n\nIn the hexadecimal number system, the base is sixteen. Therefore, the values of the positions (again from right to left) are one (160), sixteen (161), two hundred fifty-six (162), four thousand ninety-six (163), and so on. The value of each position in this system is exactly sixteen times the value of the position immediately to its right. The value of the base sixteen number 1A316 is four hundred nineteen, since there is one in the two hundred and fifty six’s position, ten in the sixteen’s position, and three in the units position. This is illustrated below:\n\nHere’s one more example illustrating the representation of the number “nineteen ninety nine” in all three of the bases we have discussed; first, in base ten:\n\nNow, in base two:\n\n\nAnd finally, in base sixteen:\n\nOne of the most common tasks we face when working with multiple bases is converting numbers from one base to another. We have already seen how to convert from base sixteen and base two to base ten: simply multiply the value of each symbol by the value of its position and add the results together. But how do we convert from base ten to base sixteen or to base two? We also need to figure out how to convert from base two to base sixteen and from base sixteen to base two.\nConverting from base two to base sixteen and from base sixteen to base two is easy. In fact, the only reason computer scientists even use base sixteen is because it serves as convenient “shorthand” for base two. The following illustrates the fact that each base sixteen digit can be represented by a group of exactly four base two digits:\n\n\n\nBase 16 (hexadecimal)\nBase 2 (binary)\n\n\n\n\n0\n00000\n\n\n1\n00001\n\n\n2\n00010\n\n\n3\n00011\n\n\n4\n00100\n\n\n5\n00101\n\n\n6\n00110\n\n\n7\n00111\n\n\n8\n01000\n\n\n9\n01001\n\n\nA\n01010\n\n\nB\n01011\n\n\nC\n01100\n\n\nD\n01101\n\n\nE\n01110\n\n\nF\n01111\n\n\n\nTo convert from base sixteen to base two, simply replace each base sixteen digit with its corresponding group of four binary digits. For example, the rather imposing hexadecimal number 1AFC316 can easily be converted its binary representation as illustrated below:\n\nTherefore, 1AFC316 = 110101111110000112. Note that leading zeros have been removed as they are not necessary.\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to convert FACE16 to base two.\nNow try to convert 4B1D16 to base two.\n\n\n\nConverting from base two to base sixteen is just as straightforward. We scan the base two number from right to left, replacing each group of four binary digits that we encounter with the equivalent hexadecimal digit. It is important that we group the digits of the base two representation from right to left, in case the number of digits is not evenly divisible by four. If this occurs, we simply add leading zeros until the number of digits is divisible by four. Conversion of the bit pattern 111110011112 to its hexadecimal representation is shown below:\n\nThe original bit pattern, 11111001111, was first broken down from right-to-left into groups of four, and a leading zero was added to the left-most group: 0111 1100 1111. Ultimately, 111110011112 = 7CF16.\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to convert 11110000000011012 to hexadecimal.\nTry to convert 111011110101001012 to hexadecimal.\n\n\n\nNote that these conversions between binary and hexadecimal representations in no way change the actual number being represented. For example, 7CF16 and 111110011112 both refer to the same number (1,999), as was illustrated earlier.\nWe have now looked at conversion methods from base two (and base sixteen) to base ten, from base sixteen to base two, and from base two to base sixteen. The only conversions that we have yet to cover are from base ten to base sixteen and from base ten to base two. We really only need to look at the base ten to base two conversion, since conversion between base two and base sixteen is so trivial. If you have a base ten number and want its base sixteen representation, you can apply a decimal to binary conversion algorithm, and then change the base two result to its base sixteen representation via the grouping method described above.\nA number can be converted from decimal to binary by subtracting from it the largest power of two that is less than or equal to the number, and repeating until a remainder of zero is reached. The binary representation of the number is then formed by placing a “1” in the positions corresponding to each of the powers of two that were subtracted. A “0” is placed in the positions corresponding to the powers of two that were not subtracted.\nFor example, take the decimal number 37. The largest power of two that can be subtracted from it is 32 (25), which leaves five. The largest power of two that can be subtracted from 5 is 4 (22), which leaves one. Finally, the largest power of two that can be subtracted from 1 is 1 (20), which leaves zero. The base two representation of the number is thus formed by placing a “1” in the thirty-two’s, four’s, and units positions, and by placing a “0” in all other positions. This gives 1001012. The conversion process for this number is illustrated below:\n\n\nAnother method of converting from decimal to binary is to divide the decimal number in half and record both the quotient and the remainder. We then repeat this process with the quotient, while keeping track of the remainder of each division. This is repeated until the quotient is zero. The binary equivalent of the original number is subsequently given by listing the remainders in the reverse order of their derivation (i.e., from the most recent remainder to the first remainder). Here’s this method on the decimal number 37:\n\nListing the remainders in reverse order gives 100101 (the same as in the previous example). Therefore, 3710 = 1001012.\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to convert the decimal number 642 to base two.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Conversions"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/04 Conversions.html#number-system-conversion",
    "href": "lessons/03 Number Systems and Binary Arithmetic/04 Conversions.html#number-system-conversion",
    "title": "CSC 131",
    "section": "",
    "text": "Now that we have reviewed the concept of number systems and the idea of counting in a variety of bases, let’s look more carefully at what exactly a numeric “base” is. As you learned long ago in grade school, 123 is the way we normally write the number one hundred twenty-three. This is because the “1” is in the hundreds place, the “2” is in the tens place, and the “3” is in the ones place. That is, the digits are positional. Each digit is multiplied by the value of its position (think of this as a weight for each digit position), and the results are then added together. Consider the following way of breaking down the number 123:\n\nThe system we normally use for representing numbers is called the decimal number system. In this system, the rightmost digit is referred to as being in the one’s or “units” position. Immediately to the left of the units position is the ten’s position. To the left of the ten’s position is the hundred’s position, then the thousand’s, then the ten thousand’s, and so on. The decimal number system is a “base ten” positional number system, because the value of each position can be expressed as a power of the number ten.\nThe exponent that the base is raised to is given by the position minus one. The right-most position (i.e., position 1), or units position, is 100. Note that anything to the power of zero is equal to 1. This right-most position is also known as the least significant position or digit (since it is represented by the lowest power of 10). The tens position is 101, the hundreds is 102, the thousands is 103, and so on. The value of each position is exactly ten times the value of the position immediately to its right.\nThe other bases work similarly. In the binary number system, the base is two; therefore, the values of the positions (given from right to left) are one (20), two (21), four (22), eight (23), sixteen (24), thirty-two (25), and so on. The value of each position in a base two system is two times the value of the position immediately to its right. For example, the number five is represented in base two as 1012 (since there is a one in the four’s position and a one in the units position). This is illustrated below:\n\n\nIn the hexadecimal number system, the base is sixteen. Therefore, the values of the positions (again from right to left) are one (160), sixteen (161), two hundred fifty-six (162), four thousand ninety-six (163), and so on. The value of each position in this system is exactly sixteen times the value of the position immediately to its right. The value of the base sixteen number 1A316 is four hundred nineteen, since there is one in the two hundred and fifty six’s position, ten in the sixteen’s position, and three in the units position. This is illustrated below:\n\nHere’s one more example illustrating the representation of the number “nineteen ninety nine” in all three of the bases we have discussed; first, in base ten:\n\nNow, in base two:\n\n\nAnd finally, in base sixteen:\n\nOne of the most common tasks we face when working with multiple bases is converting numbers from one base to another. We have already seen how to convert from base sixteen and base two to base ten: simply multiply the value of each symbol by the value of its position and add the results together. But how do we convert from base ten to base sixteen or to base two? We also need to figure out how to convert from base two to base sixteen and from base sixteen to base two.\nConverting from base two to base sixteen and from base sixteen to base two is easy. In fact, the only reason computer scientists even use base sixteen is because it serves as convenient “shorthand” for base two. The following illustrates the fact that each base sixteen digit can be represented by a group of exactly four base two digits:\n\n\n\nBase 16 (hexadecimal)\nBase 2 (binary)\n\n\n\n\n0\n00000\n\n\n1\n00001\n\n\n2\n00010\n\n\n3\n00011\n\n\n4\n00100\n\n\n5\n00101\n\n\n6\n00110\n\n\n7\n00111\n\n\n8\n01000\n\n\n9\n01001\n\n\nA\n01010\n\n\nB\n01011\n\n\nC\n01100\n\n\nD\n01101\n\n\nE\n01110\n\n\nF\n01111\n\n\n\nTo convert from base sixteen to base two, simply replace each base sixteen digit with its corresponding group of four binary digits. For example, the rather imposing hexadecimal number 1AFC316 can easily be converted its binary representation as illustrated below:\n\nTherefore, 1AFC316 = 110101111110000112. Note that leading zeros have been removed as they are not necessary.\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to convert FACE16 to base two.\nNow try to convert 4B1D16 to base two.\n\n\n\nConverting from base two to base sixteen is just as straightforward. We scan the base two number from right to left, replacing each group of four binary digits that we encounter with the equivalent hexadecimal digit. It is important that we group the digits of the base two representation from right to left, in case the number of digits is not evenly divisible by four. If this occurs, we simply add leading zeros until the number of digits is divisible by four. Conversion of the bit pattern 111110011112 to its hexadecimal representation is shown below:\n\nThe original bit pattern, 11111001111, was first broken down from right-to-left into groups of four, and a leading zero was added to the left-most group: 0111 1100 1111. Ultimately, 111110011112 = 7CF16.\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to convert 11110000000011012 to hexadecimal.\nTry to convert 111011110101001012 to hexadecimal.\n\n\n\nNote that these conversions between binary and hexadecimal representations in no way change the actual number being represented. For example, 7CF16 and 111110011112 both refer to the same number (1,999), as was illustrated earlier.\nWe have now looked at conversion methods from base two (and base sixteen) to base ten, from base sixteen to base two, and from base two to base sixteen. The only conversions that we have yet to cover are from base ten to base sixteen and from base ten to base two. We really only need to look at the base ten to base two conversion, since conversion between base two and base sixteen is so trivial. If you have a base ten number and want its base sixteen representation, you can apply a decimal to binary conversion algorithm, and then change the base two result to its base sixteen representation via the grouping method described above.\nA number can be converted from decimal to binary by subtracting from it the largest power of two that is less than or equal to the number, and repeating until a remainder of zero is reached. The binary representation of the number is then formed by placing a “1” in the positions corresponding to each of the powers of two that were subtracted. A “0” is placed in the positions corresponding to the powers of two that were not subtracted.\nFor example, take the decimal number 37. The largest power of two that can be subtracted from it is 32 (25), which leaves five. The largest power of two that can be subtracted from 5 is 4 (22), which leaves one. Finally, the largest power of two that can be subtracted from 1 is 1 (20), which leaves zero. The base two representation of the number is thus formed by placing a “1” in the thirty-two’s, four’s, and units positions, and by placing a “0” in all other positions. This gives 1001012. The conversion process for this number is illustrated below:\n\n\nAnother method of converting from decimal to binary is to divide the decimal number in half and record both the quotient and the remainder. We then repeat this process with the quotient, while keeping track of the remainder of each division. This is repeated until the quotient is zero. The binary equivalent of the original number is subsequently given by listing the remainders in the reverse order of their derivation (i.e., from the most recent remainder to the first remainder). Here’s this method on the decimal number 37:\n\nListing the remainders in reverse order gives 100101 (the same as in the previous example). Therefore, 3710 = 1001012.\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to convert the decimal number 642 to base two.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Conversions"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/02 Binary.html",
    "href": "lessons/03 Number Systems and Binary Arithmetic/02 Binary.html",
    "title": "CSC 131",
    "section": "",
    "text": "Today, virtually all civilizations use a base ten counting system. However, this has not always been so. In primitive tally systems, for example, there is one stroke for each object being counted. For example, the following tally pattern represents twelve:\n\nSome tally systems group strokes together. The one illustrated above places five strokes in each group. Most early systems attached little or no meaning to the order of the symbols used to represent a number. Roman numerals did use position, but only to indicate whether one value should be added to or subtracted from another value. For example, the Roman numeral MMC stands for 2,100, because “M” represents one thousand, “C” represents one hundred, and the positional rule states that when the symbols are arranged in order of decreasing value, all of the values should be added together. Hence, the meaning of MMC is \\(1,000 + 1,000 + 100 = 2,100\\). On the other hand, MCM means 1,900, because the positional rules states that when a symbol for a smaller value immediately precedes a symbol for a larger value, the smaller value is to be subtracted from the larger value. So, MCM is \\(1,000 + (1,000 – 100) = 1,900\\). The year 1999 as a Roman numeral is written MCMXCIX, meaning \\(1,000 + (1,000 – 100) + (100 – 10) + (10 – 1)\\).\nPositional notation truly became useful only after the zero digit was introduced. Our modern decimal number system is a base ten positional system. It uses the ten symbols “0” through “9.” We count by sequencing through these symbols: “0” for zero, “1” for one, “2” for two, and so on. Once the last symbol is encountered (i.e., “9”), how do we represent the next number? What we need to do is replace the current symbol, “9”, with the first symbol in the series, “0”, and then increment the symbol immediately to the left of the current symbol by one. Since base ten numbers are assumed to be preceded by (usually unwritten) 0’s, the number nine can be written as “09.” Hence, cycling “9” back to “0” and incrementing the leftmost “0” to “1” gives “10” as the base ten symbol for the number ten. To continue counting, we cycle the rightmost digit through the symbols “0” through “9” again, producing “10” through “19” for the numbers ten through nineteen. The number twenty can be represented by resetting the “9” to “0” and replacing the “1” with the next symbol in the sequence, “2”, giving “20.” If we extend this to, say “99,” the idea is still the same. The next number, “100,” is obtained in the same manner. We first reset the “9” in the right-most digit to “0.” We then attempt to increment the next digit (also “9”), but it, too, is at the end of the sequence. Therefore, we reset it to “0” as well, and increment the left-most “0” to “1,” giving “100.”\nComputer systems use base two, or binary, instead of base ten. Counting in binary is similar to counting in base ten. We still cycle through the sequence of symbols, incrementing the symbol to the left of the current symbol whenever the current symbol cycles back to the beginning of the sequence. The only difference is that instead of ten symbols, there are only two symbols: “0” and “1” (hence why it is called the binary number system). We begin counting by sequencing through these symbols: “0” for zero, “1” for one, and then we have reached the symbol with the largest value. Keeping in mind that the number one can be rewritten as “01,” we reset the rightmost symbol, “1”, to the first symbol in the sequence, “0”, and then increment the implied “0” immediately to the left to “1” giving “10” (the base two symbol for two).\nNote carefully that the symbol “10” (pronounced “one zero”) when interpreted as a base two number refers to the number two, not ten. When discussing base two values you should never refer to the symbol “10” as “ten” since that is not the value of the number represented by this symbol.\nContinuing with the example, the next number, three, can be represented in base two as “11” (we simply increment the right-most digit of “10” from “0” to “1”). To generate the base two representation of four, we begin with three represented as “011” (remember that it is fine to add 0’s to the left-hand side of a number symbol). Next, we set the rightmost “1” digit back to “0” and attempt to increment the middle digit. However, that digit is also at the end of the sequence, since it contains a “1.” So, we reset this digit to “0” as well and proceed to the third (leftmost) digit, which we increment from “0” to “1.” The final result is “100,” which is the base two representation of the number four.\nThis process for generating base two numbers can be continued indefinitely. The base ten (decimal) and base two (binary) representations of the numbers zero through eight are shown below. For readability, binary numbers are padded to the left with zeros):\n\n\n\nBase 10 (decimal)\nBase 2 (binary)\n\n\n\n\n0\n0000\n\n\n1\n0001\n\n\n2\n0010\n\n\n3\n0011\n\n\n4\n0100\n\n\n5\n0101\n\n\n6\n0110\n\n\n7\n0111\n\n\n8\n1000\n\n\n\nOf course, we will need to develop a fast way to find out the number represented by a base two symbol (instead of “counting up to it”). However, before we leave the notion of counting, let’s investigate one other base that is commonly used when discussing programs and data at the machine level.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Binary"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/02 Binary.html#the-binary-number-system",
    "href": "lessons/03 Number Systems and Binary Arithmetic/02 Binary.html#the-binary-number-system",
    "title": "CSC 131",
    "section": "",
    "text": "Today, virtually all civilizations use a base ten counting system. However, this has not always been so. In primitive tally systems, for example, there is one stroke for each object being counted. For example, the following tally pattern represents twelve:\n\nSome tally systems group strokes together. The one illustrated above places five strokes in each group. Most early systems attached little or no meaning to the order of the symbols used to represent a number. Roman numerals did use position, but only to indicate whether one value should be added to or subtracted from another value. For example, the Roman numeral MMC stands for 2,100, because “M” represents one thousand, “C” represents one hundred, and the positional rule states that when the symbols are arranged in order of decreasing value, all of the values should be added together. Hence, the meaning of MMC is \\(1,000 + 1,000 + 100 = 2,100\\). On the other hand, MCM means 1,900, because the positional rules states that when a symbol for a smaller value immediately precedes a symbol for a larger value, the smaller value is to be subtracted from the larger value. So, MCM is \\(1,000 + (1,000 – 100) = 1,900\\). The year 1999 as a Roman numeral is written MCMXCIX, meaning \\(1,000 + (1,000 – 100) + (100 – 10) + (10 – 1)\\).\nPositional notation truly became useful only after the zero digit was introduced. Our modern decimal number system is a base ten positional system. It uses the ten symbols “0” through “9.” We count by sequencing through these symbols: “0” for zero, “1” for one, “2” for two, and so on. Once the last symbol is encountered (i.e., “9”), how do we represent the next number? What we need to do is replace the current symbol, “9”, with the first symbol in the series, “0”, and then increment the symbol immediately to the left of the current symbol by one. Since base ten numbers are assumed to be preceded by (usually unwritten) 0’s, the number nine can be written as “09.” Hence, cycling “9” back to “0” and incrementing the leftmost “0” to “1” gives “10” as the base ten symbol for the number ten. To continue counting, we cycle the rightmost digit through the symbols “0” through “9” again, producing “10” through “19” for the numbers ten through nineteen. The number twenty can be represented by resetting the “9” to “0” and replacing the “1” with the next symbol in the sequence, “2”, giving “20.” If we extend this to, say “99,” the idea is still the same. The next number, “100,” is obtained in the same manner. We first reset the “9” in the right-most digit to “0.” We then attempt to increment the next digit (also “9”), but it, too, is at the end of the sequence. Therefore, we reset it to “0” as well, and increment the left-most “0” to “1,” giving “100.”\nComputer systems use base two, or binary, instead of base ten. Counting in binary is similar to counting in base ten. We still cycle through the sequence of symbols, incrementing the symbol to the left of the current symbol whenever the current symbol cycles back to the beginning of the sequence. The only difference is that instead of ten symbols, there are only two symbols: “0” and “1” (hence why it is called the binary number system). We begin counting by sequencing through these symbols: “0” for zero, “1” for one, and then we have reached the symbol with the largest value. Keeping in mind that the number one can be rewritten as “01,” we reset the rightmost symbol, “1”, to the first symbol in the sequence, “0”, and then increment the implied “0” immediately to the left to “1” giving “10” (the base two symbol for two).\nNote carefully that the symbol “10” (pronounced “one zero”) when interpreted as a base two number refers to the number two, not ten. When discussing base two values you should never refer to the symbol “10” as “ten” since that is not the value of the number represented by this symbol.\nContinuing with the example, the next number, three, can be represented in base two as “11” (we simply increment the right-most digit of “10” from “0” to “1”). To generate the base two representation of four, we begin with three represented as “011” (remember that it is fine to add 0’s to the left-hand side of a number symbol). Next, we set the rightmost “1” digit back to “0” and attempt to increment the middle digit. However, that digit is also at the end of the sequence, since it contains a “1.” So, we reset this digit to “0” as well and proceed to the third (leftmost) digit, which we increment from “0” to “1.” The final result is “100,” which is the base two representation of the number four.\nThis process for generating base two numbers can be continued indefinitely. The base ten (decimal) and base two (binary) representations of the numbers zero through eight are shown below. For readability, binary numbers are padded to the left with zeros):\n\n\n\nBase 10 (decimal)\nBase 2 (binary)\n\n\n\n\n0\n0000\n\n\n1\n0001\n\n\n2\n0010\n\n\n3\n0011\n\n\n4\n0100\n\n\n5\n0101\n\n\n6\n0110\n\n\n7\n0111\n\n\n8\n1000\n\n\n\nOf course, we will need to develop a fast way to find out the number represented by a base two symbol (instead of “counting up to it”). However, before we leave the notion of counting, let’s investigate one other base that is commonly used when discussing programs and data at the machine level.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Binary"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/05 Binary Arithmetic.html",
    "href": "lessons/03 Number Systems and Binary Arithmetic/05 Binary Arithmetic.html",
    "title": "CSC 131",
    "section": "",
    "text": "Let’s take a look at how arithmetic operations, such as addition and multiplication, can be performed on binary numbers. First, let’s examine binary addition of single digit numbers. The simplest case is the addition of 0 plus 0. In binary, it is represented as follows:\n\\[0+0=0\\]\nSome prefer to view this vertically as opposed to horizontally as follows:\n\nExtending this, zero plus one and one plus zero both equal one:\n\\[0 + 1 = 1\\]\n\\[1 + 0 = 1\\]\nOr vertically:\n\nFinally, one plus one equals two. But the problem is that two cannot be represented as a single binary digit. Instead, we record a zero in the one’s position and carry a one over to the two’s position. This is represented as follows:\n\\[1 + 1 = 0\\] (carry 1)\nOr vertically:\n\nMulti-digit binary addition uses the same strategy employed in decimal addition. One works right-to-left from the least significant digit to the most significant digit, making sure that the carry from the previous column is added to the current column. Because the carry digit for a particular column may be “1” at the same time the corresponding digits of both of the numbers being added are also “1,” it is possible to encounter “one plus one plus one equals three” while performing addition. Since 112 equals three, “1” should be placed in the current position and another “1” carried over to the position immediately to the left of the current position. This is be represented as follows:\n\\[1 + 1 + 1 = 1\\] (carry 1)\nOr vertically:\n\nLet’s take a look at the addition of 38 + 15 = 53. The following table shows both the binary addition (on the left) and decimal addition (on the right):\n\nAnd now the addition of 43 + 58 = 101:\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry the addition of 50 + 77 = 127.\n\n\n\nBinary multiplication is also fairly simple. Zero times zero equals zero, as does zero times one and one times zero. One times one equals one. These expressions can be represented in base two as follows:\n\\[0 \\times 0 = 0\\] \\[0 \\times 1 = 0\\] \\[1 \\times 0 = 0\\] \\[1 \\times 1 = 1\\]\nNotice that none of these four expressions generate a carry, and only one generates a result other than zero. As we will see later, these features lead to binary multiplication being easy to perform; in fact, even easier to perform than decimal multiplication!\nMultiplication of multi-digit binary numbers works in a manner similar to multiplication of decimal numbers. As we all learned in grade school, multiplication problems are solved by adding together several partial products. A partial product is formed by multiplying a single digit of the bottom number times the entire top number. For example, given the base ten multiplication problem \\(472 \\times 104\\), we would solve it in the following way:\n\nThe first partial product is given by multiplying 4 times 472, which is 1888. The second partial product is computed as 0 times 472, which is 0. Normally we do not write down zero partial products. The final partial product is 1 times 472. Notice that we write this partial product so that its rightmost digit is directly under the digit of the second number that we multiplied by (i.e., 1). We then add the partial products, column by column from right-to-left, in order to obtain the final answer (49,088 in this case).\nWe apply this same strategy to perform binary multiplication. Let’s take a look at the product of \\(19 \\times 5 = 95\\) (in base two: \\(10011_2 \\times 101_2 = 1011111_2\\)):\n\nWe form partial products by multiplying the top number by each of the digits of the bottom number. Since the right-most digit of the second number is 1, the first partial product is given by 1 times 100112, or 100112. The right-most digit of this partial product is aligned with the rightmost digit of the second number. We do not record the partial product for zero times something, so multiplying the first number by the second digit of the second number, 0, doesn’t generate anything. The final partial product is computed as 1 times 10011 again, but this time where the right-most digit of this result is aligned beneath the third digit of the second number. The partial products are then added to obtain the final result, 10111112.\nAs we have just seen, in binary multiplication the formation of the partial products is very easy since we are only multiplying by 1 (in which case we copy the top number into the proper position) or 0 (in which case we do nothing). The only difficult steps in this process are making sure that we align the partial products correctly and compute the sum of those products accurately. Now let’s try a more difficult problem: the product of 143  23 = 3289 (in base two: \\(10001111_2 \\times 10111_2 = 110011011001_2\\))\n\nHere, we copy the top number as a partial product everywhere there is a 1 digit in the second number, each time making sure that we align the partial product so that the least significant digit is directly underneath the 1 we are multiplying by. We get the final result by adding the partial products together.\nWhen adding together the partial products, it is important that we handle the carry values properly. Because there is no limit on the size of the numbers to be multiplied, it is possible that there will be a large number of partial products. This situation can lead to carry values that extend over multiple columns. To illustrate this, consider summing a partial product column of five 1s:\n\nConsidering these separately, we initially add the first two 1s: 1 + 1 = 10. We then add the next one to that sum: 10 + 1 = 11. We then add the next one: 11 + 1 = 100. Finally, we add the last one: 100 + 1 = 101. So, 1 + 1 + 1 + 1 + 1 = 1012. To record this, we write a 1 in the current column and carry 10, placing the 0 in the column immediately to the left of the current column and 1 immediately to the left of that column. This is no different from the situation we encounter when adding up a long series of decimal numbers. If the current column of digits added to one hundred and one, we would place a 1 in the current column, carry a 0 to the previous column, and carry a 1 to the column before that.\nLet’s take a closer look at the summation of the partial products of the previous example (\\(143 \\times 23 = 3289\\)). The right-most column of partial products offers no problem. It is simply 1 plus nothing, giving a result of 1 with no carry. The second column requires us to add 1 + 1 resulting in a 0 with 1 carried over to the third column. Column three is interesting and is illustrated below:\n\nThe sum of the digits in column three, including the carry, is 1 + 1 + 1 + 1 = 1002 = 4. Hence, a 0 is written in column three, a 0 is carried to column four, and a 1 is carried to column five.\nColumn four contains three 1s, giving us a sum of 112. Hence, we write a 1 in column four and carry a 1 to column five. Note that the 1 we just carried to column five joins the carry of 1 already in that column:\n\nColumn five now contains a total of five 1s (including the two carries). Since five is written in binary as 1012, we write a 1 in column five, and carry a 0 into column six and a 1 into column seven. The current state of the summation of partial products after adding the contents of column five is illustrated below:\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nThe remainder of the computation is carried out in a similar manner, always being careful to handle the carries properly. Try it out.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Binary Arithmetic"
    ]
  },
  {
    "objectID": "lessons/03 Number Systems and Binary Arithmetic/05 Binary Arithmetic.html#binary-arithmetic",
    "href": "lessons/03 Number Systems and Binary Arithmetic/05 Binary Arithmetic.html#binary-arithmetic",
    "title": "CSC 131",
    "section": "",
    "text": "Let’s take a look at how arithmetic operations, such as addition and multiplication, can be performed on binary numbers. First, let’s examine binary addition of single digit numbers. The simplest case is the addition of 0 plus 0. In binary, it is represented as follows:\n\\[0+0=0\\]\nSome prefer to view this vertically as opposed to horizontally as follows:\n\nExtending this, zero plus one and one plus zero both equal one:\n\\[0 + 1 = 1\\]\n\\[1 + 0 = 1\\]\nOr vertically:\n\nFinally, one plus one equals two. But the problem is that two cannot be represented as a single binary digit. Instead, we record a zero in the one’s position and carry a one over to the two’s position. This is represented as follows:\n\\[1 + 1 = 0\\] (carry 1)\nOr vertically:\n\nMulti-digit binary addition uses the same strategy employed in decimal addition. One works right-to-left from the least significant digit to the most significant digit, making sure that the carry from the previous column is added to the current column. Because the carry digit for a particular column may be “1” at the same time the corresponding digits of both of the numbers being added are also “1,” it is possible to encounter “one plus one plus one equals three” while performing addition. Since 112 equals three, “1” should be placed in the current position and another “1” carried over to the position immediately to the left of the current position. This is be represented as follows:\n\\[1 + 1 + 1 = 1\\] (carry 1)\nOr vertically:\n\nLet’s take a look at the addition of 38 + 15 = 53. The following table shows both the binary addition (on the left) and decimal addition (on the right):\n\nAnd now the addition of 43 + 58 = 101:\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry the addition of 50 + 77 = 127.\n\n\n\nBinary multiplication is also fairly simple. Zero times zero equals zero, as does zero times one and one times zero. One times one equals one. These expressions can be represented in base two as follows:\n\\[0 \\times 0 = 0\\] \\[0 \\times 1 = 0\\] \\[1 \\times 0 = 0\\] \\[1 \\times 1 = 1\\]\nNotice that none of these four expressions generate a carry, and only one generates a result other than zero. As we will see later, these features lead to binary multiplication being easy to perform; in fact, even easier to perform than decimal multiplication!\nMultiplication of multi-digit binary numbers works in a manner similar to multiplication of decimal numbers. As we all learned in grade school, multiplication problems are solved by adding together several partial products. A partial product is formed by multiplying a single digit of the bottom number times the entire top number. For example, given the base ten multiplication problem \\(472 \\times 104\\), we would solve it in the following way:\n\nThe first partial product is given by multiplying 4 times 472, which is 1888. The second partial product is computed as 0 times 472, which is 0. Normally we do not write down zero partial products. The final partial product is 1 times 472. Notice that we write this partial product so that its rightmost digit is directly under the digit of the second number that we multiplied by (i.e., 1). We then add the partial products, column by column from right-to-left, in order to obtain the final answer (49,088 in this case).\nWe apply this same strategy to perform binary multiplication. Let’s take a look at the product of \\(19 \\times 5 = 95\\) (in base two: \\(10011_2 \\times 101_2 = 1011111_2\\)):\n\nWe form partial products by multiplying the top number by each of the digits of the bottom number. Since the right-most digit of the second number is 1, the first partial product is given by 1 times 100112, or 100112. The right-most digit of this partial product is aligned with the rightmost digit of the second number. We do not record the partial product for zero times something, so multiplying the first number by the second digit of the second number, 0, doesn’t generate anything. The final partial product is computed as 1 times 10011 again, but this time where the right-most digit of this result is aligned beneath the third digit of the second number. The partial products are then added to obtain the final result, 10111112.\nAs we have just seen, in binary multiplication the formation of the partial products is very easy since we are only multiplying by 1 (in which case we copy the top number into the proper position) or 0 (in which case we do nothing). The only difficult steps in this process are making sure that we align the partial products correctly and compute the sum of those products accurately. Now let’s try a more difficult problem: the product of 143  23 = 3289 (in base two: \\(10001111_2 \\times 10111_2 = 110011011001_2\\))\n\nHere, we copy the top number as a partial product everywhere there is a 1 digit in the second number, each time making sure that we align the partial product so that the least significant digit is directly underneath the 1 we are multiplying by. We get the final result by adding the partial products together.\nWhen adding together the partial products, it is important that we handle the carry values properly. Because there is no limit on the size of the numbers to be multiplied, it is possible that there will be a large number of partial products. This situation can lead to carry values that extend over multiple columns. To illustrate this, consider summing a partial product column of five 1s:\n\nConsidering these separately, we initially add the first two 1s: 1 + 1 = 10. We then add the next one to that sum: 10 + 1 = 11. We then add the next one: 11 + 1 = 100. Finally, we add the last one: 100 + 1 = 101. So, 1 + 1 + 1 + 1 + 1 = 1012. To record this, we write a 1 in the current column and carry 10, placing the 0 in the column immediately to the left of the current column and 1 immediately to the left of that column. This is no different from the situation we encounter when adding up a long series of decimal numbers. If the current column of digits added to one hundred and one, we would place a 1 in the current column, carry a 0 to the previous column, and carry a 1 to the column before that.\nLet’s take a closer look at the summation of the partial products of the previous example (\\(143 \\times 23 = 3289\\)). The right-most column of partial products offers no problem. It is simply 1 plus nothing, giving a result of 1 with no carry. The second column requires us to add 1 + 1 resulting in a 0 with 1 carried over to the third column. Column three is interesting and is illustrated below:\n\nThe sum of the digits in column three, including the carry, is 1 + 1 + 1 + 1 = 1002 = 4. Hence, a 0 is written in column three, a 0 is carried to column four, and a 1 is carried to column five.\nColumn four contains three 1s, giving us a sum of 112. Hence, we write a 1 in column four and carry a 1 to column five. Note that the 1 we just carried to column five joins the carry of 1 already in that column:\n\nColumn five now contains a total of five 1s (including the two carries). Since five is written in binary as 1012, we write a 1 in column five, and carry a 0 into column six and a 1 into column seven. The current state of the summation of partial products after adding the contents of column five is illustrated below:\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nThe remainder of the computation is carried out in a similar manner, always being careful to handle the carries properly. Try it out.",
    "crumbs": [
      "Lessons",
      "03 Number Systems and Binary Arithmetic",
      "Binary Arithmetic"
    ]
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/02 Tkinter.html",
    "href": "lessons/04 Graphical User Interfaces/02 Tkinter.html",
    "title": "The Python Tkinter Library",
    "section": "",
    "text": "By default, Python does not support GUIs. That is, Python is text-based. In fact, the majority of programming languages are text-based. The print statement, for example, displays text to the console (the terminal on the RPi, for example). It does not, for example, display text to a graphical window or on a label positioned somewhere on the user’s desktop. The integration and support of GUIs in programming languages is typically done through internal or external libraries that provide the objects and tools necessary to create GUIs and to allow users to interact with GUIs.\nAlthough there are many GUI libraries that work with Python, this lesson will focus on one of the more common and popular ones that is included with Python by default and is cross-platform (i.e., it can be used to create GUIs on a variety of computing machines and operating systems). This GUI library is called Tkinter (For more information: https://wiki.python.org/moin/TkInter).\nThe Tkinter library is complex, yet it is powerful enough to create just about any GUI that a programmer would need. It would not be possible to cover the entire library in a single lesson. Therefore, we will take the approach of introducing the most frequently used components that Tkinter supports. Subsequently, we will show how to create a few simple GUIs that demonstrate a few of the different types that can be created."
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/02 Tkinter.html#introduction",
    "href": "lessons/04 Graphical User Interfaces/02 Tkinter.html#introduction",
    "title": "The Python Tkinter Library",
    "section": "",
    "text": "By default, Python does not support GUIs. That is, Python is text-based. In fact, the majority of programming languages are text-based. The print statement, for example, displays text to the console (the terminal on the RPi, for example). It does not, for example, display text to a graphical window or on a label positioned somewhere on the user’s desktop. The integration and support of GUIs in programming languages is typically done through internal or external libraries that provide the objects and tools necessary to create GUIs and to allow users to interact with GUIs.\nAlthough there are many GUI libraries that work with Python, this lesson will focus on one of the more common and popular ones that is included with Python by default and is cross-platform (i.e., it can be used to create GUIs on a variety of computing machines and operating systems). This GUI library is called Tkinter (For more information: https://wiki.python.org/moin/TkInter).\nThe Tkinter library is complex, yet it is powerful enough to create just about any GUI that a programmer would need. It would not be possible to cover the entire library in a single lesson. Therefore, we will take the approach of introducing the most frequently used components that Tkinter supports. Subsequently, we will show how to create a few simple GUIs that demonstrate a few of the different types that can be created."
  },
  {
    "objectID": "lessons/04 Graphical User Interfaces/02 Tkinter.html#a-tkinter-primer",
    "href": "lessons/04 Graphical User Interfaces/02 Tkinter.html#a-tkinter-primer",
    "title": "The Python Tkinter Library",
    "section": "A Tkinter primer",
    "text": "A Tkinter primer\nTkinter stands for “Tk interface.” Tk is a GUI toolkit that has been around for a while and was originally developed by the same folks that created the Java programming language. Tkinter is an object-oriented layer that provides a Python interface to the Tk GUI toolkit.\nThe first thing we must do to use the Tkinter library in a Python program is to import it via:\nfrom tkinter import *\nAlthough there are various ways to import the library, the above is the most common method of doing so that reduces the amount of source code required.\nThe typical manner in which GUIs are created using the Tkinter library is to create a window on which other components are placed. Let’s look at a simple program that creates a window and places a label on it:\n1: from tkinter import *\n2: window = Tk()\n3: text = Label(window, text=\"GUIs in Python are pretty easy!\")\n4: text.pack()\n5: window.mainloop()\nHere’s the output of this short program:\n\n\n\n\n\nLet’s explain the program, line-by-line. You already know the statement on line 1 that imports the Tkinter library. The statement on line 2 creates a graphical window (that is stored in the variable window). This must always be done in order to create a GUI using the Tkinter library. Line 3 creates a Tkinter Label, which is a component that is used to display text, an icon, or an image on a GUI. The label, which has the text “GUIs in Python are pretty easy!”, is stored in the variable text and is bound (or attached) to the window as its child. These explain the parameters passed in to the constructor of the Label class defined in the Tkinter library. The pack function called on line 4 is used on all Tkinter widgets. In this case, it instructs the label to size itself to fit the specified text and to make itself visible on the window. However, the GUI is not actually shown on the desktop until the statement on line 5. This statement instructs the window to appear on the desktop and wait for the user to interact with it. It will remain on the desktop until the user closes the window (in this case, by clicking on the X at the topright of the window).\nLet’s try a more standard way of creating GUIs using the Tkinter library. This method uses the objectoriented paradigm to encapsulate the GUI in a class that inherits from a Tkinter Frame. Here’s the program:\n 1: from tkinter import *\n\n 2: class App(Frame):\n 3:     def __init__(self, master):\n 4:         Frame.__init__(self, master)\n 5:         self.button1 = Button(master, text=\"BYE!\",\\\n 6:         fg=\"red\", command=self.quit)\n 7:         self.button1.pack(side=LEFT)\n 8:         self.button2 = Button(master, text=\\\n 9:         \"Say something!\", command=self.say)\n10:         self.button2.pack(side=LEFT)\n\n11:     def say(self):\n12:         print(\"Froot Loops!\")\n\n13: window = Tk()\n14: app = App(window)\n15: window.mainloop()\nHere’s the resulting GUI:\n\n\n\n\n\nClicking on the BYE! button closes the application. Clicking on the Say something! button displays the string “Froot Loops!” to the console each time it is clicked.\nLet’s explain the statements of the program as we did before, in the order that they are executed. Clearly, line 1 imports the Tkinter library. Lines 2 through 12 define the App class and are not yet executed. Line 13 creates the main window of the GUI. Line 14 creates a new instance of the App class, passing the main window as a parameter (it becomes the parent of any GUI components created in the App class). This launches the constructor of the App class which begins on line 3. Since the App class is a subclass of the Tkinter Frame class, the constructor of the Frame class is first called on line 4. This initializes a Tkinter Frame, which serves as a holder for other GUI components. A Tkinter Button (called button1) is then instantiated as an instance variable on lines 5 and 6. It is set as a child of the window (called master in the App class), given the text “BYE!” colored in red, and instructed to execute the function quit when clicked. The function quit is defined in the Tkinter library. For a frame, it simply closes it.\nLine 7 makes the button visible. Note the parameter: side=LEFT. This places the button as far left as possible in the frame. The default is TOP, which places a component as far to the top as possible. A second button, button2, is instantiated in lines 8 and 9. This button is instructed to execute the function say when clicked, which is defined in the App class (on lines 11 and 12). The button is also positioned as far left as possible (next to button1). The function say simply displays the text “Froot Loops!” to the console.\nFinally, line 15 displays the GUI and allows the user to interact with it."
  },
  {
    "objectID": "lessons/06 Recursion/01 Introduction.html",
    "href": "lessons/06 Recursion/01 Introduction.html",
    "title": "Recursion",
    "section": "",
    "text": "Although a lot of problems exist, it is often fun (and interesting) to study games to see if we can glean anything of value from them beyond just entertainment. In some cases, we actually learn useful tactics that can help us solve real problems later on. The Towers of Hanoi is an old, simple game (in principle). You are presented with three pegs (or towers) on which you can move various discs around. Initially, the discs rest on a single tower (the largest is on the bottom and the smallest is on the top). The objective is to move the discs from this source tower to some destination tower. But there are rules:\n\nOnly a single disc can be moved at a time;\nNo larger disc may ever be placed on top of a smaller disc; and\nMoving a single disc constitutes one move.\n\nThe objective, of course, is to move all of the discs from a source tower to a destination tower in the minimum number of moves. Here is an example of what the start of the game looks like (with three discs):\n\n\n\n\n\nThe game is interesting because it presents us with an optimization problem. That is, the goal is not just to find a solution (i.e., to successfully move the discs from the source tower on the left to the destination tower on the right), but to find one that is optimal (i.e., that results in some minimum number of moves). It is quite easy to eventually find a solution in, say, 100 moves. In fact, we can probably make mostly random moves and get there within 100.\nThe minimum number of moves required to solve the Towers of Hanoi with three discs turns out to be seven! In fact, here are the moves:\n\n\n\n\n\nTrying our hand at solving the puzzle with one, two, three discs, and so on, may lead to some idea of where to place the first disc. We also notice a pattern; however, it is not so straightforward. In fact, attempting to design an algorithm to solve the puzzle would most likely be difficult at this point. It would undoubtedly involve repetition, and breaking down the problem so that it can be reasoned about and an algorithm designed is not as simple as it may initially appear\nThe simplest case of the Towers of Hanoi is one with a single disc. The minimum number of moves required in this case is, trivially, one (move the disc from the source tower to the destination tower). We can create a table that, given an initial number of discs, provides the minimum number of moves required for a Towers of Hanoi problem with that many discs:\n\n\n\nNumber of Discs\nMinimum number of moves\n\n\n\n\n1\n1\n\n\n2\n3\n\n\n3\n7\n\n\n4\n15\n\n\n5\n31\n\n\n6\n63\n\n\n\nIn the general case of n discs, how many moves would it minimally take? Do you see a pattern? A quick look indicates that the minimum number of moves required appears to double each time a disc is added. For example, one disc requires one move. Two discs requires three moves (a bit more than double the number of moves required for a single disc). Three discs requires seven moves (a bit more than double the number of moves required for two discs). And so on\nIt appears that the minimum number of moves required can be represented as a power of two of the number of discs. In the case of a single disc, we have: \\(2^{1} = 2\\); and \\(2 - 1 = 1\\). In this case, that’s \\(2^{1}-1\\) moves (minimally). In the case of two discs, we have: \\(2^{2} = 4\\); and \\(4 - 1 = 3\\). That’s \\(2^{2} - 1\\) moves. And in the case of three discs, we have \\(2^{3} = 8\\); and \\(8 - 1 = 7\\). That’s \\(2^{3} - 1\\) moves. Generalizing this for n discs, we simply have \\(2^{*n*} - 1\\) moves (minimally)! Here’s the updated table:\n\n\n\nNumber of Discs\nMinimum number of moves\n\n\n\n\n1\n1\n\n\n2\n3\n\n\n3\n7\n\n\n4\n15\n\n\n5\n31\n\n\n6\n63\n\n\nn\n\\(2^{n} - 1\\)\n\n\n\nLet’s suppose that it takes 1 second for you to make a single move. How long would it take to complete the puzzle with six discs? Since it takes 63 moves to complete the puzzle with six discs, and each move takes 1 second, then it would take slightly over one minute to complete the puzzle. Since the number of moves effectively doubles each time a disc is added to the problem, so does the time it takes to solve the puzzle! For example, it would take approximately two minutes to solve a puzzle with seven discs, approximately 16 minutes for a puzzle with ten discs, and approximately 11 days for a puzzle with 20 discs!\nSuppose that your computer could make 500 million moves per second (which is probably about right!). A quick calculation shows us that the Towers of Hanoi with 30 discs would take a little over two seconds. Again, it doubles with every additional disc. For example, it would take your computer approximately four seconds for a puzzle with 31 discs, approximately one minute for puzzle with 35 discs, and approximately one hour for a puzzle with 41 discs. And it would take almost one month for a puzzle with 50 discs! One month for a fast computer that can make 500 million moves per second!\nIt is said that a group of monks are working to solve the Towers of Hanoi with 64 golden disks. They believe that, once solved, it will be the end of the world. They move the discs by hand. Think of the size of the discs to be able to stack 64 of them (golden ones, mind you) on a single tower! They must require pulleys, ropes, many monks for each move, and so on. Suppose that they can make one move every ten minutes (which is quite fast, considering). It would take them over 350 billion millennia (that’s over 350 billion thousand years) to solve the puzzle in the minimum ~18.4 quintillion moves! I’m not worried…\n\n\n\nConsider a simple question: Let’s say that there are ten students in the class. Suppose that some activity requires pairing students in groups of two. How many unique groups could be generated? That is, how many ways could the class be split up into groups of two? Although not particularly difficult, the answer is not obvious at first. A strategy may be to simplify the problem into a trivial case, and build up from there. We could do this by first considering a class of two students. How many groups of two could be formed? Clearly, only one. There is only one way to group two students in groups of two. Let’s add a third student. In fact, let’s consider the three students, S1, S2, and S3. How many ways could groups of two be formed from these three students? Let’s try to enumerate them all:\n\nS1 and S2;\nS1 and S3; and\nS2 and S3.\n\nSo there are three ways to form groups of two from three total students. What about four total students, S1 through S4?\n\nS1 and S2;\nS1 and S3;\nS1 and S4;\nS2 and S3;\nS2 and S4; and\nS3 and S4\n\nThere are six ways to form groups of two from four total students. One more: what about five total student, S1 through S5?\n\nS1 and S2;\nS1 and S3;\nS1 and S4;\nS1 and S5;\nS2 and S3;\nS2 and S4;\nS2 and S5;\nS3 and S4;\nS3 and S5; and\nS4 and S5.\n\nThere are ten ways to form groups of two from five total students. How does this scale to more students? Take a look at this table (note that there are exactly zero ways to form groups of two from a single student!):\n\n\n\nStudent\nGroups\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n3\n\n\n4\n6\n\n\n5\n10\n\n\n6\n15\n\n\n7\n21\n\n\n8\n28\n\n\n9\n36\n\n\n10\n?\n\n\n\nCan you guess the number of groups of two that can be formed with ten students? Can you see a pattern that gives the number of groups from some number of students? Take a closer look at a subset of the table above:\n\n\n\nStudent\nGroups\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n3\n\n\n\nFor the case of three students, it seems that we can calculate the number of groups of two that can be formed as the sum of the number of groups of two that can be formed with two students plus those two students (i.e., 1 + 2 = 3). Let’s see if this continues to work out with four students:\n\n\n\nStudent\nGroups\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n3\n\n\n4\n6\n\n\n\nTo calculate how many groups of two can be formed with four students, we can sum the number of students in the row above (3) with the number of groups that can be formed with that many students (3): (3 + 3 = 6).\nAnd one more:\n\n\n\nStudent\nGroups\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n3\n\n\n4\n6\n\n\n5\n10\n\n\n\nThe number of groups of two that can be formed with five students is the number of groups of two that can be formed with four students (6) plus those four students (4): (6 + 4 = 10). And now, we can calculate the number of groups of two that can be formed with 10 students:\n\n\n\nStudent\nGroups\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n3\n\n\n4\n6\n\n\n5\n10\n\n\n6\n15\n\n\n7\n21\n\n\n8\n28\n\n\n9\n36\n\n\n10\n45\n\n\n\nHow can we generalize this for any number of students (say, n)? It turns out that we can use a recurrence relation to describe this behavior.\n\n\n\n\n\n\nDefinition\n\n\n\nA recurrence relation is an equation that recursively defines a sequence. That is, each term in the sequence is defined as a function of the preceding terms in some way.\n\n\nFor example, in the table above the number of groups of two that can be formed with ten students is a function of the number of groups of two that can be formed with nine students. And that itself is a function of the number of groups of two that can be formed with eight students. And this goes on. Ultimately, however, we can establish some base (or trivial) case that is immediately answerable. For example, we can say (without needing to think about it too much) that no groups of two can be formed with one student. In fact, this is the simplest case for this problem. It is the base (or trivial) case.\nRecurrence relations must ensure that, at some point, the base case is achievable. That is, the problem must be repeatedly broken down into smaller and smaller versions of itself, eventually reaching the base case. The solution to a specific term in the sequence is then built back up, from the base case! Algorithms that repeatedly break something down until a base case is reached and build a solution back up are known as divide and conquer algorithms.\nFor the groups of students problem stated above, we can define a function, G(n), that calculates the number of groups of two that can be formed from n total students. We could express this function as follows: \\[\\begin{equation}\nG(n) =\n   \\left\\{\\begin{array}{lr}\n       0 &\\text{, if } n = 1\\\\\n       (n-1)+G(n-1) &\\text{, otherwise}\n    \\end{array}\\right.\n\\end{equation}\\]\nWe read this as follows: the number of groups of two that can be formed from n students is:\n• 0, if the number of students, n, is 1; or\n• n minus 1 plus the number of groups of two that can be formed from n minus 1 students, otherwise.\nAlthough fully understanding this at this point is not necessary, note how the second part of the function is dependent on the function itself. That is, the otherwise part breaks the problem down a bit into a smaller version of itself via G(n – 1). The interesting thing is that the problem can be broken down enough times to ensure that the base case is eventually reached! If n is some positive number greater than 0, the recurrence relation will break down the problem until n is 1, at which point the base case is reached (and everything stops).\nFormally, the equation above is known as a recurrence relation because it is defined in terms of itself. It also has two separate parts, and the result depends on the input value. In mathematics, we refer to this type of function as a piecewise function. This particular function has two pieces:\n• The first results in 0, but only if the input value, n, is 1; and\n• The second results in a broken down version of itself, otherwise (i.e., for values of n that are not 1).\n\n\n\nIn computer science, recursion is usually understood to be the idea of a subprogram repeatedly calling itself. Of course, at some point this repeated calling has to stop (otherwise, it would be an infinite loop). In a previous lesson, we envisioned recursion as a spiral of sorts. Each time a subprogram calls itself, we descend down a level of the spiral until we eventually reach the bottom (some base or trivial case). At that point, execution begins to unwind as the subprogram calls complete and we retrace our path back up through the various levels until finally arriving at the top level where execution began. This is when the solution is built back up. Generally, however, recursion is just another name for recurrence relation.\n\n\n\n\n\n\nDefinition\n\n\n\nRecursion is the process of breaking down a problem into smaller and smaller versions of itself until a base or trivial case is reached. Recursion must have two parts: (1) a base or trivial case that provides an immediate answer to some specified input; and (2) a recursive step that breaks the problem down into a smaller version of itself.\n\n\nRecursion is the programming equivalent of mathematical induction (which is just defining something in terms of itself). To illustrate this more clearly, let’s take a look at a simple algorithm that computes a base to some power (i.e., xy):\n# compute 2^10\nx = 2\ny = 10\npow = 1\n\nfor i in range(0, y):\n    pow *= x\n\nprint(\"{}^{} = {}\".format(x, y, pow))\nThis example computes 210 (1024). It basically multiplies one by the base (x) y times. When the base is two and the exponent is ten, it multiples one by two, ten times (i.e., 1 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2).\nTo convert this iterative algorithm to a recursive one, we must first define the recurrence relation that solves the problem. First, the base or trivial case. For exponents, that’s simple: \\(x^{0} = 1\\). That is, anything raised to the power zero is always one. The recursive step takes more thought. A hint is to observe how powers can be broken down. For example: \\(2^{2} = 2 * 2\\). Extending this, \\(2^{3} = 2 * 2 * 2\\). This can be rewritten as \\(2^{3} = 2 * 2^{2}\\). We can extend this further: \\(2^{4} = 2 * 2^{3}\\). Notice how the exponents can be repeatedly broken down into smaller exponents. The trick is to see if the base case is eventually reached.\nLet’s take a look at the first example again: \\(2^{2} = 2 * 2\\). Technically, \\(2^{2} = 2 * 2^{1}\\). And \\(2^{1} = 2 * 2^{0}\\)! So the base case can eventually be reached. We can now formally define a recurrence relation for some function Pow(x, y) as follows:\n\\[\\begin{equation}\nPow(x, y) =\n   \\left\\{\\begin{array}{lr}\n       1 &\\text{, if } y = 0\\\\\n       x*Pow(x, y-1) &\\text{, otherwise}\n    \\end{array}\\right.\n\\end{equation}\\]\nLet’s see if it works with an example: 25 (which is 32). In the recurrence relation above, we would call the function with Pow(2, 5). Since y is not zero, the second (recursive) case is applied resulting in 2 * Pow(2, 4). To calculate Pow(2, 4), the second case is applied again resulting in 2 * Pow(2, 3). And to calculate Pow(2, 3), we apply the second case another time which results in 2 * Pow(2, 2). We have to apply the second case a few more times: first with Pow(2, 2) which results in 2 * Pow(2, 1), and lastly with Pow(2, 1) which results in 2 * Pow(2, 0). At this point, the first (base) case is applied (since y is 0) resulting in 1. We can now build it all back up: 1 * 2 * 2 * 2 * 2 * 2 = 32.\nPerhaps this is best illustrated as follows; first with the recursive calls:\nPow(2, 5)\n 2 * Pow(2, 4)\n  2 * Pow(2, 3)\n   2 * Pow(2, 2)\n    2 * Pow(2, 1)\n     2 * Pow(2, 0)\nNow let’s build the result back up:\nPow(2, 5) 32\n 2 * Pow(2, 4) 16\n  2 * Pow(2, 3) 8\n   2 * Pow(2, 2) 4\n    2 * Pow(2, 1) 2\n     2 * Pow(2, 0) 1\nNotice how, at each step in the building back up, the result of the recursive calls combine to form simple arithmetic problems (e.g., 2 * Pow(2, 0) becomes 2 * 1 which equals 2). The arithmetic results form the answer to a previous recursive call (which is then replaced to form another simple arithmetic problem).\nHere’s another interesting mathematical function: the factorial. Let’s first look at its recursive definition:\n\\[\\begin{equation}\nFrac(n) =\n   \\left\\{\\begin{array}{lr}\n       1 &\\text{, if } n = 0\\\\\n       n*Frac(n-1) &\\text{, otherwise}\n    \\end{array}\\right.\n\\end{equation}\\]\nThe factorial function repeatedly multiplies some integer by all the integers below it (up to 1). For example, five factorial (referred to as 5!) = 5 * 4 * 3 * 2 * 1 = 120. To see how this works, let’s take a look at some examples:\n5! = 5 * 4 * 3 * 2 * 1 = 120\n4! = 4 * 3 * 2 * 1 = 24\n3! = 3 * 2 * 1 = 6\n2! = 2 * 1 = 2\n1! = 1\nNote how 4! is embedded within 5!:\n5! = 5 * 4 * 3 * 2 * 1\nAnd so on. In fact, we could say that 5! = 5 * 4!, and 4! = 4 * 3!, and 3! = 3 * 2!, and so on. This clearly breaks the problem down into smaller and smaller versions of itself. So what is the base case? Perhaps it’s just that 1! = 1. Although correct, mathematicians actually prefer 0! = 1 (as illustrated in the recurrence relation above). So the breaking down occurs as follows:\n5! = 5 * 4!\n4! = 4 * 3!\n3! = 3 * 2!\n2! = 2 * 1!\n1! = 1 * 0!\n0! = 1\nAnd now we can implement a recursive factorial function as follows:\ndef fact(n):\n    if (n == 0):\n        return 1\n    else:\n        return n * fact(n - 1)\nAnd to compute 5!:\nprint(\"5! = {}\".format(fact(5)))\nLet’s see how the recursion works as in the previous Pow example; first with the recursive calls:\nfact(5)\n 5 * fact(4)\n  4 * fact(3)\n   3 * fact(2)\n    2 * fact(1)\n     1 * fact(0)\nNext with the building back up:\nfact(5) 120\n 5 * fact(4) 24\n  4 * fact(3) 6\n   3 * fact(2) 2\n    2 * fact(1) 1\n     1 * fact(0) 1\n\n\n\n\n\n\n\nDid you know\n\n\n\nAlthough not always simple, any iterative algorithm can be converted to a recursive one and vice versa!\n\nTry implementing an iterative factorial algorithm (in Python)\nAnother interesting mathematical function is one that generates the Fibonacci sequence. Although it has been featured in a puzzle, no actual function was provided. Let’s take a look at the Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …\nA term in the sequence can be calculated as the sum of the two previous terms. For example, the seventh term (8) is the sum of the fifth and sixth terms (3 and 5). Here’s a recurrence relation for the Fibonacci sequence:\n\\[\\begin{equation}\nFib(n) =\n   \\left\\{\\begin{array}{lr}\n       0 &\\text{, if } n = 1\\\\\n       1 &\\text{, if } n = 2\\\\\n       Fib(n-1)+Fib(n-2) &\\text{, otherwise}\n    \\end{array}\\right.\n\\end{equation}\\]\nNote that this recurrence relation has two base cases! This is necessary since the recursion requires the sum of the two previous terms. The first term in the sequence, Fib(1), is 0 (the first base case). The second term in the sequence, Fib(2), is 1 (the second base case). The remaining terms are calculated recursively as the sum of the previous two terms, Fib(n – 1) + Fib(n – 2). Here’s how the recursion breaks down for Fib(6) (which equals 5). Since there are multiple branches of recursion (i.e., two parts to each recursive call), we’ll use a different method to show the recursion:\n\n\n\n\n\nAt the top, Fib(6) breaks down to Fib(5) + Fib(4). The figure then takes on an upside-down tree-like structure. Note how, if flipped upside-down, the top would form a root. The root then splits into two branches, each of which split into two more branches, and so on. The values at the bottom of the figure form what are called leaves. These represent the base cases, all either Fib(1) or Fib(2). In a future lesson, we will discuss trees more formally.\nWe can build the result back up as follows:\n\n\n\n\n\nThe result (at the top) is, as expected, 5.\n\n\n\nAs noted earlier, crafting an algorithm for this puzzle is not as simple as it sounds. In fact, it is quite difficult to design an iterative algorithm for it. Let’s see if we can use recursion to our advantage. Consider the puzzle with three discs:\n\n\n\n\n\nSuppose that the destination tower is the one on the right. The middle tower will be used as a spare. In order to move all three discs from the source tower to the destination tower, we can think of first needing to move two discs (the top two, in fact) from the source tower to the spare tower:\n\n\n\n\n\nClearly this is not possible since we cannot move two discs simultaneously; however, let’s continue with this train of thought for a moment. Supposing that we have successfully done this, then we would need to move the single disc left on the source tower to the destination tower:\n\n\n\n\n\nAnd all that would be left to do is to move the two discs that are on the spare tower over to the destination tower:\n\n\n\n\n\nPuzzle solved! However, as mentioned we cannot move two discs simultaneously. However, let’s go back to the original state:\n\n\n\n\n\nIn order to move the two top discs from the source tower to the spare tower, we first need to move the single top disc from the source tower to the destination tower:\n\n\n\n\n\nWe can then move the second disc from the source tower to the spare tower:\n\n\n\n\n\nAnd we can finally move the small disc from the destination tower to the spare tower:\n\n\n\n\n\nIn a sense, the three disc puzzle (i.e., moving three discs from the source tower to the destination tower) is a two-disc puzzle (moving the two top discs from the source tower to the spare tower), followed by a one-disc puzzle (moving the largest disc from the source tower to the destination tower), and finished with a two-disc puzzle (moving the two discs left on the spare tower to the destination tower).\nBut of course, the two-disc puzzles are simply three one-disc puzzles! And a one-disc puzzle is simple: just move the disc from one tower to another. Moving one disc is, in fact, the base case of the Towers of Hanoi! Moving more than one disc can be broken down as a sequence of three smaller puzzles as follows:\n\nMove all but the bottom disc from the source tower to the spare tower;\nMove the largest disc from the source tower to the destination tower; and\nMove the discs on the spare tower to the destination tower.\n\nOr in general, given n discs:\n\nMove n – 1 discs from source to spare;\nMove 1 disc from source to destination; and\nMove n – 1 discs from spare to destination.\n\nWe can design a recursive algorithm in Python as follows:\ndef hanoi(n, src, dst, spr):\n    if (n == 1):\n        print(\"{} -&gt; {}\".format(src, dst))\n    else:\n        hanoi(n - 1, src, spr, dst)\n        hanoi(1, src, dst, spr)\n        hanoi(n - 1, spr, dst, src)\nNote the parameters in the function hanoi. The variable n specifies the number of discs. The variables src, dst, and spr refer to the three towers. We can execute the algorithm and call the hanoi function (with three discs from a source tower A to a destination tower C using a spare tower B) as follows:\nhanoi(3, \"A\", \"C\", \"B\")\nHere is the output:\nA -&gt; C\nA -&gt; B\nC -&gt; B\nA -&gt; C\nB -&gt; A\nB -&gt; C\nA -&gt; C\nThe recursive function does require a little bit of explanation. Let’s take a look at the initial call to the function again:\nhanoi(3, \"A\", \"C\", \"B\")\nWhen this call occurs, the actual parameters, 3, “A”, “C”, and “B”, are passed in (or mapped) to the formal parameters, n, src, dst, and spr. To be clear, the source tower is A, and the destination tower is C. The first part of the recursive function, representing the base case when n = 1, is clear: simply move the single disc from src to dst. This is accomplished by displaying the move to the console\nprint(\"{} -&gt; {}\".format(src, dst))\nIf n &gt; 1, the recursive step is applied:\nhanoi(n - 1, src, spr, dst)\nhanoi(1, src, dst, spr)\nhanoi(n - 1, spr, dst, src)\nThat is, to move n discs from src to dst using spr, we must first move n – 1 discs from src to spr (using dst as the temporary spare tower), then move one disc from src to dst, and finally move the n – 1 discs moved previously from spr to dst (using src as the temporary spare tower). Let’s look at the first call only along with the function definition:\ndef hanoi(n, src, dst, spr):\n    ...\n    hanoi(n - 1, src, spr, dst)\nIn this call, the actual parameter, n – 1, is mapped to the formal parameter, n. So whatever n is in the function, when it is called again, it is with n – 1. Similarly, src is mapped to src (since moving n discs from some source results in moving n – 1 discs from that source first). The n – 1 discs, however, are moved to the spare tower (to get them out of the way). So the call maps spr as the actual parameter to dst as the formal parameter. Lastly, dst is mapped to spr. That is, the destination tower is temporarily used as the spare tower when moving the n – 1 discs out of the way.\nPerhaps this is best viewed dynamically, as each call is made. Let’s illustrate this with a simple puzzle with two discs:\nhanoi(2, \"A\", \"C\", \"B\")\nThis call results in the following variable values:\n\n\n\nn\nsrc\ndst\nspr\n\n\n\n\n2\nA\nC\nB\n\n\n\nThe recursive step is then applied, which results in the following three recursive calls:\n    1  A B  C\nhanoi(n - 1, src, spr, dst)\n    A  B C\nhanoi(1, src, dst, spr)\n    1  B C  A\nhanoi(n - 1, spr, dst, src)\nSince these are all one-disc puzzles, the base case is applied each time (which simply displays the move to the console). The first recursive call results in the the following variable values:\n\n\n\nn\nsrc\ndst\nspr\n\n\n\n\n1\nA\nB\nC\n\n\n\nIt therefore displays the following move: A → B. The second recursive call results in the the following variable values:\n\n\n\nn\nsrc\ndst\nspr\n\n\n\n\n1\nA\nC\nB\n\n\n\nIt therefore displays the following move: A → C. The third recursive call results in the the following variable values:\n\n\n\nn\nsrc\ndst\nspr\n\n\n\n\n1\nB\nC\nA\n\n\n\nIt therefore displays the following move: B → C. The three moves do, in fact, solve the two-disc puzzle. Note that the values for the three towers can be anything. The strings “A”, “B”, and “C” were used above; however, the integers 1, 2, and 3 would work just as well. If we wish, we can display the moves required for puzzles with one through four discs as follows:\nfor i in range(1, 5):\n    print(\"The Towers of Hanoi with {} disc(s):\".format(i))\n    hanoi((i, \"A\", \"C\", \"B\")\n    print()\nThe output of this modified algorithm is:\nThe Towers of Hanoi with 1 disc(s):\nA -&gt; C\n\nThe Towers of Hanoi with 2 disc(s):\nA -&gt; B\nA -&gt; C\nB -&gt; C\n\nThe Towers of Hanoi with 3 disc(s):\nA -&gt; C\nA -&gt; B\nC -&gt; B\nA -&gt; C\nB -&gt; A\nB -&gt; C\nA -&gt; C\n\nThe Towers of Hanoi with 4 disc(s):\nA -&gt; B\nA -&gt; C\nB -&gt; C\nA -&gt; B\nC -&gt; A\nC -&gt; B\nA -&gt; B\nA -&gt; C\nB -&gt; C\nB -&gt; A\nC -&gt; A\nB -&gt; C\nA -&gt; B\nA -&gt; C\nB -&gt; C"
  },
  {
    "objectID": "lessons/06 Recursion/01 Introduction.html#recursion",
    "href": "lessons/06 Recursion/01 Introduction.html#recursion",
    "title": "Recursion",
    "section": "",
    "text": "Although a lot of problems exist, it is often fun (and interesting) to study games to see if we can glean anything of value from them beyond just entertainment. In some cases, we actually learn useful tactics that can help us solve real problems later on. The Towers of Hanoi is an old, simple game (in principle). You are presented with three pegs (or towers) on which you can move various discs around. Initially, the discs rest on a single tower (the largest is on the bottom and the smallest is on the top). The objective is to move the discs from this source tower to some destination tower. But there are rules:\n\nOnly a single disc can be moved at a time;\nNo larger disc may ever be placed on top of a smaller disc; and\nMoving a single disc constitutes one move.\n\nThe objective, of course, is to move all of the discs from a source tower to a destination tower in the minimum number of moves. Here is an example of what the start of the game looks like (with three discs):\n\n\n\n\n\nThe game is interesting because it presents us with an optimization problem. That is, the goal is not just to find a solution (i.e., to successfully move the discs from the source tower on the left to the destination tower on the right), but to find one that is optimal (i.e., that results in some minimum number of moves). It is quite easy to eventually find a solution in, say, 100 moves. In fact, we can probably make mostly random moves and get there within 100.\nThe minimum number of moves required to solve the Towers of Hanoi with three discs turns out to be seven! In fact, here are the moves:\n\n\n\n\n\nTrying our hand at solving the puzzle with one, two, three discs, and so on, may lead to some idea of where to place the first disc. We also notice a pattern; however, it is not so straightforward. In fact, attempting to design an algorithm to solve the puzzle would most likely be difficult at this point. It would undoubtedly involve repetition, and breaking down the problem so that it can be reasoned about and an algorithm designed is not as simple as it may initially appear\nThe simplest case of the Towers of Hanoi is one with a single disc. The minimum number of moves required in this case is, trivially, one (move the disc from the source tower to the destination tower). We can create a table that, given an initial number of discs, provides the minimum number of moves required for a Towers of Hanoi problem with that many discs:\n\n\n\nNumber of Discs\nMinimum number of moves\n\n\n\n\n1\n1\n\n\n2\n3\n\n\n3\n7\n\n\n4\n15\n\n\n5\n31\n\n\n6\n63\n\n\n\nIn the general case of n discs, how many moves would it minimally take? Do you see a pattern? A quick look indicates that the minimum number of moves required appears to double each time a disc is added. For example, one disc requires one move. Two discs requires three moves (a bit more than double the number of moves required for a single disc). Three discs requires seven moves (a bit more than double the number of moves required for two discs). And so on\nIt appears that the minimum number of moves required can be represented as a power of two of the number of discs. In the case of a single disc, we have: \\(2^{1} = 2\\); and \\(2 - 1 = 1\\). In this case, that’s \\(2^{1}-1\\) moves (minimally). In the case of two discs, we have: \\(2^{2} = 4\\); and \\(4 - 1 = 3\\). That’s \\(2^{2} - 1\\) moves. And in the case of three discs, we have \\(2^{3} = 8\\); and \\(8 - 1 = 7\\). That’s \\(2^{3} - 1\\) moves. Generalizing this for n discs, we simply have \\(2^{*n*} - 1\\) moves (minimally)! Here’s the updated table:\n\n\n\nNumber of Discs\nMinimum number of moves\n\n\n\n\n1\n1\n\n\n2\n3\n\n\n3\n7\n\n\n4\n15\n\n\n5\n31\n\n\n6\n63\n\n\nn\n\\(2^{n} - 1\\)\n\n\n\nLet’s suppose that it takes 1 second for you to make a single move. How long would it take to complete the puzzle with six discs? Since it takes 63 moves to complete the puzzle with six discs, and each move takes 1 second, then it would take slightly over one minute to complete the puzzle. Since the number of moves effectively doubles each time a disc is added to the problem, so does the time it takes to solve the puzzle! For example, it would take approximately two minutes to solve a puzzle with seven discs, approximately 16 minutes for a puzzle with ten discs, and approximately 11 days for a puzzle with 20 discs!\nSuppose that your computer could make 500 million moves per second (which is probably about right!). A quick calculation shows us that the Towers of Hanoi with 30 discs would take a little over two seconds. Again, it doubles with every additional disc. For example, it would take your computer approximately four seconds for a puzzle with 31 discs, approximately one minute for puzzle with 35 discs, and approximately one hour for a puzzle with 41 discs. And it would take almost one month for a puzzle with 50 discs! One month for a fast computer that can make 500 million moves per second!\nIt is said that a group of monks are working to solve the Towers of Hanoi with 64 golden disks. They believe that, once solved, it will be the end of the world. They move the discs by hand. Think of the size of the discs to be able to stack 64 of them (golden ones, mind you) on a single tower! They must require pulleys, ropes, many monks for each move, and so on. Suppose that they can make one move every ten minutes (which is quite fast, considering). It would take them over 350 billion millennia (that’s over 350 billion thousand years) to solve the puzzle in the minimum ~18.4 quintillion moves! I’m not worried…\n\n\n\nConsider a simple question: Let’s say that there are ten students in the class. Suppose that some activity requires pairing students in groups of two. How many unique groups could be generated? That is, how many ways could the class be split up into groups of two? Although not particularly difficult, the answer is not obvious at first. A strategy may be to simplify the problem into a trivial case, and build up from there. We could do this by first considering a class of two students. How many groups of two could be formed? Clearly, only one. There is only one way to group two students in groups of two. Let’s add a third student. In fact, let’s consider the three students, S1, S2, and S3. How many ways could groups of two be formed from these three students? Let’s try to enumerate them all:\n\nS1 and S2;\nS1 and S3; and\nS2 and S3.\n\nSo there are three ways to form groups of two from three total students. What about four total students, S1 through S4?\n\nS1 and S2;\nS1 and S3;\nS1 and S4;\nS2 and S3;\nS2 and S4; and\nS3 and S4\n\nThere are six ways to form groups of two from four total students. One more: what about five total student, S1 through S5?\n\nS1 and S2;\nS1 and S3;\nS1 and S4;\nS1 and S5;\nS2 and S3;\nS2 and S4;\nS2 and S5;\nS3 and S4;\nS3 and S5; and\nS4 and S5.\n\nThere are ten ways to form groups of two from five total students. How does this scale to more students? Take a look at this table (note that there are exactly zero ways to form groups of two from a single student!):\n\n\n\nStudent\nGroups\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n3\n\n\n4\n6\n\n\n5\n10\n\n\n6\n15\n\n\n7\n21\n\n\n8\n28\n\n\n9\n36\n\n\n10\n?\n\n\n\nCan you guess the number of groups of two that can be formed with ten students? Can you see a pattern that gives the number of groups from some number of students? Take a closer look at a subset of the table above:\n\n\n\nStudent\nGroups\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n3\n\n\n\nFor the case of three students, it seems that we can calculate the number of groups of two that can be formed as the sum of the number of groups of two that can be formed with two students plus those two students (i.e., 1 + 2 = 3). Let’s see if this continues to work out with four students:\n\n\n\nStudent\nGroups\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n3\n\n\n4\n6\n\n\n\nTo calculate how many groups of two can be formed with four students, we can sum the number of students in the row above (3) with the number of groups that can be formed with that many students (3): (3 + 3 = 6).\nAnd one more:\n\n\n\nStudent\nGroups\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n3\n\n\n4\n6\n\n\n5\n10\n\n\n\nThe number of groups of two that can be formed with five students is the number of groups of two that can be formed with four students (6) plus those four students (4): (6 + 4 = 10). And now, we can calculate the number of groups of two that can be formed with 10 students:\n\n\n\nStudent\nGroups\n\n\n\n\n1\n0\n\n\n2\n1\n\n\n3\n3\n\n\n4\n6\n\n\n5\n10\n\n\n6\n15\n\n\n7\n21\n\n\n8\n28\n\n\n9\n36\n\n\n10\n45\n\n\n\nHow can we generalize this for any number of students (say, n)? It turns out that we can use a recurrence relation to describe this behavior.\n\n\n\n\n\n\nDefinition\n\n\n\nA recurrence relation is an equation that recursively defines a sequence. That is, each term in the sequence is defined as a function of the preceding terms in some way.\n\n\nFor example, in the table above the number of groups of two that can be formed with ten students is a function of the number of groups of two that can be formed with nine students. And that itself is a function of the number of groups of two that can be formed with eight students. And this goes on. Ultimately, however, we can establish some base (or trivial) case that is immediately answerable. For example, we can say (without needing to think about it too much) that no groups of two can be formed with one student. In fact, this is the simplest case for this problem. It is the base (or trivial) case.\nRecurrence relations must ensure that, at some point, the base case is achievable. That is, the problem must be repeatedly broken down into smaller and smaller versions of itself, eventually reaching the base case. The solution to a specific term in the sequence is then built back up, from the base case! Algorithms that repeatedly break something down until a base case is reached and build a solution back up are known as divide and conquer algorithms.\nFor the groups of students problem stated above, we can define a function, G(n), that calculates the number of groups of two that can be formed from n total students. We could express this function as follows: \\[\\begin{equation}\nG(n) =\n   \\left\\{\\begin{array}{lr}\n       0 &\\text{, if } n = 1\\\\\n       (n-1)+G(n-1) &\\text{, otherwise}\n    \\end{array}\\right.\n\\end{equation}\\]\nWe read this as follows: the number of groups of two that can be formed from n students is:\n• 0, if the number of students, n, is 1; or\n• n minus 1 plus the number of groups of two that can be formed from n minus 1 students, otherwise.\nAlthough fully understanding this at this point is not necessary, note how the second part of the function is dependent on the function itself. That is, the otherwise part breaks the problem down a bit into a smaller version of itself via G(n – 1). The interesting thing is that the problem can be broken down enough times to ensure that the base case is eventually reached! If n is some positive number greater than 0, the recurrence relation will break down the problem until n is 1, at which point the base case is reached (and everything stops).\nFormally, the equation above is known as a recurrence relation because it is defined in terms of itself. It also has two separate parts, and the result depends on the input value. In mathematics, we refer to this type of function as a piecewise function. This particular function has two pieces:\n• The first results in 0, but only if the input value, n, is 1; and\n• The second results in a broken down version of itself, otherwise (i.e., for values of n that are not 1).\n\n\n\nIn computer science, recursion is usually understood to be the idea of a subprogram repeatedly calling itself. Of course, at some point this repeated calling has to stop (otherwise, it would be an infinite loop). In a previous lesson, we envisioned recursion as a spiral of sorts. Each time a subprogram calls itself, we descend down a level of the spiral until we eventually reach the bottom (some base or trivial case). At that point, execution begins to unwind as the subprogram calls complete and we retrace our path back up through the various levels until finally arriving at the top level where execution began. This is when the solution is built back up. Generally, however, recursion is just another name for recurrence relation.\n\n\n\n\n\n\nDefinition\n\n\n\nRecursion is the process of breaking down a problem into smaller and smaller versions of itself until a base or trivial case is reached. Recursion must have two parts: (1) a base or trivial case that provides an immediate answer to some specified input; and (2) a recursive step that breaks the problem down into a smaller version of itself.\n\n\nRecursion is the programming equivalent of mathematical induction (which is just defining something in terms of itself). To illustrate this more clearly, let’s take a look at a simple algorithm that computes a base to some power (i.e., xy):\n# compute 2^10\nx = 2\ny = 10\npow = 1\n\nfor i in range(0, y):\n    pow *= x\n\nprint(\"{}^{} = {}\".format(x, y, pow))\nThis example computes 210 (1024). It basically multiplies one by the base (x) y times. When the base is two and the exponent is ten, it multiples one by two, ten times (i.e., 1 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2).\nTo convert this iterative algorithm to a recursive one, we must first define the recurrence relation that solves the problem. First, the base or trivial case. For exponents, that’s simple: \\(x^{0} = 1\\). That is, anything raised to the power zero is always one. The recursive step takes more thought. A hint is to observe how powers can be broken down. For example: \\(2^{2} = 2 * 2\\). Extending this, \\(2^{3} = 2 * 2 * 2\\). This can be rewritten as \\(2^{3} = 2 * 2^{2}\\). We can extend this further: \\(2^{4} = 2 * 2^{3}\\). Notice how the exponents can be repeatedly broken down into smaller exponents. The trick is to see if the base case is eventually reached.\nLet’s take a look at the first example again: \\(2^{2} = 2 * 2\\). Technically, \\(2^{2} = 2 * 2^{1}\\). And \\(2^{1} = 2 * 2^{0}\\)! So the base case can eventually be reached. We can now formally define a recurrence relation for some function Pow(x, y) as follows:\n\\[\\begin{equation}\nPow(x, y) =\n   \\left\\{\\begin{array}{lr}\n       1 &\\text{, if } y = 0\\\\\n       x*Pow(x, y-1) &\\text{, otherwise}\n    \\end{array}\\right.\n\\end{equation}\\]\nLet’s see if it works with an example: 25 (which is 32). In the recurrence relation above, we would call the function with Pow(2, 5). Since y is not zero, the second (recursive) case is applied resulting in 2 * Pow(2, 4). To calculate Pow(2, 4), the second case is applied again resulting in 2 * Pow(2, 3). And to calculate Pow(2, 3), we apply the second case another time which results in 2 * Pow(2, 2). We have to apply the second case a few more times: first with Pow(2, 2) which results in 2 * Pow(2, 1), and lastly with Pow(2, 1) which results in 2 * Pow(2, 0). At this point, the first (base) case is applied (since y is 0) resulting in 1. We can now build it all back up: 1 * 2 * 2 * 2 * 2 * 2 = 32.\nPerhaps this is best illustrated as follows; first with the recursive calls:\nPow(2, 5)\n 2 * Pow(2, 4)\n  2 * Pow(2, 3)\n   2 * Pow(2, 2)\n    2 * Pow(2, 1)\n     2 * Pow(2, 0)\nNow let’s build the result back up:\nPow(2, 5) 32\n 2 * Pow(2, 4) 16\n  2 * Pow(2, 3) 8\n   2 * Pow(2, 2) 4\n    2 * Pow(2, 1) 2\n     2 * Pow(2, 0) 1\nNotice how, at each step in the building back up, the result of the recursive calls combine to form simple arithmetic problems (e.g., 2 * Pow(2, 0) becomes 2 * 1 which equals 2). The arithmetic results form the answer to a previous recursive call (which is then replaced to form another simple arithmetic problem).\nHere’s another interesting mathematical function: the factorial. Let’s first look at its recursive definition:\n\\[\\begin{equation}\nFrac(n) =\n   \\left\\{\\begin{array}{lr}\n       1 &\\text{, if } n = 0\\\\\n       n*Frac(n-1) &\\text{, otherwise}\n    \\end{array}\\right.\n\\end{equation}\\]\nThe factorial function repeatedly multiplies some integer by all the integers below it (up to 1). For example, five factorial (referred to as 5!) = 5 * 4 * 3 * 2 * 1 = 120. To see how this works, let’s take a look at some examples:\n5! = 5 * 4 * 3 * 2 * 1 = 120\n4! = 4 * 3 * 2 * 1 = 24\n3! = 3 * 2 * 1 = 6\n2! = 2 * 1 = 2\n1! = 1\nNote how 4! is embedded within 5!:\n5! = 5 * 4 * 3 * 2 * 1\nAnd so on. In fact, we could say that 5! = 5 * 4!, and 4! = 4 * 3!, and 3! = 3 * 2!, and so on. This clearly breaks the problem down into smaller and smaller versions of itself. So what is the base case? Perhaps it’s just that 1! = 1. Although correct, mathematicians actually prefer 0! = 1 (as illustrated in the recurrence relation above). So the breaking down occurs as follows:\n5! = 5 * 4!\n4! = 4 * 3!\n3! = 3 * 2!\n2! = 2 * 1!\n1! = 1 * 0!\n0! = 1\nAnd now we can implement a recursive factorial function as follows:\ndef fact(n):\n    if (n == 0):\n        return 1\n    else:\n        return n * fact(n - 1)\nAnd to compute 5!:\nprint(\"5! = {}\".format(fact(5)))\nLet’s see how the recursion works as in the previous Pow example; first with the recursive calls:\nfact(5)\n 5 * fact(4)\n  4 * fact(3)\n   3 * fact(2)\n    2 * fact(1)\n     1 * fact(0)\nNext with the building back up:\nfact(5) 120\n 5 * fact(4) 24\n  4 * fact(3) 6\n   3 * fact(2) 2\n    2 * fact(1) 1\n     1 * fact(0) 1\n\n\n\n\n\n\n\nDid you know\n\n\n\nAlthough not always simple, any iterative algorithm can be converted to a recursive one and vice versa!\n\nTry implementing an iterative factorial algorithm (in Python)\nAnother interesting mathematical function is one that generates the Fibonacci sequence. Although it has been featured in a puzzle, no actual function was provided. Let’s take a look at the Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …\nA term in the sequence can be calculated as the sum of the two previous terms. For example, the seventh term (8) is the sum of the fifth and sixth terms (3 and 5). Here’s a recurrence relation for the Fibonacci sequence:\n\\[\\begin{equation}\nFib(n) =\n   \\left\\{\\begin{array}{lr}\n       0 &\\text{, if } n = 1\\\\\n       1 &\\text{, if } n = 2\\\\\n       Fib(n-1)+Fib(n-2) &\\text{, otherwise}\n    \\end{array}\\right.\n\\end{equation}\\]\nNote that this recurrence relation has two base cases! This is necessary since the recursion requires the sum of the two previous terms. The first term in the sequence, Fib(1), is 0 (the first base case). The second term in the sequence, Fib(2), is 1 (the second base case). The remaining terms are calculated recursively as the sum of the previous two terms, Fib(n – 1) + Fib(n – 2). Here’s how the recursion breaks down for Fib(6) (which equals 5). Since there are multiple branches of recursion (i.e., two parts to each recursive call), we’ll use a different method to show the recursion:\n\n\n\n\n\nAt the top, Fib(6) breaks down to Fib(5) + Fib(4). The figure then takes on an upside-down tree-like structure. Note how, if flipped upside-down, the top would form a root. The root then splits into two branches, each of which split into two more branches, and so on. The values at the bottom of the figure form what are called leaves. These represent the base cases, all either Fib(1) or Fib(2). In a future lesson, we will discuss trees more formally.\nWe can build the result back up as follows:\n\n\n\n\n\nThe result (at the top) is, as expected, 5.\n\n\n\nAs noted earlier, crafting an algorithm for this puzzle is not as simple as it sounds. In fact, it is quite difficult to design an iterative algorithm for it. Let’s see if we can use recursion to our advantage. Consider the puzzle with three discs:\n\n\n\n\n\nSuppose that the destination tower is the one on the right. The middle tower will be used as a spare. In order to move all three discs from the source tower to the destination tower, we can think of first needing to move two discs (the top two, in fact) from the source tower to the spare tower:\n\n\n\n\n\nClearly this is not possible since we cannot move two discs simultaneously; however, let’s continue with this train of thought for a moment. Supposing that we have successfully done this, then we would need to move the single disc left on the source tower to the destination tower:\n\n\n\n\n\nAnd all that would be left to do is to move the two discs that are on the spare tower over to the destination tower:\n\n\n\n\n\nPuzzle solved! However, as mentioned we cannot move two discs simultaneously. However, let’s go back to the original state:\n\n\n\n\n\nIn order to move the two top discs from the source tower to the spare tower, we first need to move the single top disc from the source tower to the destination tower:\n\n\n\n\n\nWe can then move the second disc from the source tower to the spare tower:\n\n\n\n\n\nAnd we can finally move the small disc from the destination tower to the spare tower:\n\n\n\n\n\nIn a sense, the three disc puzzle (i.e., moving three discs from the source tower to the destination tower) is a two-disc puzzle (moving the two top discs from the source tower to the spare tower), followed by a one-disc puzzle (moving the largest disc from the source tower to the destination tower), and finished with a two-disc puzzle (moving the two discs left on the spare tower to the destination tower).\nBut of course, the two-disc puzzles are simply three one-disc puzzles! And a one-disc puzzle is simple: just move the disc from one tower to another. Moving one disc is, in fact, the base case of the Towers of Hanoi! Moving more than one disc can be broken down as a sequence of three smaller puzzles as follows:\n\nMove all but the bottom disc from the source tower to the spare tower;\nMove the largest disc from the source tower to the destination tower; and\nMove the discs on the spare tower to the destination tower.\n\nOr in general, given n discs:\n\nMove n – 1 discs from source to spare;\nMove 1 disc from source to destination; and\nMove n – 1 discs from spare to destination.\n\nWe can design a recursive algorithm in Python as follows:\ndef hanoi(n, src, dst, spr):\n    if (n == 1):\n        print(\"{} -&gt; {}\".format(src, dst))\n    else:\n        hanoi(n - 1, src, spr, dst)\n        hanoi(1, src, dst, spr)\n        hanoi(n - 1, spr, dst, src)\nNote the parameters in the function hanoi. The variable n specifies the number of discs. The variables src, dst, and spr refer to the three towers. We can execute the algorithm and call the hanoi function (with three discs from a source tower A to a destination tower C using a spare tower B) as follows:\nhanoi(3, \"A\", \"C\", \"B\")\nHere is the output:\nA -&gt; C\nA -&gt; B\nC -&gt; B\nA -&gt; C\nB -&gt; A\nB -&gt; C\nA -&gt; C\nThe recursive function does require a little bit of explanation. Let’s take a look at the initial call to the function again:\nhanoi(3, \"A\", \"C\", \"B\")\nWhen this call occurs, the actual parameters, 3, “A”, “C”, and “B”, are passed in (or mapped) to the formal parameters, n, src, dst, and spr. To be clear, the source tower is A, and the destination tower is C. The first part of the recursive function, representing the base case when n = 1, is clear: simply move the single disc from src to dst. This is accomplished by displaying the move to the console\nprint(\"{} -&gt; {}\".format(src, dst))\nIf n &gt; 1, the recursive step is applied:\nhanoi(n - 1, src, spr, dst)\nhanoi(1, src, dst, spr)\nhanoi(n - 1, spr, dst, src)\nThat is, to move n discs from src to dst using spr, we must first move n – 1 discs from src to spr (using dst as the temporary spare tower), then move one disc from src to dst, and finally move the n – 1 discs moved previously from spr to dst (using src as the temporary spare tower). Let’s look at the first call only along with the function definition:\ndef hanoi(n, src, dst, spr):\n    ...\n    hanoi(n - 1, src, spr, dst)\nIn this call, the actual parameter, n – 1, is mapped to the formal parameter, n. So whatever n is in the function, when it is called again, it is with n – 1. Similarly, src is mapped to src (since moving n discs from some source results in moving n – 1 discs from that source first). The n – 1 discs, however, are moved to the spare tower (to get them out of the way). So the call maps spr as the actual parameter to dst as the formal parameter. Lastly, dst is mapped to spr. That is, the destination tower is temporarily used as the spare tower when moving the n – 1 discs out of the way.\nPerhaps this is best viewed dynamically, as each call is made. Let’s illustrate this with a simple puzzle with two discs:\nhanoi(2, \"A\", \"C\", \"B\")\nThis call results in the following variable values:\n\n\n\nn\nsrc\ndst\nspr\n\n\n\n\n2\nA\nC\nB\n\n\n\nThe recursive step is then applied, which results in the following three recursive calls:\n    1  A B  C\nhanoi(n - 1, src, spr, dst)\n    A  B C\nhanoi(1, src, dst, spr)\n    1  B C  A\nhanoi(n - 1, spr, dst, src)\nSince these are all one-disc puzzles, the base case is applied each time (which simply displays the move to the console). The first recursive call results in the the following variable values:\n\n\n\nn\nsrc\ndst\nspr\n\n\n\n\n1\nA\nB\nC\n\n\n\nIt therefore displays the following move: A → B. The second recursive call results in the the following variable values:\n\n\n\nn\nsrc\ndst\nspr\n\n\n\n\n1\nA\nC\nB\n\n\n\nIt therefore displays the following move: A → C. The third recursive call results in the the following variable values:\n\n\n\nn\nsrc\ndst\nspr\n\n\n\n\n1\nB\nC\nA\n\n\n\nIt therefore displays the following move: B → C. The three moves do, in fact, solve the two-disc puzzle. Note that the values for the three towers can be anything. The strings “A”, “B”, and “C” were used above; however, the integers 1, 2, and 3 would work just as well. If we wish, we can display the moves required for puzzles with one through four discs as follows:\nfor i in range(1, 5):\n    print(\"The Towers of Hanoi with {} disc(s):\".format(i))\n    hanoi((i, \"A\", \"C\", \"B\")\n    print()\nThe output of this modified algorithm is:\nThe Towers of Hanoi with 1 disc(s):\nA -&gt; C\n\nThe Towers of Hanoi with 2 disc(s):\nA -&gt; B\nA -&gt; C\nB -&gt; C\n\nThe Towers of Hanoi with 3 disc(s):\nA -&gt; C\nA -&gt; B\nC -&gt; B\nA -&gt; C\nB -&gt; A\nB -&gt; C\nA -&gt; C\n\nThe Towers of Hanoi with 4 disc(s):\nA -&gt; B\nA -&gt; C\nB -&gt; C\nA -&gt; B\nC -&gt; A\nC -&gt; B\nA -&gt; B\nA -&gt; C\nB -&gt; C\nB -&gt; A\nC -&gt; A\nB -&gt; C\nA -&gt; B\nA -&gt; C\nB -&gt; C"
  },
  {
    "objectID": "lessons/01 More Python/02 Formal vs Actual Parameters.html",
    "href": "lessons/01 More Python/02 Formal vs Actual Parameters.html",
    "title": "Formal vs Actual Parameters",
    "section": "",
    "text": "You have seen that a function can have parameters. These parameters are formally stated when the\nfunction is defined; for example:\ndef average(a, b):   \n     return (a + b) / 2.0   \nHere, the variables a and b are formally defined as parameters that must be passed in to the function average when it is called. In this context, the variables a and b are called formal parameters. It is where they are defined (in a formal manner).\n\n\n\n\n\n\nDefinition\n\n\n\nFormal parameters are formally defined as part of the function header.\n\n\nNow consider a point in the source code where this function is called; for example:\navg = average(11, 67)\nHere, the result of a call to the function average with the supplied values (or parameters) 11 and 67 is\nstored in the variable avg . These values, 11 and 67, are considered actual parameters in this context.\nThat is, they are the actual values that will be passed in as parameters to the function average.\n\n\n\n\n\n\nDefinition\n\n\n\nActual parameters (or arguments) are the actual values that are passed into a function.\n\n\nIn fact, they are mapped to the formally defined parameters (i.e., formal parameters) a and b in the\nfunction average. That function will use these values to make calculations and return the average of\nthe two. The value returned replaces the function call. Think of this replacement as follows:\navg = average(11, 67) \n            39.0   \n\nTherefore, the variable avg is assigned the value 39.0 after the call to the function average is\ncomplete. Consider this call to the same function:\nx = 11   \ny = 67   \navg = average(x, y)   \nHere, the result is still the same. The average of the two variables, x and y (with the values 11 and 67\nrespectively), is stored in the variable avg . Here, x and y are also actual parameters (even if they are\nvariables themselves) because they represent the actual values supplied to the function average.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Formal vs Actual Parameters"
    ]
  },
  {
    "objectID": "lessons/01 More Python/07 String Methods.html",
    "href": "lessons/01 More Python/07 String Methods.html",
    "title": "String Methods",
    "section": "",
    "text": "Strings are often necessary when writing programs. As such, Python provides a variety of methods that work on strings. You have already seen one such method, format() , that formats a string as specified (we did this earlier in one variant of the print statement). The following code block lists some of the more useful string methods:\nstr.capitalize()    # capitalizes the first character of a string   \nstr.find()          # returns the first index of a string within another string   \nstr.format()        # formats a string according to a specification   \nstr.isdigit()       # determines if a string consists only of numeric characters   \nstr.lower()         # converts a string to lowercase   \nstr.replace()       # replaces all occurrences of a string (within a string) with another string   \nstr.split()         # returns a list of the words in a string   \nstr.upper()         # converts a string to uppercase \nThese string methods are explained in greater detail in a variety of online sources. We suggest that you\nGoogle them and try them out. However, here are a few examples in IDLE:\n&gt;&gt;&gt;  s = \"So, when is this going to get difficult?\"   \n&gt;&gt;&gt;  s   \n'So, when is this going to get difficult?'   \n&gt;&gt;&gt;  s.capitalize()   \n'So, when is this going to get difficult?'   \n&gt;&gt;&gt;  s.find(\"going\")   \n17   \n&gt;&gt;&gt;  s.isdigit()   \nFalse   \n&gt;&gt;&gt;  s.lower()   \n'so, when is this going to get difficult?'   \n&gt;&gt;&gt;  s.upper()   \n'SO, WHEN IS THIS GOING TO GET DIFFICULT?'   \n&gt;&gt;&gt;  s.replace( \"difficult\" ,  \"easy\" )   \n'So, when is this going to get easy?'   \n&gt;&gt;&gt;  s.split()   \n['So,', 'when', 'is', 'this', 'going', 'to', 'get', 'difficult?'] \n&gt;&gt;&gt;  s . split( \"i\" )   \n['So, when ', 's th', 's go', 'ng to get d', 'ff', 'cult?']   \nNote the execution of the string method str.find() above: s.find(\"going\") . This string method returns the first index of the string, “going”, within the string, s . Why is the result 17? At first glance, it seems that the first character of the string, “going”, is at position 18. However, strings are sequences (just like lists); therefore, the characters of a string in Python begin at index 0.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "String Methods"
    ]
  },
  {
    "objectID": "lessons/01 More Python/08 External Libraries.html",
    "href": "lessons/01 More Python/08 External Libraries.html",
    "title": "Importing External Libraries",
    "section": "",
    "text": "It is often useful (and necessary) to import external functionality into our programs. In fact, you’ve seen (and used) this before (in the lesson Introduction to Data Structures), although it may not have been explained in detail. Often, others have designed functions and other bits of code that may prove useful. We don’t always want to recreate things that already exist. Python supports the importing of such things via the import reserved word. For example, many of the programs we create require the use of mathematical functions beyond simple arithmetic (e.g., sin, cos, tan) or mathematical constants (e.g., pi, e). The structure of an import statement is as follows:\nimport library\nPretty simple. Here’s an example of the importing and use of the math library:\nimport math   \nprint(math.pi)             # outputs 3.141592653589793   \nprint(math.e)              # outputs 2.718281828459045   \nprint(math.sin(math.pi))   # outputs 1.2246467991473532e-16   (virtually 0)\nprint(math.cos(math.pi))   # outputs -1.0   \nprint(math.log(1000))      # outputs 6.907755278982137   \nprint(math.log(math.e))    # outputs 1.0 \nAny value or function used in a library must be fully qualified with the name of the library (e.g., we need to specify math.pi and not just pi ). Alternatively, we can itemize what we wish to import from a library. This allows us to use values and functions directly without having to specify the library name. The structure of such an import statement is as follows:\nfrom library import function1, function2, constant1, constant2  # and so on\nFor example, the previous code block could have been written as follows:\nfrom math import pi, e, sin, cos, log\nprint(math.pi)             # outputs 3.141592653589793   \nprint(math.e)              # outputs 2.718281828459045   \nprint(math.sin(math.pi))   # outputs 1.2246467991473532e-16   (virtually 0)\nprint(math.cos(math.pi))   # outputs -1.0   \nprint(math.log(1000))      # outputs 6.907755278982137   \nprint(math.log(math.e))    # outputs 1.0    \nFormally, Python calls its libraries modules. And we can even write our own modules! They are just Python programs that typically provide definitions of constants and functions that other Python programs import and make use of. Python modules just need to be saved as a .py file and located in the same folder/directory as a Python program that needs to make use of it. For example, we could include several useful functions in a file called my_goodies.py. Suppose that it contained the following:\n# my_goodies.py\n\nfrom time import time   \n\n# starts a timer   \ndef start_time():   \n    global start   \n    start = time()   \n\n# stops the timer and returns the time elapsed   \ndef stop_time():   \n    stop = time()   \n    elapsed = stop - start   \n    return  elapsed   \nThe purpose of this example module is to use it to time how long algorithms take to execute. It’s quite simple. The function start_time effectively starts a timer (through the time library’s time function) by capturing the current “time” – which is essentially the number of seconds elapsed since an epoch defined in your operating system. For Unix and Unix-like operating systems (e.g., the “flavor” of Linux used on the Raspberry Pi), the epoch is 1970-01-01 00:00:00. The function stop_time captures the current time again (this time, after the algorithm has finished), and calculates and returns the difference between the two. We can make use of this module as follows:\n# my_goodies_test.py\n\nfrom my_goodies import start_time, stop_time   \n\n# start a timer   \nstart_time()   \n\n# do something that takes a little time   \nfor i in range(100000000):   \n    pass   \n\n# stop the timer   \nduration = stop_time()  \n\n# display how long it took   \nprint(\"Algorithm took {} seconds.\".format(duration))   \nNote that the “algorithm” in the test code above really does nothing. It’s just there to take up some noticeable amount of time so that the module can be tested. Here’s a sample run:\n~$ python my_goodies_test.py    \nAlgorithm took 5.71634602547 seconds.",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "External Libraries"
    ]
  },
  {
    "objectID": "lessons/01 More Python/03 Variable Scope.html",
    "href": "lessons/01 More Python/03 Variable Scope.html",
    "title": "Variable Scope",
    "section": "",
    "text": "Consider the following Python program snippet:\n# global variables\na = 10\nb = 20\n\n# functions\ndef f(x):   \n    a = 11   \n    b = 21   \n    x *= 2   \n    print(f\"in f(): a={a}, b={b}, x={x}\")  \n\ndef g():   \n    global a \n    a *= 1.5 \n    print(f\"in g(): a={a}, b={b}\")\n\n# main\nf(b)   \nprint(f\"in main: a={a}, b={b}\")\n\ng() \nprint(f\"in main: a={a}, b={b}\") \nThe variables a and b in the code above are considered global variables.\n\n\n\n\n\n\nDefinition\n\n\n\nGlobal variables are accessible throughout the entire program because they are defined\noutside of any block context (e.g., a loop construct, a function, etc).\n\n\nGlobal variables can be accessed anywhere. Their scope is global (i.e., throughout the entire program).\n\n\n\n\n\n\nDefinition\n\n\n\nA variable’s scope is the region of code that variable is accessible in.\n\n\nTake a look at the output of the program above:\nin f(): a=11, b=21, x=40   \nin main: a=10, b=20   \nin g(): a=15.0, b=20   \nin main: a=15.0, b=20   \nLet’s explain the output. Initially, the variable a is assigned the value 10 and the variable b is assigned the value 20. The next segment of code defines the functions f and g. These are only definitions (i.e., the statements are not actually interpreted or executed at this point).\nWhat follows is a call to the function f, passing the variable b as an actual parameter. Control is then transferred to the function f, whose statements are now executed. Note that, to the function f , the variable x is the formal parameter that takes on the value passed in (from the variable b ). So the variable x is now equal to the value of the variable b (i.e., 20) that was passed in at the point of the call to f. Note that the variable x is local to the function f; therefore, it is considered a local variable . That is, it is defined in f and only accessible in f – its scope is valid only in the function f.\n\n\n\n\n\n\nDefinition\n\n\n\nA local variable is a variable defined in (and therefore only accessible in) a local region/context. For example, a variable defined inside a function is local to that function and therefore only accessible within that function.\n\n\nAlso note that, although a and b are global, there are local versions declared in f. It is important to note\nthat these are different variables than the global versions – even if they have the same name!\n\n\n\n\n\n\nDefinition\n\n\n\nShadowing is the process of introducing a local variable that shares the same name as a global variable. This local variable “shadows” (or hides) access to the global variable of the same name. We will see this concept appear again later in the course, but with a different context.\n\n\nSo what happens in f? The local variable a is initialized with the value 11, the local variable b is initialized with the value 21, and the local variable x (which is passed in as an argument with the value 20) is doubled to 40. The output of the function f is then clear:\nin f(): a=11, b=21, x=40\nOnce f completes and control is transferred back to the point at which function f was called, the variable x is no longer accessible! In fact, let’s alter the print statement immediately after the call to f from:\nprint(f\"in main: a={a}, b={b}\")   \nAnd change it to:\nprint(f\"in main: a={a}, b={b}, x={x}\")   \nHere’s the output of the program now:\nin f(): a=11, b=21, x=40   \nTraceback (most recent call last):   \n  File \"scope.py\", line 11, in &lt;module&gt;   \n    print(\"in main: a={}, b={}, x={}\".format(a, b, x))   \nNameError: name 'x' is not defined   \nNotice the error indicating that the variable x is not defined. That’s because it was defined in f; however, the current context is outside of f. The variable x is no longer available once f finishes and control is transferred back to the main part of the program. Let’s replace the print statement to remove the error and explain the rest of the output from the original execution of the program:\nin main: a=10, b=20   \nin g(): a=15.0, b=20   \nin main: a=15.0, b=20  \nOnce control is transferred back to the main part of the program, the local variables a and b (in f) no longer exist. However, the global variables a and b do! They were initialized to 10 and 20 respectively. Therefore, the next line of output makes sense:\nin main: a=10, b=20   \nThe next part of the program calls g. Note the global keyword in the function g. This instructs Python to reference a globally defined version of the variable that follows the global keyword. That is, a local version is not defined and/or initialized. Instead, the global version is directly referenced. Moreover (and quite importantly), it permits the global version to be changed. Although there are no arguments to the function g , the global variable a is directly modifiable through the global keyword. When the statement a *= 1.5 is executed, the value of the global variable a is 10. This statement changes its value to 15.0, directly updating the variable’s value – globally!\nNote the print statement in g. It refers both to the variables a and b . A reference to the variable a makes sense; however, the variable b is also accessible. In fact, the variable b is referencing the global version of b, similar to the variable a (i.e., it is directly readable). The difference in using the global keyword is that it permits a change to the variable; without it, it can only be utilized in a read-only manner. Since the global variable b is initialized with the value 20, the output in g is clear:\nin g(): a=15.0, b=20   \nWhen control is transferred back to the main part of the program, changes to global variable a persist\n(even if they were changed in a function!):\nin main: a=15.0, b=20 \nTo illustrate this even more, let’s slightly change the function g as follows:\ndef g():   \n    global a   \n    a *= 1.5   \n    b = 40   \n    print(f\"in g(): a={a}, b={b}\")   \nNote the slight difference: b is declared and initialized with the value 40. Which b is this? Is it a local version (i.e., local to g)? Or is it referring to the global version declared in the main part of the program? Recall that, without the global keyword, a global variable can not be modified. Therefore, an assignment statement in a function to a variable that has the same name as a global variable indicates that the variable is a new instance, defined locally in the function. This is a different variable b! The output in g is clear:\nin g(): a=15.0, b=40   \nWhen control is transferred back to the main part of the program, the local version of b disappears. Allthat’s left is the global version (that remains unchanged at 20). Therefore, the output in the main part of the program is also clear:\nin main: a=15.0, b=20",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Variable Scope"
    ]
  },
  {
    "objectID": "lessons/01 More Python/03 Variable Scope.html#global-vs-local-variables",
    "href": "lessons/01 More Python/03 Variable Scope.html#global-vs-local-variables",
    "title": "Variable Scope",
    "section": "",
    "text": "Consider the following Python program snippet:\n# global variables\na = 10\nb = 20\n\n# functions\ndef f(x):   \n    a = 11   \n    b = 21   \n    x *= 2   \n    print(f\"in f(): a={a}, b={b}, x={x}\")  \n\ndef g():   \n    global a \n    a *= 1.5 \n    print(f\"in g(): a={a}, b={b}\")\n\n# main\nf(b)   \nprint(f\"in main: a={a}, b={b}\")\n\ng() \nprint(f\"in main: a={a}, b={b}\") \nThe variables a and b in the code above are considered global variables.\n\n\n\n\n\n\nDefinition\n\n\n\nGlobal variables are accessible throughout the entire program because they are defined\noutside of any block context (e.g., a loop construct, a function, etc).\n\n\nGlobal variables can be accessed anywhere. Their scope is global (i.e., throughout the entire program).\n\n\n\n\n\n\nDefinition\n\n\n\nA variable’s scope is the region of code that variable is accessible in.\n\n\nTake a look at the output of the program above:\nin f(): a=11, b=21, x=40   \nin main: a=10, b=20   \nin g(): a=15.0, b=20   \nin main: a=15.0, b=20   \nLet’s explain the output. Initially, the variable a is assigned the value 10 and the variable b is assigned the value 20. The next segment of code defines the functions f and g. These are only definitions (i.e., the statements are not actually interpreted or executed at this point).\nWhat follows is a call to the function f, passing the variable b as an actual parameter. Control is then transferred to the function f, whose statements are now executed. Note that, to the function f , the variable x is the formal parameter that takes on the value passed in (from the variable b ). So the variable x is now equal to the value of the variable b (i.e., 20) that was passed in at the point of the call to f. Note that the variable x is local to the function f; therefore, it is considered a local variable . That is, it is defined in f and only accessible in f – its scope is valid only in the function f.\n\n\n\n\n\n\nDefinition\n\n\n\nA local variable is a variable defined in (and therefore only accessible in) a local region/context. For example, a variable defined inside a function is local to that function and therefore only accessible within that function.\n\n\nAlso note that, although a and b are global, there are local versions declared in f. It is important to note\nthat these are different variables than the global versions – even if they have the same name!\n\n\n\n\n\n\nDefinition\n\n\n\nShadowing is the process of introducing a local variable that shares the same name as a global variable. This local variable “shadows” (or hides) access to the global variable of the same name. We will see this concept appear again later in the course, but with a different context.\n\n\nSo what happens in f? The local variable a is initialized with the value 11, the local variable b is initialized with the value 21, and the local variable x (which is passed in as an argument with the value 20) is doubled to 40. The output of the function f is then clear:\nin f(): a=11, b=21, x=40\nOnce f completes and control is transferred back to the point at which function f was called, the variable x is no longer accessible! In fact, let’s alter the print statement immediately after the call to f from:\nprint(f\"in main: a={a}, b={b}\")   \nAnd change it to:\nprint(f\"in main: a={a}, b={b}, x={x}\")   \nHere’s the output of the program now:\nin f(): a=11, b=21, x=40   \nTraceback (most recent call last):   \n  File \"scope.py\", line 11, in &lt;module&gt;   \n    print(\"in main: a={}, b={}, x={}\".format(a, b, x))   \nNameError: name 'x' is not defined   \nNotice the error indicating that the variable x is not defined. That’s because it was defined in f; however, the current context is outside of f. The variable x is no longer available once f finishes and control is transferred back to the main part of the program. Let’s replace the print statement to remove the error and explain the rest of the output from the original execution of the program:\nin main: a=10, b=20   \nin g(): a=15.0, b=20   \nin main: a=15.0, b=20  \nOnce control is transferred back to the main part of the program, the local variables a and b (in f) no longer exist. However, the global variables a and b do! They were initialized to 10 and 20 respectively. Therefore, the next line of output makes sense:\nin main: a=10, b=20   \nThe next part of the program calls g. Note the global keyword in the function g. This instructs Python to reference a globally defined version of the variable that follows the global keyword. That is, a local version is not defined and/or initialized. Instead, the global version is directly referenced. Moreover (and quite importantly), it permits the global version to be changed. Although there are no arguments to the function g , the global variable a is directly modifiable through the global keyword. When the statement a *= 1.5 is executed, the value of the global variable a is 10. This statement changes its value to 15.0, directly updating the variable’s value – globally!\nNote the print statement in g. It refers both to the variables a and b . A reference to the variable a makes sense; however, the variable b is also accessible. In fact, the variable b is referencing the global version of b, similar to the variable a (i.e., it is directly readable). The difference in using the global keyword is that it permits a change to the variable; without it, it can only be utilized in a read-only manner. Since the global variable b is initialized with the value 20, the output in g is clear:\nin g(): a=15.0, b=20   \nWhen control is transferred back to the main part of the program, changes to global variable a persist\n(even if they were changed in a function!):\nin main: a=15.0, b=20 \nTo illustrate this even more, let’s slightly change the function g as follows:\ndef g():   \n    global a   \n    a *= 1.5   \n    b = 40   \n    print(f\"in g(): a={a}, b={b}\")   \nNote the slight difference: b is declared and initialized with the value 40. Which b is this? Is it a local version (i.e., local to g)? Or is it referring to the global version declared in the main part of the program? Recall that, without the global keyword, a global variable can not be modified. Therefore, an assignment statement in a function to a variable that has the same name as a global variable indicates that the variable is a new instance, defined locally in the function. This is a different variable b! The output in g is clear:\nin g(): a=15.0, b=40   \nWhen control is transferred back to the main part of the program, the local version of b disappears. Allthat’s left is the global version (that remains unchanged at 20). Therefore, the output in the main part of the program is also clear:\nin main: a=15.0, b=20",
    "crumbs": [
      "Lessons",
      "01 More Python",
      "Variable Scope"
    ]
  },
  {
    "objectID": "lessons/07 High Level Data Structures/01 Introduction.html",
    "href": "lessons/07 High Level Data Structures/01 Introduction.html",
    "title": "High Level Data Structures",
    "section": "",
    "text": "This lesson looks at the topic of data structures, which is concerned with the various ways that data can be organized within a computer program. Specifically, four common “high level” data structures are introduced: lists, stacks, queues, and trees. Each of these structures represents a way to organize data so that it may be applied to solve certain problems in an efficient manner. Three of these structures (lists, stacks, and queues) are linear in nature. That is, their items logically exist one after another in sequential order. The tree structure is non-sequential, in that its contents can not be meaningfully represented by a simple sequential listing."
  },
  {
    "objectID": "lessons/07 High Level Data Structures/01 Introduction.html#lists",
    "href": "lessons/07 High Level Data Structures/01 Introduction.html#lists",
    "title": "High Level Data Structures",
    "section": "Lists",
    "text": "Lists\nWhen designing algorithms to solve computing problems, it is rare that we do not, to some degree, store and manipulate data. Often, we need to store data in a list form. This has been observed in previous lessons (e.g., searching a list for some value, sorting a list using the insertion sort, etc). In fact, we have seen (and used) lists in Scratch and in Python to solve problems.\nIn general, a list groups values together in such a way that there is a first item in the list, a last item in the list, and some number of items in the middle of the list. Accessing any individual item in the list is permitted (using its position or index). There are generally two implementations of lists: array-based lists and linked lists.\nWe have already seen arrays in a previous lesson; however, let’s briefly review. Arrays are comparable to a numbered list such as a grocery list, a class roster, or a set of numbered drawers. They are used to store multiple instances of anything, as long as they are all of the same kind (i.e., all numbers, all letters, all images, all books, etc). Imagine these things being in some sort of order (i.e., we have a first thing, a last thing, and some number of things in between). The members of (or entries in) the array are called elements.\n\n\n\n\n\nThe order in which elements are stored in an array is important. This is because very often a programmer needs to access a specific element of an array, and in order to do that, its position relative to the first element of the array must be known. The position of an element is also referred to as its address, and the relative address (how far away from the first element it is) is called its index.\nAgain, the distinction between a value and its index is one that must be emphasized. A value refers to a piece of data stored in the array, and its index is the position in the array where that value is stored. The index represents where an element is, and the value represents what the element is. While the two are related, each of them will be of different importance to us depending on the scenario we are trying to solve.\nIn most programming languages, arrays must be declared along with their capacity (i.e., the maximum number of values that the array can contain). This is important because array elements are located in contiguous memory locations (i.e., next to each other in memory). Therefore, an array’s capacity is required in order to properly allocate all of the contiguous memory locations needed. This does, however, represent the array’s weakness. If we know how many items we will store in the array, then this is simple. But what if we don’t? We may purposely overestimate, but this wastes memory. What if we underestimate and fill the array? The cost of creating a new, larger array, and then duplicating the existing array to this new array can be quite large. The need for specifying an array’s capacity at declaration time is what motivated a tweak on implementing lists in programming languages. The result is the linked list.\nUnlike arrays, linked lists can grow or shrink as needed. Individual elements in a linked list are not necessarily stored in contiguous memory locations. The cost of this benefit is that some mechanism for linking each element in the list must exist. Ultimately, this mechanism requires additional memory; thus, linked lists require more space in memory than arrays do when storing the same data. However, this is offset by the convenience of only storing what is needed in the list at any one time.\nSince the elements in a linked list are not necessarily stored in contiguous memory locations, we must somehow link the elements in the list to one another. This requires extending the concept of element to include two components: actual data (i.e., some value) and a link (sometimes called “next” in code) to the next element in the list. This extended definition makes up what is called a node. Linked lists are made up of nodes, each of which stores data and a link to the next node in the linked list:\n\n\n\n\n\nIf each node in the list contains some data and a link to the next node, then we really only need to know the location of the first node in order to process each element in the list. From the first node, we can repeatedly following links to the next node, until the end of the list is reached:\n\n\n\n\n\nOf course, it does not necessarily have to look so pretty. The linked list above is drawn so that each element seems to be located in contiguous memory locations; however, we could just as easily have drawn the linked list like this:\n\n\n\n\n\nIn this case, the first node is still the one all the way to the left. The last node, however, is now the third from the left.\nThe first node in a linked list is known as its head. Knowing where the head is in a linked list is crucial.\nSo how do we know when to stop when, for example, we process each element in the list? That is, how do we know when we are at the last element in the list? The answer lies in the link component of the node. For clarity, you should know that the last node in a linked list is known as the tail. The link component of the tail of a linked list will always be nothing. In Python, we would say that its value would be equal to None. In other programming languages, we sometimes refer to this as null. For simplicity, the link component of the tail node is equivalent to 0.\nSo what does the link component of a node other than the tail actually store? It stores the memory address of the next node in the list! Perhaps this is best explained by creating a linked list, step-by-step, and showing what happens at each step. Let’s insert the values 5, 9, 2, 6, and 1 into a linked list. Inserting the value 5 first requires creating a new node with 5 as the data component and 0 as the link component (by default):\n\nOf course, this node must be stored somewhere in memory. Let’s randomly pick the memory address 5B44 (in hexadecimal). In addition, since this is the only node in the linked list so far, then it is at its head:\n\nSuppose that inserting the value 9 creates a new node that is stored at memory address 5B46:\n\nThe nodes must now be linked. Since this new node belongs after the head of the list (i.e., it is the second node inserted into the list), then we simply need to link the head to this new node as follows:\n\nNotice how the link component of the head contains the memory address of the next node in the list. This has the same effect as the following pictorial example:\n\nSince we know where the head of the linked list is located (by definition), then we can reach the second node by following the link (i.e., by moving the to memory address specified in the link component of the node).\nInserting the value 2 is similar. Suppose that the new node containing this value is stored at memory address 5B50:\n\nNotice how the link component of the node containing the value 9 correctly links it to the newly inserted node. Now let’s insert the value 6. Suppose that the new node is stored at memory address 5B52:\n\nFinally, let’s insert the value 1. Suppose that the new node is stored at memory address 5B48:\n\nNotice how we can start at the head of the linked list and follow the link components of each node, all the way through the tail. We know to stop at the tail because its link component is 0. Pictorially, this can be represented as follows:\n\nJust like arrays, linked lists can be used to implement searching and sorting algorithms. Processing each element is just as simple. Moving elements around, however, is a bit more complicated since it involves rearranging the link components of nodes to reflect a potentially new ordering of the elements in the list. For example, consider the problem of deleting the node containing the value 2:\n\nStarting at the head, we see that the node containing the value 2 is the third node in the list. To remove this node, we will need to change the node containing the value 9 (since it is linked to the node that we wish to delete). The solution is to change the link component of this node so that it is equivalent to the link component of the node that we wish to delete:\n\nThe node to be deleted is circled in red above. To remove it from the linked list, we simply need to copy its link component to the node that precedes it, thereby rerouting around it. After this action, the result is the following linked list (the grayed out node is no longer a part of the linked list): \nHere is a recap of terminology associated with a linked list:\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nNode\nAn element of a linked list that contains data and a link\n\n\nData\nThe value held within the node\n\n\nLink\nA way to reference the next node in the linked list\n\n\nHead\nAlways refers to the first node\n\n\nTail\nAlways refers to the last node\n\n\nTraversal\nVisiting all nodes from head to tail (can be used, for example, to print all data in the list)"
  },
  {
    "objectID": "lessons/07 High Level Data Structures/01 Introduction.html#stacks",
    "href": "lessons/07 High Level Data Structures/01 Introduction.html#stacks",
    "title": "High Level Data Structures",
    "section": "Stacks",
    "text": "Stacks\nStack data structures are used, among other things, to model the behavior of stacks of real-world objects. In order to understand this structure let’s begin by thinking about a simple stack of blocks:\n\n\n\n\n\nIn this stack, C is the top block, B is beneath C, and A is the bottom block. Assuming that the blocks were added one at a time, how must this stack have been built? First, the bottom block, A, must have been set, then B would have been placed on top of A, and finally C would have been placed on top of B. Note that the blocks must be added to the stack from bottom to top: A, then B, then C. The last block placed on the stack will be the top block.\nNow, let’s think about removing a block from the stack. As any child could demonstrate, the block that is most easily accessible is the top block (C in this case). Removing C from the stack leaves us with B sitting on top of A. It is interesting to note that the first item to be removed from the stack, C, was the last item added to the stack (remember the order in which the blocks were added). In fact, assuming that you don’t cheat and grab an item from the middle of the stack, the last item added on the stack would always be the first taken off. For this reason, stacks are known as Last-In, First-Out (LIFO) data structures.\nAs mentioned earlier, the stack data structure models the behavior of real-world stacks of objects. The two primary operations that can be applied to stack data structures are push and pop. The push operator is used to add a new item onto the top of the stack. The pop operator is used to remove the top item from the stack. Stack data structures do not support the removal of items from the middle of the stack. The stack of real-world blocks shown above could be modeled by applying the following operations to an initially empty stack data structure:\n    push A\n    push B\n    push C\nThe removal of C could subsequently be accomplished by issuing the pop command:\n    pop\nTo be more formal, the stack data structure can be defined as a specialized type of list (an ordered sequence of items) in which all insertions to and deletions from the list take place at one end. The end of the list where the insertions and deletions are performed is known as the top of the stack. Stacks are usually drawn vertically, so that the item at top of the stack appears literally as the topmost item in the structure; however, they could just as easily be drawn sideways or upside down.\nIn order to ensure that you have a clear understanding of the behavior of the stack data structure, consider the following sequence of stack operations and pictorial representations of the stack that would result after each operation is applied. Note again that the pop operation always removes the last item placed on the top of the stack:\n\n\n\n\n\nNow that you have some understanding of how stacks behave, it is natural to ask, “So what?” Why are stacks of interest to computer scientists? In the real world, we routinely encounter stacks of objects (e.g., CDs, dishes, bills). We use these stacks to temporarily hold objects until we are ready to use or process them in some way. One important characteristic of all stacks (both the real-world type and their software counterpart) is that, due to their LIFO nature, they reverse the order of the objects they hold. For example, if you place three CDs in a stack, AC/DC, then Iron Maiden, then Justin Bieber, and then play the top one, you will unfortunately be listening to Justin Bieber and not AC/DC. In everyday life, we tend to use stacks in situations where order is unimportant (e.g., for holding identical, non-perishable items like dinner plates).\nIn a similar manner, stack data structures are used by computer software to temporarily hold data objects until they can be processed by the computer. However, instead of deemphasizing the LIFO nature of stacks, in computing stacks tend to be used almost exclusively in situations where we specifically want to process items in the opposite order than they were added to the structure.\nOne common use of stacks in computing is to manage the execution of interruptible tasks. The utility of stacks for this purpose can easily be seen by a real-world analogy. Say that you are typing an English paper (task one) and the phone rings. You pick up the phone (i.e., place task one on the stack of on hold processes) and begin a conversation with a friend (task two). During this conversation you get a second phone call, so you put your friend on hold (i.e., place task two on the stack of on hold processes) and take a call from your mom (task three). After a brief talk with mom, you switch back to your friend (i.e., after task three completes, you pop task two off of the stack of on hold processes and restart it from the point you left off). Finally, after a not-so-brief conversation with your friend, you return to your English paper (i.e., after task two completes, you pop task one off of the stack of on hold processes and restart it where you left off).\nNote that in order to handle these interruptible tasks properly, a data structure such as a stack that incorporates LIFO behavior must be employed.\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry your hand at pushing the letters of the word PUPILS, one letter at a time, to a stack.\nNow pop each letter off of the stack, one at a time. While doing so, record each popped letter to see the word formed after the pop operations are complete and the stack is empty again.\n\n\n\nAs you can see, a stack can easily reverse a word. We can also use a stack to match parentheses in, for example, mathematical expressions. The basic idea is to scan through an expression, one character at a time, from left-to-right. Left (or open) parentheses are pushed on the stack. Right (or close) parentheses result in a pop (and a match of the left parenthesis that was just popped). Operators and operands are ignored.\nTake a look at the following expression and its resulting stack operations. To make it easier to follow, we’ll change the orientation of the stack so that the top is to the right:\na + b * (c + (d - e) / (f / g))\n\nSo long as the stack is empty at the end, all parentheses have been matched. Create the table for the following expression:\n(a + (b - c)\nAn error arises because the expression has been processed, but there is still an open parenthesis on the stack. Now create the table for the following expression:\n(a + b))\nAnother error arises because there is a close parenthesis left to process, but there is no matching open parenthesis on the stack (it is empty)."
  },
  {
    "objectID": "lessons/07 High Level Data Structures/01 Introduction.html#queues",
    "href": "lessons/07 High Level Data Structures/01 Introduction.html#queues",
    "title": "High Level Data Structures",
    "section": "Queues",
    "text": "Queues\nIn America, a waiting line (such as the kind you encounter at a bank or supermarket), is simply referred to as a line. In England and many other countries, a waiting line is called a queue (pronounced like the letter Q). The following illustrates a real-world queue that you might encounter at a local movie theater:\n\n\n\n\n\nPerson A is buying a ticket to see the next Star Wars movie. Persons B, C, D, and E are waiting in line to buy their tickets. The four of them are considered to be waiting in the queue. Since person A is in the process of buying his ticket, he is not considered to be part of the queue (i.e., he is not waiting). Person B is at the front, or head, of the queue, and will be the next person to be served. Person E is at the back, or end, of the queue, and must wait for everyone ahead to be served before being able to buy a ticket.\nQueues are known as First-In, First-Out (FIFO) data structures. Assuming that no one breaks or cuts in line, the first person to enter the queue will be the first person to leave the queue (and thus be the first person served). Queues are extremely useful, both in the real-world and in computing, because they enable us to control access to scarce resources (such as Star Wars tickets in the example above).\nThe queue data structure models the behavior of real-world queues. It supports two primary operations: enqueue and dequeue. The enqueue operation is used to add a new item to the back of the queue. This operator is analogous to a person getting in line. The dequeue operation is used to remove an item from the front of the queue. This operation is analogous to having the person at the head of the line step forward to be served (and then of course to purchase grossly overpriced and over-buttered popcorn and a soda).\nMore formally, a queue is a list in which all insertions take place at one end, the back of the queue, and all deletions take place at the opposite end, the front (or head) of the queue. The basic queue data structure does not allow the insertion or deletion of items from the middle. Thus, it does not support concepts like people breaking or cutting in line, or giving up and leaving because the line is too long.\nConsider the following sequence of operations applied to an initially empty queue, and the resulting queue configurations. In order to help clearly distinguish between the behavior of stacks verses queues, the same data presented in the (numeric) stack example above is used (along with the same pattern of operations applied to the structure). Notice that, even though the order of operations is the same in both of these examples, the contents of the two structures is quite different:\n\n\n\n\n\nHere is a recap of terminology associated with stacks and queues:\n\n\n\nTerm\nDefinition\n\n\n\n\nItem\nAn element within the stack or queue that contains a value\n\n\n\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nPush\nOperation to add an item to the top of the stack\n\n\nPop\nOperation to remove (and return) the item at the top of the stack\n\n\nTop\nAlways refers to the top item in the stack\n\n\n\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nEnqueue\nOperation to add an item to the back of the queue\n\n\nDequeue\nOperation to remove (and return) the item at the back of the queue\n\n\nFront\nAlways refers to the front item in the queue\n\n\nBack\nAlways refers to the back item in the queue"
  },
  {
    "objectID": "lessons/07 High Level Data Structures/01 Introduction.html#trees",
    "href": "lessons/07 High Level Data Structures/01 Introduction.html#trees",
    "title": "High Level Data Structures",
    "section": "Trees",
    "text": "Trees\nAlthough there are many different types of tree-like data structures, we will focus on the binary tree in this lesson. First, let’s recall the various searching algorithms that were discussed in previous lessons. One in particular was especially efficient on sorted data: the binary search. The binary search works well because it effectively halves the search space with each comparison. The strategy is to continuously pick the middle value in a portion of the list making up half of what is left to search through. Initially, the middle of the list is picked. If the specified value is not found, then the half of the list that it cannot be contained within is discarded, and the process repeats with the other half of the list. This idea of halving the search space with a single comparison is the foundation for the binary tree. Earlier, you learned that linked lists were made up of nodes that point to other nodes in a linear or sequential fashion. These other nodes could be considered neighbors. Reaching the nodes in a linked list is performed by following the link component of each node until the tail of the list is reached. One could maintain a sorted linked list and implement the binary search, for example. Binary trees are also made up of nodes; however, instead of a node containing a link to some next neighbor node, each node in a binary tree contains two link components. These link components are known as the node’s children. This represents a different relationship between nodes.\nPerhaps it is best to see what a tree actually looks like for reference:\n\n\n\n\n\nThe top node in the tree is known as the root of the tree. In a binary tree, each node has up to two children. In the tree above, the root node has two children (one to the left, and one to the right – which is usually where we place them). In turn, these two children have children of their own. This can continue many times; however, at some point there will be nodes at the bottom of the tree that do not have children. These nodes are known as leaf nodes. Collectively, they are referred to as the leaves of the tree.\nWhy is this data structure called a binary tree? Well, if we were to turn the image above upside-down, it would look kind of like a real tree with a root at the bottom that splits into branches. Each branch splits into more, and so on, until the leaves are reached. It is called a binary tree because each node in the tree has, at most, two children. As branches are followed down the tree, the tree repeatedly splits into two halves, much like the process behind the binary search.\nSometimes it is useful to only consider parts of the tree. These parts are known as subtrees:\n\n\n\n\n\nAlthough there is only a single root in a binary tree (always the node at the top of the tree), each subtree can be said to have a node that serves as its root. For example, the node labeled “left child” in the tree above can be said to be the root of the shaded subtree on the left.\nThe nodes in a binary tree are arranged in levels. A level can be said to be a horizontal slice of the binary tree. In the tree above, for example, the nodes labeled “left child” and “right child” are at the same level. In fact, they are at level 1. The root is at level 0. For a binary tree that is balanced (i.e., one that isn’t lopsided with too many extra nodes on any side), the number of levels is a function of the number of nodes. In a binary tree containing n nodes, there can be, at most, \\(⌈log_2n ⌉\\) levels. Intuitively, this makes sense since each level down the tree splits that part of the tree in half. In the tree above, there are 12 nodes; thus, there can be at most \\(⌈log_212⌉=⌈3.58⌉=4\\) . In fact, there are four levels in the tree!\nThe most useful binary trees implement an internal ordering of the nodes. Ordered binary trees are binary trees that abide by the rule that, given any node, the values of all children in the left subtree are less than the value of the node. Similarly, the values of all children in the right subtree are greater than (or sometimes greater than or equal to) the value of the node. This is also referred to as a binary search tree. Here is an example of an ordered binary tree:\n\n\n\n\n\nNotice that, for any node in the tree, the values of all children in its left subtree are less than the value of the node. Similarly, the values of all children in its right subtree are greater than the value of the node. For example, the values of all nodes to the left of the root are all less than seven, and the values of all nodes to the right of the root are all greater than 7.\nIf we were to place all nodes at the same level (i.e., all next to each other) and remove all links to children, this binary tree would look very much like a sorted array:\n\n\n\n\n\nNotice that we can easily implement a binary search! An ordered binary tree actually works very much the same way. To search for a value, we begin at the root and compare its value to the desired value. If the desired value is less than the value of the root, we follow the link to the left and continue. If the desired value is greater than the value of the root, we follow the link to the right and continue. This exactly replicates the behavior of the binary search. If we find a node that is equal to the desired value, then the search is successful. If we reach a leaf node that is not equal to the desired value, then the search is unsuccessful.\nAn interesting aspect of the binary tree is that we can use an array to represent one in memory. The root of the tree is placed at the first position in the array (i.e., at index 0). The children of any node are easily found as follows: • The left child of a node at index i is at index \\(2i+1\\) ; • The right child of a node at index i is at index \\(2i+2\\) ; and • The parent of a node at index i is at index \\(⌊(i−1)/2⌋\\) . Take a look at the previous tree again:\n\n\n\n\n\nThis tree can be represented by an array as follows:\n\n\n\n\n\nThe arrows are there to illustrate a few of the nodes and their children. For example, the root node is at index 0. Its children are at indexes \\(2(0)+1=1\\) and \\(2(0)+2=2\\) . This is illustrated by the arrows pointing from the root node in the array. As another example, the children of the node containing the value 2 (which is at index 3) are at indexes \\(2(3)+1=7\\) and \\(2(3)+2=8\\) . Nodes with missing children are still included in the array (i.e., space is left for the missing children). As a final example, the parent of the node containing the value 6 (which is at index 10) is at index \\(⌊(10−1)/2⌋=⌊9/2⌋=⌊4.5⌋=4\\). These are all confirmed in the tree above.\nHere is a recap of terminology associated with trees:\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nBinary Tree\nA tree where each node has at most two children\n\n\nNode\nAn element of a tree that contains data and references to all child nodes\n\n\nRoot\nAlways refers to the topmost node\n\n\nChildren\nNodes attached to a parent\n\n\nParent\nAny node with children\n\n\nLeaf\nA node that does not have any children (opposite of parent)\n\n\nSubtree\nA subset of attached nodes within a tree. The topmost node of a subtree forms the root of that subtree (or a “subroot” of the entire tree)\n\n\nLevel\nStarting at 0 for the root, the level of a node is how far down the tree that node is\n\n\nBalanced\nA tree whose maximum level is, at most, log base 2 of the number of nodes within the tree\n\n\nOrdered Binary Tree\nA binary tree with the extra property of having smaller values to the left and larger values to the right"
  }
]